---
title: Bash codes of 'practice'
bibliography: '`r system.file("extdata", "library.bib", package = "utils.tool")`'
csl: '`r system.file("extdata", "nature.csl", package = "utils.tool")`'
reference-section-title: "Reference"
link-citations: true
output:
  bookdown::pdf_document2:
    # pandoc_args: [
      # "--filter", "pandoc-fignos",
      # "--filter", "pandoc-tablenos"
    # ]
    keep_tex: true
    toc: true
    toc_depth: 3
    latex_engine: xelatex
header-includes:
  \usepackage{caption}
  \captionsetup{font={footnotesize},width=6in}
  \renewcommand{\dblfloatpagefraction}{.9}
  \makeatletter
  \renewenvironment{figure}
  {\def\@captype{figure}}
  \makeatletter
  \definecolor{shadecolor}{RGB}{242,242,242}
  \usepackage{xeCJK}
  \usepackage{setspace}
  \setstretch{1.3} 
---


# File: back_eucommia_analysis.sh

```{r eval = F, echo = T}
### Similar-fragmentation-network based multidimensional data analysis
mzmine_path="../0924_neg_RT.tsv.csv"
savepath="results/0924_neg_RT.tsv"
version=$(echo | awk '{l=asort(a,b);print l}')
 	if [ $version == 0 ]
 	then
 	mzmine_data=$(awk -F , '
 	 	{
 	 	if(NR==1)
 	 	 	{
 	 	 	for(i=4; i<=NF; i++)
 	 	 	 	{
 	 	 	 	col_sample[$i]=i
 	 	 	 	}
 	 	 	l=asorti(col_sample,b)
 	 	 	\
 	 	 	printf $1 "\t" $2 "\t" $3
 	 	 	\
 	 	 	for(i=1; i<l; i++)
 	 	 	 	{
 	 	 	 	printf b[i] "\t"
 	 	 	 	}
 	 	 	printf b[l] "\n"
 	 	 	}
 	 	if(NR>=2)
 	 	 	{
 	 	 	printf $1"\t" $2"\t" $3
 	 	 	\
 	 	 	for(i=1; i<l; i++)
 	 	 	 	{
 	 	 	 	printf $col_sample[b[i]] "\t"
 	 	 	 	}
 	 	 	printf $col_sample[b[l]] "\n"
 	 	 	}
 	 	}' $mzmine_path)
 	echo "$mzmine_data" > $savepath
 	fi;
```

```{r eval = F, echo = T}
#############
climit="0.95"
numlimit="0.2"
data1="results/canopus_pp_filter.tsv"
data2="r_network/mzmine_table.tsv"
compar1="Raw"
compar2="Pro"
log=10
log_to=2
stat=$(awk -F $'\t' -v OFS=$'\t' '
 	{
 	if(NR==1)
 	 	{
 	 	for(i=2; i<=NF; i++)
 	 	 	{
 	 	 	class[i]=$i
 	 	 	num[i]=0
 	 	 	}
 	 	}
 	if(NR>=2)
 	 	{
 	 	for(i=2; i<=NF; i++)
 	 	 	{
 	 	 	if($i>='$climit')
 	 	 	 	{
 	 	 	 	num[i]+=1;
 	 	 	 	id[i,NR]=$1;
 	 	 	 	}
 	 	 	}
 	 	}
 	}
 	END{
 	for(i=2; i<=NF; i++)
 	 	{
 	 	p=num[i]/(NR-1)
 	 	\
 	 	if(p<='$numlimit') #
 	 	 	{
 	 	 	printf class[i]"\t"  num[i]"\t"
 	 	 	\
 	 	 	for(j=2; j<=NR; j++)
 	 	 	 	{
 	 	 	 	if(id[i,j]!="")
 	 	 	 	 	{
 	 	 	 	 	printf id[i,j]"@";
 	 	 	 	 	}
 	 	 	 	}
 	 	 	printf "\n"
 	 	 	}
 	 	}
 	}' $data1 | sed 's/@$//g')
awk -F ["\t"@] -v OFS=$'\t' '
 	BEGIN{
 	 	maxNF=0
 	 	\
 	 	rows=0
 	 	\
 	 	compar1n=0
 	 	\
 	 	compar2n=0
 	 	}
 	{
 	if(NR==FNR)
 	 	{
 	 	rows+=1
 	 	if(maxNF<NF)
 	 	 	{
 	 	 	maxNF=NF
 	 	 	}
 	 	class[FNR]=$1
 	 	\
 	 	num[FNR]=$2
 	 	\
 	 	for(j=3; j<=NF; j++)
 	 	 	{
 	 	 	id[FNR,j]=$j
 	 	 	}
 	 	}
 	else
 	 	{
 	 	if(FNR==1)
 	 	 	{
 	 	 	for(i=1; i<=NF; i++)
 	 	 	 	{
 	 	 	 	if(($i~/'$compar1'/))
 	 	 	 	 	{
 	 	 	 	 	colum1[i]=i
 	 	 	 	 	compar1n+=1
 	 	 	 	 	}
 	 	 	 	if(($i~/'$compar2'/))
 	 	 	 	 	{
 	 	 	 	 	colum2[i]=i
 	 	 	 	 	compar2n+=1
 	 	 	 	 	}
 	 	 	 	if(($i~/retention/))
 	 	 	 	 	{
 	 	 	 	 	rtcolum=i
 	 	 	 	 	}
 	 	 	 	if(($i~/m\/z/))
 	 	 	 	 	{
 	 	 	 	 	mzcolum=i
 	 	 	 	 	}
 	 	 	 	}
 	 	 	}
 	 	if(FNR>=2)
 	 	 	{
 	 	 	sum[1,$1]=0
 	 	 	\
 	 	 	sum[2,$1]=0
 	 	 	\
 	 	 	rt[$1]=$rtcolum
 	 	 	\
 	 	 	mz[$1]=$mzcolum
 	 	 	\
 	 	 	for(i=1; i<=NF; i++)
 	 	 	 	{
 	 	 	 	if(i==colum1[i] && colum1[i]!="")
 	 	 	 	 	{
 	 	 	 	 	sum[1,$1]+=$i
 	 	 	 	 	}
 	 	 	 	if(i==colum2[i] && colum2[i]!="")
 	 	 	 	 	{
 	 	 	 	 	sum[2,$1]+=$i
 	 	 	 	 	}
 	 	 	 	}
 	 	 	}
 	 	}
 	}
 	END{
 	 	printf "class\t"  "id\t"  "log'$log'_raw\t"  "log'$log'_pro\t" \
 	 	\
 	 	"log'$log'_delta_area\t"  "pro_to_raw\t"  "log'$log_to'_pro_to_raw\t"  "variety\t"  "number\t" > "boxplot.tsv"
 	 	\
 	 	printf "rt\t"  "m/z\n" >> "boxplot.tsv"
 	 	\
 	 	for(i=1; i<=rows; i++)
 	 	 	{
 	 	 	for(j=3; j<=maxNF; j++)
 	 	 	 	{
 	 	 	 	if(id[i,j]!="")
 	 	 	 	 	{
 	 	 	 	 	raw=(sum[1,id[i,j]]/compar1n)
 	 	 	 	 	\
 	 	 	 	 	pro=(sum[2,id[i,j]]/compar2n)
 	 	 	 	 	\
 	 	 	 	 	log_raw=log(raw)/log('$log')
 	 	 	 	 	\
 	 	 	 	 	log_pro=log(pro)/log('$log')
 	 	 	 	 	\
 	 	 	 	 	delta_area=pro-raw
 	 	 	 	 	\
 	 	 	 	 	if(raw!=0)
 	 	 	 	 	 	{
 	 	 	 	 	 	to_raw=pro/raw
 	 	 	 	 	 	\
 	 	 	 	 	 	norm_to_raw=log(to_raw)/log('$log_to')
 	 	 	 	 	 	}
 	 	 	 	 	else
 	 	 	 	 	 	{
 	 	 	 	 	 	to_raw="infinity"
 	 	 	 	 	 	\
 	 	 	 	 	 	norm_to_raw="infinity"
 	 	 	 	 	 	}
 	 	 	 	 	if(delta_area>0)
 	 	 	 	 	 	{
 	 	 	 	 	 	norm_delta=log(delta_area)/log('$log')
 	 	 	 	 	 	\
 	 	 	 	 	 	variety="increase"
 	 	 	 	 	 	}
 	 	 	 	 	else if(delta_area<0)
 	 	 	 	 	 	{
 	 	 	 	 	 	norm_delta=-1*(log(-1*delta_area)/log('$log'))
 	 	 	 	 	 	\
 	 	 	 	 	 	variety="decrease"
 	 	 	 	 	 	}
 	 	 	 	 	else
 	 	 	 	 	 	{
 	 	 	 	 	 	norm_delta=0
 	 	 	 	 	 	}
 	 	 	 	 	printf class[i]"\t"  id[i,j]"\t"  log_raw"\t"  log_pro"\t" \
 	 	 	 	 	\
 	 	 	 	 	norm_delta"\t"  to_raw"\t"  norm_to_raw"\t"  variety"\t"  num[i]"\t" \
 	 	 	 	 	\
 	 	 	 	 	rt[id[i,j]]"\t"  mz[id[i,j]]"\n" >> "boxplot.tsv"
 	 	 	 	 	}
 	 	 	 	}
 	 	 	}
 	 	}' <(echo "$stat") $data2
```

```{r eval = F, echo = T}
##############
keywords_1="lignans"
keywords_2="iridoids"
awk -F $'\t' -v OFS=$'\t' '
 	{
 	if(NR==1)
 	 	{
 	 	print "id","rt","m/z","classification","variety","pro/raw","log10_raw","norm_delta" > "lignans_and_iridoids.tsv"
 	 	\
 	 	for(i=1; i<=NF; i++)
 	 	 	{
 	 	 	if($i~/^id/)
 	 	 	 	{
 	 	 	 	col_id=i
 	 	 	 	}
 	 	 	if($i~/^rt/)
 	 	 	 	{
 	 	 	 	col_rt=i
 	 	 	 	}
 	 	 	if($i~/m\/z/)
 	 	 	 	{
 	 	 	 	col_mz=i
 	 	 	 	}
 	 	 	if($i~/class/)
 	 	 	 	{
 	 	 	 	col_class=i
 	 	 	 	}
 	 	 	if($i~/variety/)
 	 	 	 	{
 	 	 	 	col_variety=i
 	 	 	 	}
 	 	 	if($i~/^pro_to_raw/)
 	 	 	 	{
 	 	 	 	col_ratio=i
 	 	 	 	}
 	 	 	if($i~/log10_raw/)
 	 	 	 	{
 	 	 	 	col_log10_raw=i
 	 	 	 	}
 	 	 	if($i~/delta_area/)
 	 	 	 	{
 	 	 	 	col_delta=i
 	 	 	 	}
 	 	 	}
 	 	}
 	if((tolower($col_class)~/'$keywords_1'/) || (tolower($col_class)~/'$keywords_2'/))
 	 	{
 	 	print $col_id, $col_rt, $col_mz, $col_class, $col_variety, $col_ratio, $col_log10_raw, $col_delta >> "lignans_and_iridoids.tsv"
 	 	}
  	}' boxplot.tsv
data="results/fingerid_first_score.tsv"
list="lignans_and_iridoids.tsv"
awk -F $'\t' '	
 	{
 	if(NR==FNR)
 	 	{
 	 	if(FNR==1)
 	 	 	{
 	 	 	for(i=1; i<=NF; i++)
 	 	 	 	{
 	 	 	 	if($i~/^id/)
 	 	 	 	 	{
 	 	 	 	 	col_id=i
 	 	 	 	 	}
 	 	 	 	if($i~/similarity/)
 	 	 	 	 	{
 	 	 	 	 	col_simi=i
 	 	 	 	 	}
 	 	 	 	if($i~/name/)
 	 	 	 	 	{
 	 	 	 	 	col_name=i
 	 	 	 	 	}
 	 	 	 	if($i~/formula/)
 	 	 	 	 	{
 	 	 	 	 	col_formula=i
 	 	 	 	 	}
 	 	 	 	if($i~/^inchi$/)
 	 	 	 	 	{
 	 	 	 	 	col_inchi=i
 	 	 	 	 	}
 	 	 	 	if($i~/smiles/)
 	 	 	 	 	{
 	 	 	 	 	col_smiles=i
 	 	 	 	 	}
 	 	 	 	if($i~/score/)
 	 	 	 	 	{
 	 	 	 	 	col_score=i
 	 	 	 	 	}
 	 	 	 	if($i~/xlogp/)
 	 	 	 	 	{
 	 	 	 	 	col_xlogp=i
 	 	 	 	 	}
 	 	 	 	if($i~/inchikey2D/)
 	 	 	 	 	{
 	 	 	 	 	col_inchikey2D=i
 	 	 	 	 	}
 	 	 	 	if($i~/links/)
 	 	 	 	 	{
 	 	 	 	 	col_links=i
 	 	 	 	 	}
 	 	 	 	}
 	 	 	}
 	 	if(FNR>=2)
 	 	 	{
 	 	 	simi[$col_id]=$col_simi
 	 	 	\
 	 	 	name[$col_id]=$col_name
 	 	 	\
 	 	 	formula[$col_id]=$col_formula
 	 	 	\
 	 	 	smiles[$col_id]=$col_smiles
 	 	 	\
 	 	 	inchi[$col_id]=$col_inchi
 	 	 	\
 	 	 	inchikey2D[$col_id]=$col_inchikey2D
 	 	 	\
 	 	 	score[$col_id]=$col_score
 	 	 	\
 	 	 	xlogp[$col_id]=$col_xlogp
 	 	 	\
 	 	 	links[$col_id]=$col_links
 	 	 	}
 	 	}
 	if(NR!=FNR)
 	 	{
 	 	if(FNR==1)
 	 	 	{
 	 	 	for(i=1; i<=NF; i++)
 	 	 	 	{
 	 	 	 	if($i~/^id/)
 	 	 	 	 	{
 	 	 	 	 	col_list_id=i
 	 	 	 	 	}
 	 	 	 	printf $i"\t" > "com_lignans_and_iridoids.tsv"
 	 	 	 	}
 	 	 	printf "similarity\t"  "name\t"  "formula\t"  "xlogp\t"  "smiles\t" \
 	 	 	\
 	 	 	"inchi\t"  "inchikey2D\t"  "links\n" >> "com_lignans_and_iridoids.tsv"
 	 	 	}
 	 	if(FNR>=2)
 	 	 	{
 	 	 	for(i=1; i<=NF; i++)
 	 	 	 	{
 	 	 	 	printf $i"\t" >> "com_lignans_and_iridoids.tsv"
 	 	 	 	}
 	 	 	printf simi[$col_list_id]"\t"  name[$col_list_id]"\t"  formula[$col_list_id]"\t"  xlogp[$col_list_id]"\t" \
 	 	 	\
 	 	 	smiles[$col_list_id]"\t" inchi[$col_list_id]"\t"  inchikey2D[$col_list_id]"\t" \
 	 	 	\
 	 	 	links[$col_list_id]"\n" >> "com_lignans_and_iridoids.tsv"
 	 	 	}
 	 	}
 	}' $data $list
 ##################
 #sort 
 data_o="com_lignans_and_iridoids.tsv"
 data_r=$(cat <(head -n 1 $data_o) <(sort -t $'\t' -k 6 -n -r <(sed '1d' $data_o)))
 echo "$data_r" > com_lignans_and_iridoids.tsv
 ##################
 #data (MS1) idenfication
data1="../data_chi.tsv"
data2="../data_eng.tsv"
data3="com_lignans_and_iridoids.tsv"
tolerance=0.02 # mass_window
awk -F $'\t' '
 	{
 	if(max=="" || max<FNR)
 	 	{
 	 	max=FNR
 	 	}
 	if(NR==FNR)
 	 	{
 	 	if(FNR==1)
 	 	 	{
 	 	 	for(i=1; i<=NF; i++)
 	 	 	 	{
 	 	 	 	if($i~/Num/)
 	 	 	 	 	{
 	 	 	 	 	num=i
 	 	 	 	 	}
 	 	 	 	if($i~/Compound/)
 	 	 	 	 	{
 	 	 	 	 	compound=i
 	 	 	 	 	}
 	 	 	 	if($i~/Precursor/)
 	 	 	 	 	{
 	 	 	 	 	precursor=i
 	 	 	 	 	}
 	 	 	 	}
 	 	 	}
 	 	if(FNR>=2)
 	 	 	{
 	 	 	chi_num[FNR]=$num
 	 	 	\
 	 	 	chi_com[FNR]=$compound
 	 	 	\
 	 	 	chi_pre[FNR]=$precursor
 	 	 	}
 	 	}
 	if(FILENAME~/eng/)
 	 	{
 	 	if(FNR==1)
 	 	 	{
 	 	 	close("'$data1'")
 	 	 	\
 	 	 	for(i=1; i<=NF; i++)
 	 	 	 	{
 	 	 	 	if($i~/Num/)
 	 	 	 	 	{
 	 	 	 	 	num=i
 	 	 	 	 	}
 	 	 	 	if($i~/Compound/)
 	 	 	 	 	{
 	 	 	 	 	compound=i
 	 	 	 	 	}
 	 	 	 	if($i~/Precursor/)
 	 	 	 	 	{
 	 	 	 	 	precursor=i
 	 	 	 	 	}
 	 	 	 	}
 	 	 	}
 	 	if(FNR>=2)
 	 	 	{
 	 	 	eng_num[FNR]=$num
 	 	 	\
 	 	 	eng_com[FNR]=$compound
 	 	 	\
 	 	 	eng_pre[FNR]=$precursor
 	 	 	}
 	 	}
 	if(FILENAME~/com/)
 	 	{
 	 	if(FNR==1)
 	 	 	{
 	 	 	close("'$data2'")
 	 	 	\
 	 	 	printf $0"\t"  "ms1_candidate\n" > "identi_1_'$data3'"
 	 	 	\
 	 	 	for(i=1; i<=NF; i++)
 	 	 	 	{
 	 	 	 	if($i~/m\/z/)
 	 	 	 	 	{
 	 	 	 	 	mass=i
 	 	 	 	 	}
 	 	 	 	}
 	 	 	}
 	 	if(FNR>=2)
 	 	 	{
 	 	 	printf $0 "\t" >> "identi_1_'$data3'"
 	 	 	\
 	 	 	for(i=1; i<=max; i++)
 	 	 	 	{
 	 	 	 	if($mass>=chi_pre[i]-'$tolerance' && $mass<=chi_pre[i]+'$tolerance')
 	 	 	 	 	{
 	 	 	 	 	printf chi_num[i]  "_"  chi_com[i]  "_"  chi_pre[i]  " | " >> "identi_1_'$data3'"
 	 	 	 	 	}
 	 	 	 	if($mass>=eng_pre[i]-'$tolerance' && $mass<=eng_pre[i]+'$tolerance')
 	 	 	 	 	{
 	 	 	 	 	printf eng_num[i]  "_"  eng_com[i]  "_"  eng_pre[i]  " | " >> "identi_1_'$data3'"
 	 	 	 	 	}
 	 	 	 	}
 	 	 	printf "\n" >> "identi_1_'$data3'"
 	 	 	}
 	 	}
 	}' $data1 $data2 $data3
 ##############
 ##database idenfication 
 data1="../identi_1.tsv"
 data2="r_network/ms2_figures/*.tsv"
 data_origin="origin"
 database="../MSMS-Public-Neg-VS15.msp"
 data3="../database.msp"
 tolerance=0.01
 ms2_tolerance=0.2
 in_tolerance=20
 weight1=80
 weight2=20
 point_limit=80
 sed 's/\r//g' $database > ../database.msp
 awk -F $'\t' '
 	{
 	if(NR==FNR)
 	 	{
 	 	if(NR==1)
 	 	 	{
 	 	 	p_file=FILENAME
 	 	 	\
 	 	 	for(i=1; i<=NF; i++)
 	 	 	 	{
 	 	 	 	if($i~/^id/)
 	 	 	 	 	{
 	 	 	 	 	col_id=i
 	 	 	 	 	}
 	 	 	 	if($i~/m\/z/)
 	 	 	 	 	{
 	 	 	 	 	col_mz=i
 	 	 	 	 	}
 	 	 	 	}
 	 	 	}
 	 	if(NR>=2)
 	 	 	{
 	 	 	pre_mz[$col_id]=$col_mz
 	 	 	\
 	 	 	printf "info: datafile1 is ready. The data is " $col_id " to " $col_mz "\n"  #info
 	 	 	}
 	 	}
 	if(FILENAME~/ms2_figures/)
 	 	{
 	 	if(FNR==1)
 	 	 	{
 	 	 	close(p_file)
 	 	 	\
 	 	 	p_file=FILENAME
 	 	 	\
 	 	 	n=split(FILENAME,a,"[/]")
 	 	 	\
 	 	 	split(a[n],b,"[.]")
 	 	 	\
 	 	 	id=b[1]
 	 	 	\
 	 	 	printf "info: datafile2 is ready. The id number is " id "\n"  #info
 	 	 	}
 	 	if(FNR>=2)
 	 	 	{
 	 	 	if("'$data_origin'"=="sirius")
 	 	 	 	{
 	 	 	 	if($2+0<0)
 	 	 	 	 	{
 	 	 	 	 	count[id]+=1
 	 	 	 	 	\
 	 	 	 	 	data2_mz[id,count[id]]=$1
 	 	 	 	 	\
 	 	 	 	 	data2_in[id,count[id]]=$2*(-1)
 	 	 	 	 	\
 	 	 	 	 	printf "info: The ms2 peak is " count[id] " " $1 " " data2_in[id,count[id]] "\n"  #info
 	 	 	 	 	}
 	 	 	 	}
 	 	 	else
 	 	 	 	{
 	 	 	 	if($2+0>0)
 	 	 	 	 	{
 	 	 	 	 	count[id]+=1
 	 	 	 	 	\
 	 	 	 	 	data2_mz[id,count[id]]=$1
 	 	 	 	 	\
 	 	 	 	 	data2_in[id,count[id]]=$2
 	 	 	 	 	\
 	 	 	 	 	printf "info: The ms2 peak is " count[id] " " $1 " " data2_in[id,count[id]] "\n"  #info
 	 	 	 	 	}
 	 	 	 	}
 	 	 	}
 	 	}
 	if(FILENAME~/.msp/)
 	 	{
 	 	if(FNR==1)
 	 	 	{
 	 	 	msp_num+=1
 	 	 	\
 	 	 	FS="[:][ ]||[\t]"
 	 	 	\
 	 	 	close(p_file)
 	 	 	\
 	 	 	p_file=FILENAME
 	 	 	\
 	 	 	n=split($0,c,"[:][ ]")
 	 	 	\
 	 	 	name=c[n]
 	 	 	\
 	 	 	printf "info: datafile3 is ready. The first name is " name "\n"  #info
 	 	 	}
 	 	if(FNR>=2)
 	 	 	{
 	 	 	if($1~/NAME/)
 	 	 	 	{
 	 	 	 	if(belong_id[msp_num]+0>=1)
 	 	 	 	 	{
 	 	 	 	 	for(i=1; i<=database_count[msp_num]; i++)
 	 	 	 	 	 	{
 	 	 	 	 	 	mz=data3_mz[msp_num,i]
 	 	 	 	 	 	\
 	 	 	 	 	 	intensity=(data3_in[msp_num,i]/max_in[msp_num])*100
 	 	 	 	 	 	\
 	 	 	 	 	 	if(intensity+0>=5)
 	 	 	 	 	 	 	{
 	 	 	 	 	 	 	point='$weight1'
 	 	 	 	 	 	 	\
 	 	 	 	 	 	 	full_marks[msp_num]+=point
 	 	 	 	 	 	 	}
 	 	 	 	 	 	else
 	 	 	 	 	 	 	{
 	 	 	 	 	 	 	point='$weight2'
 	 	 	 	 	 	 	\
 	 	 	 	 	 	 	full_marks[msp_num]+=point
 	 	 	 	 	 	 	}
 	 	 	 	 	 	for(j=1; j<=belong_id[msp_num]; j++)
 	 	 	 	 	 	 	{
 	 	 	 	 	 	 	for(k=1; k<=count[subdirectory[msp_num,j]]; k++)
 	 	 	 	 	 	 	 	{
 	 	 	 	 	 	 	 	l1=data2_mz[subdirectory[msp_num,j],k]-'$ms2_tolerance'
 	 	 	 	 	 	 	 	\
 	 	 	 	 	 	 	 	m1=data2_mz[subdirectory[msp_num,j],k]+'$ms2_tolerance'
 	 	 	 	 	 	 	 	\
 	 	 	 	 	 	 	 	if(mz+0>=l1+0 && mz+0<=m1+0)
 	 	 	 	 	 	 	 	 	{
 	 	 	 	 	 	 	 	 	l2=data2_in[subdirectory[msp_num,j],k]-'$in_tolerance'
 	 	 	 	 	 	 	 	 	\
 	 	 	 	 	 	 	 	 	m2=data2_in[subdirectory[msp_num,j],k]+'$in_tolerance'
 	 	 	 	 	 	 	 	 	\
 	 	 	 	 	 	 	 	 	if(intensity+0>=l2+0 && intensity+0<=m2+0)
 	 	 	 	 	 	 	 	 	 	{
 	 	 	 	 	 	 	 	 	 	assign_point[subdirectory[msp_num,j],msp_num]+=point;
 	 	 	 	 	 	 	 	 	 	\
 	 	 	 	 	 	 	 	 	 	break;
 	 	 	 	 	 	 	 	 	 	}
 	 	 	 	 	 	 	 	 	}
 	 	 	 	 	 	 	 	}
 	 	 	 	 	 	 	}
 	 	 	 	 	 	}
 	 	 	 	 	}
 	 	 	 	msp_num+=1
 	 	 	 	\
 	 	 	 	name=$2
 	 	 	 	}
 	 	 	if($1~/PRECURSORMZ/)
 	 	 	 	{
 	 	 	 	for(i in pre_mz)
 	 	 	 	 	{
 	 	 	 	 	if($2+0>=pre_mz[i]-'$tolerance' && $2+0<=pre_mz[i]+'$tolerance')
 	 	 	 	 	 	{
 	 	 	 	 	 	printf "info: the MS1 are " $2 " vs " pre_mz[i] "\n"
 	 	 	 	 	 	data3_mz[msp_num]=$2
 	 	 	 	 	 	belong_id[msp_num]+=1
 	 	 	 	 	 	subdirectory[msp_num,belong_id[msp_num]]=i
 	 	 	 	 	 	assign[i,msp_num]=name
 	 	 	 	 	 	sep[i,msp_num]=msp_num
 	 	 	 	 	 	}
 	 	 	 	 	}
 	 	 	 	}
 	 	 	if(belong_id[msp_num]+0>=1)
 	 	 	 	{
 	 	 	 	if($1~/PRECURSORTYPE/)
 	 	 	 	 	{
 	 	 	 	 	data3_type[msp_num]=$2; getline;
 	 	 	 	 	\
 	 	 	 	 	data3_formula[msp_num]=$2; getline;
 	 	 	 	 	\
 	 	 	 	 	data3_ontology[msp_num]=$2; getline;
 	 	 	 	 	\
 	 	 	 	 	data3_inchikey[msp_num]=$2; getline;
 	 	 	 	 	\
 	 	 	 	 	data3_smiles[msp_num]=$2; getline;
 	 	 	 	 	\
 	 	 	 	 	data3_rt[msp_num]=$2; getline;
 	 	 	 	 	\
 	 	 	 	 	data3_ccs[msp_num]=$2;
 	 	 	 	 	}
 	 	 	 	if($1~/Num Peaks/)
 	 	 	 	 	{
 	 	 	 	 	data3_peaks[msp_num]=$2
 	 	 	 	 	}
 	 	 	 	if($1~/^[0-9]/)
 	 	 	 	 	{
 	 	 	 	 	database_count[msp_num]+=1
 	 	 	 	 	\
 	 	 	 	 	data3_mz[msp_num,database_count[msp_num]]=$1
 	 	 	 	 	\
 	 	 	 	 	data3_in[msp_num,database_count[msp_num]]=$2
 	 	 	 	 	\
 	 	 	 	 	if(max_in[msp_num]<$2)
 	 	 	 	 	 	{
 	 	 	 	 	 	max_in[msp_num]=$2
 	 	 	 	 	 	}
 	 	 	 	 	}
 	 	 	 	}
 	 	 	}
 	 	}
 	if(msp_num!="" && (FILENAME~"'$data1'"))
 	 	{
 	 	if(FNR==1)
 	 	 	{
 	 	 	FS="\t"
 	 	 	\
 	 	 	close(p_file)
 	 	 	\
 	 	 	printf $0"\t" "custom_idenfication\n" > "../identi_2_'$data_origin'.tsv"
 	 	 	}
 	 	if(FNR>=2)
 	 	 	{
 	 	 	printf $0 >> "../identi_2_'$data_origin'.tsv"
 	 	 	\
 	 	 	for(i in assign_point)
 	 	 	 	{
 	 	 	 	if(i~"^"$1"\034" && assign_point[i]+0>='$point_limit')
 	 	 	 	 	{
 	 	 	 	 	score[i]=assign_point[i]
 	 	 	 	 	}
 	 	 	 	}
 	 	 	for(n=asort(score,sort_score); n>=1; n--)
 	 	 	 	{
 	 	 	 	for(i in score)
 	 	 	 	 	{
 	 	 	 	 	if(score[i]==sort_score[n])
 	 	 	 	 	 	{
 	 	 	 	 	 	printf "\t" score[i] "("  full_marks[sep[i]]  ")"  " | " \
 	 	 	 	 	 	\
 	 	 	 	 	 	data3_type[sep[i]] " | "  \
 	 	 	 	 	 	\
 	 	 	 	 	 	data3_formula[sep[i]] " | " \
 	 	 	 	 	 	\
 	 	 	 	 	 	data3_ontology[sep[i]] " | " \
 	 	 	 	 	 	\
 	 	 	 	 	 	assign[i] " | " \
 	 	 	 	 	 	\
 	 	 	 	 	 	>> "../identi_2_'$data_origin'.tsv"
 	 	 	 	 	 	\
 	 	 	 	 	 	delete score[i]; break;
 	 	 	 	 	 	}
 	 	 	 	 	}
 	 	 	 	}
 	 	 	delete score
 	 	 	\
 	 	 	printf "\n" >> "../identi_2_'$data_origin'.tsv"
 	 	 	}
 	 	}
 	}' $data1 $data2 $data3 $data1
 ##################
 ##find name from pubchem
 data1="../identi_2_origin.tsv"
 awk -F $'\t' '
  	{
  	if(NR==1)
  	 	{
  	 	FS="[\t]||[;][ ]"
  	 	for(i=1; i<=NF; i++)
  	 	 	{
  	 	 	if($i~/^id/)
  	 	 	 	{
  	 	 	 	col_id=i
  	 	 	 	}
  	 	 	if($i~/links/)
  	 	 	 	{
  	 	 	 	col_links=i
  	 	 	 	}
  	 	 	}
  	 	printf "" > "id_links.tsv"
  	 	}
  	if(NR>=2)
  	 	{
  	 	printf $col_id"\t" $col_links"\n" >> "id_links.tsv"
  	 	}
  	}' $data
 data2="id_links.tsv"
 awk -F "[\t]||[;][ ]" '
 	BEGIN{
 	 	printf "" > "id_links_sep1.tsv"
 	 	}
  	{
  	for(i=1; i<=NF; i++)
  	 	{
  	 	if(i!=NF)
  	 	 	{
  	 	 	printf $i"\t" >> "id_links_sep1.tsv"
  	 	 	}
  	 	else
  	 	 	{
  	 	 	printf $i"\n" >> "id_links_sep1.tsv"
  	 	 	}
  	 	}
  	}' $data2
 data3="id_links_sep1.tsv"
 awk -F $'\t' '
 	BEGIN{
 	 	printf "" > "id_cid.tsv"
 	 	}
 	{
 	if($2~/PubChem/)
 	 	{
 	 	split($2,a,"[(]||[,]||[)]")
 	 	\
 	 	if(a[2]~/^[0-9]/)
 	 	 	{
 	 	 	printf $1 "\t" a[2] "\n" >> "id_cid.tsv"
 	 	 	}
 	 	}
 	}' $data3
 data4="id_cid.tsv"
 arg=$(awk -F $'\t' '{printf $1"_"$2"@"}' $data4 | sed 's/@$//g')
script=$(echo '
import sys
import pubchempy as pcp
data=sys.argv[1]
id_cids=data.split("@")
for i in id_cids:
 data_file=open("synonyms.tsv","a+")
 essemble=i.split("_")
 id=essemble[0]
 cid=essemble[1]
 compound=pcp.Compound.from_cid(cid)
 smiles=compound.isomeric_smiles
 print(str(id)+"\t",end="",file=data_file)
 for name in compound.synonyms:
  print(name,end=" | ",file=data_file)
 print("\t"+smiles,file=data_file)
 print("Info: the data of "+str(id)+"_"+str(cid)+" has been collected.")
 data_file.close()')
python <(echo "$script") $arg
 ################################################
 ################################################
 ## transform principle
 data="../identi_2_origin.tsv"
 tolerance="0.1"
 ratio_limit="1.2"
 awk -F $'\t' '
 	{
 	if(NR==1)
 	 	{
 	 	for(i=1; i<=NF; i++)
 	 	 	{
 	 	 	if($i~/^id/)
 	 	 	 	{
 	 	 	 	col_id=i
 	 	 	 	}
 	 	 	if($i~/norm_delta/)
 	 	 	 	{
 	 	 	 	col_delta=i
 	 	 	 	}
 	 	 	if($i~/class/)
 	 	 	 	{
 	 	 	 	col_class=i
 	 	 	 	}
 	 	 	if($i~/pro\/raw/)
 	 	 	 	{
 	 	 	 	col_ratio=i
 	 	 	 	}
 	 	 	}
 	 	}
 	if(NR>=2)
 	 	{
 	 	id[FNR]=$col_id
 	 	\
 	 	norm_delta[$col_id]=$col_delta
 	 	\
 	 	class[$col_id]=$col_class
 	 	\
 	 	ratio[$col_id]=$col_ratio
 	 	}
 	}
 	END{
 	 	printf "source\t" "target\t" "source_delta\t" "target_delta\t" "trans_probability\t" \
 	 	\
 	 	"ratio\t" "classification\n" > "principle_'$tolerance'_'$ratio_limit'.tsv"
 	 	\
 	 	for(i in id)
 	 	 	{
 	 	 	if(ratio[id[i]]+0>="'$ratio_limit'"+0)
	 	 	 	{
	 	 	 	for(j in norm_delta)
	 	 	 	 	{
	 	 	 	 	if(norm_delta[id[i]]+0>0 && norm_delta[j]+0<0 || norom_delta[id[i]]+0<0 && norm_delta[j]+0>0)
	 	 	 	 	 	{
	 	 	 	 	 	l=(norm_delta[j])*(-1)-"'$tolerance'"
	 	 	 	 	 	\
	 	 	 	 	 	m=(norm_delta[j])*(-1)+"'$tolerance'"
	 	 	 	 	 	\
	 	 	 	 	 	if(norm_delta[id[i]]+0>=l && norm_delta[id[i]]<=m && class[id[i]]==class[j])
	 	 	 	 	 	 	{
	 	 	 	 	 	 	trans=norm_delta[id[i]]+norm_delta[j]
	 	 	 	 	 	 	\
	 	 	 	 	 	 	if(trans+0<0)
	 	 	 	 	 	 	 	{
	 	 	 	 	 	 	 	trans*=(-1)
	 	 	 	 	 	 	 	}
	 	 	 	 	 	 	if(id[i]+0>j)
	 	 	 	 	 	 	 	{
	 	 	 	 	 	 	 	printf id[i]"\t" j"\t" norm_delta[id[i]]"\t" norm_delta[j]"\t" \
	 	 	 	 	 	 	 	\
	 	 	 	 	 	 	 	trans"\t" id[i]":"ratio[id[i]]" | "j":"ratio[j]"\t" \
	 	 	 	 	 	 	 	\
	 	 	 	 	 	 	 	class[id[i]]"\n" >> "principle_'$tolerance'_'$ratio_limit'.tsv"
	 	 	 	 	 	 	 	}
	 	 	 	 	 	 	if(id[i]+0<j)
	 	 	 	 	 	 	 	{
	 	 	 	 	 	 	 	printf j"\t" id[i]"\t" norm_delta[j]"\t" norm_delta[id[i]]"\t" \
	 	 	 	 	 	 	 	\
	 	 	 	 	 	 	 	trans"\t" j":"ratio[j]" | "id[i]":"ratio[id[i]]"\t" \
	 	 	 	 	 	 	 	\
	 	 	 	 	 	 	 	class[id[i]]"\n" >> "principle_'$tolerance'_'$ratio_limit'.tsv"
	 	 	 	 	 	 	 	}
	 	 	 	 	 	 	}
	 	 	 	 	 	}
	 	 	 	 	}
	 	 	 	}
 	 	 	delete norm_delta[id[i]]
 	 	 	}
 	 	}' $data
 #######################################
 #######################################
 #######################################
 ## classification arrangement
 data1="canopus_summary.tsv"
 data2="canopus.tsv"
 data3="results/canopus_pp.tsv"
 definition_limit="0.9"
 awk -F $'\t' '
 	{
 	if(NR==FNR)
 	 	{
 	 	if(FNR==1)
 	 	 	{
 	 	 	p_file=FILENAME
 	 	 	\
 	 	 	for(i=1; i<=NF; i++)
 	 	 	 	{
	 	 	 	if($i~/name/)
	 	 	 	 	{
	 	 	 	 	col_id=i
	 	 	 	 	}
	 	 	 	if($i~/specific/)
	 	 	 	 	{
	 	 	 	 	col_specific=i
	 	 	 	 	}
	 	 	 	if($i~/level/)
	 	 	 	 	{
	 	 	 	 	col_level=i
	 	 	 	 	}
	 	 	 	if($i~/subclass/)
	 	 	 	 	{
	 	 	 	 	col_subclass=i
	 	 	 	 	}
	 	 	 	if($i~/^class/)
	 	 	 	 	{
	 	 	 	 	col_class=i
	 	 	 	 	}
	 	 	 	if($i~/superclass/)
	 	 	 	 	{
	 	 	 	 	col_superclass=i
	 	 	 	 	}
 	 	 	 	}
 	 	 	}
 	 	if(FNR>=2)
 	 	 	{
 	 	 	n=split($col_id,a,"[_]")
 	 	 	\
 	 	 	id=a[n]
 	 	 	\
 	 	 	specific[id]=$col_specific
 	 	 	\
 	 	 	level[id]=$col_level
 	 	 	\
 	 	 	subclass[id]=$col_subclass
 	 	 	\
 	 	 	class[id]=$col_class
 	 	 	\
 	 	 	superclass[id]=$col_superclass
 	 	 	}
 	 	}
 	if(FILENAME~/canopus.tsv/)
 	 	{
 	 	if(FNR==1)
 	 	 	{
 	 	 	close(p_file)
 	 	 	\
 	 	 	p_file=FILENAME
 	 	 	\
 	 	 	for(i=1; i<=NF; i++)
 	 	 	 	{
	 	 	 	if($i~/name/)
	 	 	 	 	{
	 	 	 	 	col_name=i
	 	 	 	 	}
	 	 	 	if($i~/description/)
	 	 	 	 	{
	 	 	 	 	col_description=i
	 	 	 	 	}
 	 	 	 	}
 	 	 	}
 	 	if(FNR>=2)
 	 	 	{
 	 	 	description[$col_name]=$col_description
 	 	 	}
 	 	}
 	if(FILENAME~"'$data3'")
 	 	{
 	 	if(FNR==1)
 	 	 	{
 	 	 	close(p_file)
 	 	 	\
 	 	 	for(i=1; i<=NF; i++)
 	 	 	 	{
 	 	 	 	if($i~/^id$/)
 	 	 	 	 	{
 	 	 	 	 	col_id=i
 	 	 	 	 	}
 	 	 	 	if(i>=2)
 	 	 	 	 	{
 	 	 	 	 	col_class_name[i]=$i
 	 	 	 	 	}
 	 	 	 	}
 	 	 	printf "id\t"  "definition_source\t"  "definition\t"  "definition_pp\t"  "definition_description\t" \
 	 	 	\
 	 	 	"specific\t"  "specific_pp\t"  "level_5\t"  "level_5_pp\t" \
 	 	 	\
 	 	 	"subclass\t"  "subclass_pp\t"  "class\t"  "class_pp\t"  "superclass\t"  "superclass_pp\n" > "stat_classification.tsv"
 	 	 	}
 	 	if(FNR>=2)
 	 	 	{
 	 	 	for(i=2; i<=NF; i++)
 	 	 	 	{
 	 	 	 	c_pp[col_class_name[i]]=sprintf("%.4f",$i)
 	 	 	 	}
 	 	 	if(level[$col_id] != "" && c_pp[level[$col_id]]+0 >= "'$definition_limit'"+0)
 	 	 	 	{
 	 	 	 	definition_source="level_5"
 	 	 	 	\
 	 	 	 	definition=level[$col_id]
 	 	 	 	}
 	 	 	else if(subclass[$col_id] != "" && c_pp[subclass[$col_id]]+0 >= "'$definition_limit'"+0)
 	 	 	 	{
 	 	 	 	definition_source="subclass"
 	 	 	 	\
 	 	 	 	definition=subclass[$col_id]
 	 	 	 	}
 	 	 	else if(class[$col_id] != "" && c_pp[class[$col_id]]+0 >= "'$definition_limit'"+0)
 	 	 	 	{
 	 	 	 	definition_source="class"
 	 	 	 	\
 	 	 	 	definition=class[$col_id]
 	 	 	 	}
 	 	 	else if(superclass[$col_id] != "" && c_pp[superclass[$col_id]]+0 >= "'$definition_limit'"+0)
 	 	 	 	{
 	 	 	 	definition_source="superclass"
 	 	 	 	\
 	 	 	 	definition=superclass[$col_id]
 	 	 	 	}
 	 	 	else
 	 	 	 	{
 	 	 	 	definition_source="null"
 	 	 	 	\
 	 	 	 	definition="null"
 	 	 	 	\
 	 	 	 	c_pp[definition]="null"
 	 	 	 	\
 	 	 	 	description[definition]="null"
 	 	 	 	}
 	 	 	printf $col_id"\t"  definition_source"\t"  definition"\t"  c_pp[definition]"\t"  description[definition]"\t" \
 	 	 	\
 	 	 	specific[$col_id]"\t"  c_pp[specific[$col_id]]"\t"  level[$col_id]"\t"  c_pp[level[$col_id]]"\t" \
 	 	 	\
 	 	 	subclass[$col_id]"\t"  c_pp[subclass[$col_id]]"\t"  class[$col_id]"\t"  c_pp[class[$col_id]]"\t" \
 	 	 	\
 	 	 	superclass[$col_id]"\t"  c_pp[superclass[$col_id]]"\n" >> "stat_classification.tsv"
 	 	 	}
 	 	}
 	}' $data1 $data2 $data3
 ##################
 ## translate
 data=$(awk -F $'\t' '
 	{
 	if(NR==1)
 	 	{
 	 	for(i=1; i<=NF; i++)
 	 	 	{
 	 	 	if($i~/^definition$/)
 	 	 	 	{
 	 	 	 	col_definition=i
 	 	 	 	}
 	 	 	}
 	 	}
 	if(NR>=2 && $col_definition!="null")
 	 	{
 	 	print $col_definition
 	 	}
 	}' stat_classification.tsv | sort | uniq)
 trans :zh -b <<< echo "$data"
 ################################################################################
 ################################################################################
 ################################################################################
 ## new algorithm (transform principle)
 ######## here the low pp will be filtered
 data="results/stat_classification.tsv"
 stat=$(awk -F $'\t' '
 	{
 	if(NR==1)
 	 	{
 	 	for(i=1; i<=NF; i++)
 	 	 	{
 	 	 	if($i~/^id$/)
 	 	 	 	{
 	 	 	 	col_id=i
 	 	 	 	}
 	 	 	if($i~/^definition$/)
 	 	 	 	{
 	 	 	 	col_definition=i
 	 	 	 	}
 	 	 	}
 	 	}
 	if(NR>=2)
 	 	{
 	 	if($col_definition!="null")
 	 	 	{
 	 	 	id_class[$col_id]=$col_definition
 	 	 	class_num[$col_definition]+=1
 	 	 	}
 	 	}
 	}
 	END{
 	 	for(i in class_num)
 	 	 	{
 	 	 	printf i"\t"  class_num[i]"\t"
 	 	 	\
 	 	 	for(j in id_class)
 	 	 	 	{
 	 	 	 	if(id_class[j]==i)
 	 	 	 	 	{
 	 	 	 	 	printf j"@"
 	 	 	 	 	}
 	 	 	 	}
 	 	 	printf "\n"
 	 	 	}
 	 	}' $data | sed 's/@$//g')
 data2="results/re_neg_RT.tsv"
 data3="results/neg_RT.tsv"
 compar1="Raw"
 compar2="Pro"
 log=10
 log_to=2
 awk -F ["\t"@] -v OFS=$'\t' '
 	BEGIN{
 	 	maxNF=0
 	 	\
 	 	rows=0
 	 	\
 	 	compar1n=0
 	 	\
 	 	compar2n=0
 	 	}
 	{
 	if(NR==FNR)
 	 	{
 	 	rows+=1
 	 	if(maxNF<NF)
 	 	 	{
 	 	 	maxNF=NF
 	 	 	}
 	 	class[FNR]=$1
 	 	\
 	 	num[FNR]=$2
 	 	\
 	 	for(j=3; j<=NF; j++)
 	 	 	{
 	 	 	id[FNR,j]=$j
 	 	 	}
 	 	}
 	else
 	 	{
 	 	if(FNR==1 && FILENAME~/re_/)
 	 	 	{
 	 	 	for(i=1; i<=NF; i++)
 	 	 	 	{
 	 	 	 	if(($i~/'$compar1'/) && $i~/area/)
 	 	 	 	 	{
 	 	 	 	 	colum1[i]=i
 	 	 	 	 	compar1n+=1
 	 	 	 	 	}
 	 	 	 	if(($i~/'$compar2'/) && $i~/area/)
 	 	 	 	 	{
 	 	 	 	 	colum2[i]=i
 	 	 	 	 	compar2n+=1
 	 	 	 	 	}
 	 	 	 	if(($i~/retention/))
 	 	 	 	 	{
 	 	 	 	 	rtcolum=i
 	 	 	 	 	}
 	 	 	 	if(($i~/m\/z/))
 	 	 	 	 	{
 	 	 	 	 	mzcolum=i
 	 	 	 	 	}
 	 	 	 	}
 	 	 	}
 	 	if(FNR>=2)
 	 	 	{
 	 	 	if(sum[1,$1]=="" && sum[2,$1]=="") ######## revise data 
 	 	 	 	{
	 	 	 	sum[1,$1]=0
	 	 	 	\
	 	 	 	sum[2,$1]=0
	 	 	 	\
	 	 	 	rt[$1]=$rtcolum
	 	 	 	\
	 	 	 	mz[$1]=$mzcolum
	 	 	 	\
	 	 	 	for(i=1; i<=NF; i++)
	 	 	 	 	{
	 	 	 	 	if(i==colum1[i] && colum1[i]!="")
	 	 	 	 	 	{
	 	 	 	 	 	sum[1,$1]+=$i
	 	 	 	 	 	}
	 	 	 	 	if(i==colum2[i] && colum2[i]!="")
	 	 	 	 	 	{
	 	 	 	 	 	sum[2,$1]+=$i
	 	 	 	 	 	}
	 	 	 	 	}
	 	 	 	}
 	 	 	}
 	 	}
 	}
 	END{
 	 	printf "class\t"  "id\t"  "log'$log'_raw\t"  "log'$log'_pro\t" \
 	 	\
 	 	"log'$log'_delta_area\t"  "pro_to_raw\t"  "log'$log_to'_pro_to_raw\t"  "variety\t"  "number\t" > "algorithm.tsv"
 	 	\
 	 	printf "rt\t"  "m/z\n" >> "algorithm.tsv"
 	 	\
 	 	for(i=1; i<=rows; i++)
 	 	 	{
 	 	 	for(j=3; j<=maxNF; j++)
 	 	 	 	{
 	 	 	 	if(id[i,j]!="")
 	 	 	 	 	{
 	 	 	 	 	raw=(sum[1,id[i,j]]/compar1n)
 	 	 	 	 	\
 	 	 	 	 	pro=(sum[2,id[i,j]]/compar2n)
 	 	 	 	 	\
 	 	 	 	 	log_raw=log(raw)/log('$log')
 	 	 	 	 	\
 	 	 	 	 	log_pro=log(pro)/log('$log')
 	 	 	 	 	\
 	 	 	 	 	delta_area=pro-raw
 	 	 	 	 	\
 	 	 	 	 	if(raw!=0)
 	 	 	 	 	 	{
 	 	 	 	 	 	to_raw=pro/raw
 	 	 	 	 	 	\
 	 	 	 	 	 	norm_to_raw=log(to_raw)/log('$log_to')
 	 	 	 	 	 	}
 	 	 	 	 	else
 	 	 	 	 	 	{
 	 	 	 	 	 	to_raw="infinity"
 	 	 	 	 	 	\
 	 	 	 	 	 	norm_to_raw="infinity"
 	 	 	 	 	 	}
 	 	 	 	 	if(delta_area+0>0)
 	 	 	 	 	 	{
 	 	 	 	 	 	norm_delta=log(delta_area)/log('$log')
 	 	 	 	 	 	\
 	 	 	 	 	 	variety="increase"
 	 	 	 	 	 	}
 	 	 	 	 	else if(delta_area<0)
 	 	 	 	 	 	{
 	 	 	 	 	 	norm_delta=-1*(log(-1*delta_area)/log('$log'))
 	 	 	 	 	 	\
 	 	 	 	 	 	variety="decrease"
 	 	 	 	 	 	}
 	 	 	 	 	else
 	 	 	 	 	 	{
 	 	 	 	 	 	norm_delta=0
 	 	 	 	 	 	}
 	 	 	 	 	printf class[i]"\t"  id[i,j]"\t"  log_raw"\t"  log_pro"\t" \
 	 	 	 	 	\
 	 	 	 	 	norm_delta"\t"  to_raw"\t"  norm_to_raw"\t"  variety"\t"  num[i]"\t" \
 	 	 	 	 	\
 	 	 	 	 	rt[id[i,j]]"\t"  mz[id[i,j]]"\n" >> "algorithm.tsv"
 	 	 	 	 	}
 	 	 	 	}
 	 	 	}
 	 	}' <(echo "$stat") $data2 $data3
 #######################
 data="algorithm.tsv"
 awk -F $'\t' -v OFS=$'\t' '
 	{
 	if(NR==1)
 	 	{
 	 	print "id","rt","m/z","classification","variety","pro/raw","log10_raw","log10_pro","norm_delta" > "compound.tsv"
 	 	\
 	 	for(i=1; i<=NF; i++)
 	 	 	{
 	 	 	if($i~/^id/)
 	 	 	 	{
 	 	 	 	col_id=i
 	 	 	 	}
 	 	 	if($i~/^rt/)
 	 	 	 	{
 	 	 	 	col_rt=i
 	 	 	 	}
 	 	 	if($i~/m\/z/)
 	 	 	 	{
 	 	 	 	col_mz=i
 	 	 	 	}
 	 	 	if($i~/class/)
 	 	 	 	{
 	 	 	 	col_class=i
 	 	 	 	}
 	 	 	if($i~/variety/)
 	 	 	 	{
 	 	 	 	col_variety=i
 	 	 	 	}
 	 	 	if($i~/^pro_to_raw/)
 	 	 	 	{
 	 	 	 	col_ratio=i
 	 	 	 	}
 	 	 	if($i~/log10_raw/)
 	 	 	 	{
 	 	 	 	col_log10_raw=i
 	 	 	 	}
 	 	 	if($i~/log10_pro/)
 	 	 	 	{
 	 	 	 	col_log10_pro=i
 	 	 	 	}
 	 	 	if($i~/delta_area/)
 	 	 	 	{
 	 	 	 	col_delta=i
 	 	 	 	}
 	 	 	}
 	 	}
 	if(NR>=2)
 	 	{
 	 	print $col_id, $col_rt, sprintf("%.5f",$col_mz), $col_class, $col_variety, $col_ratio, $col_log10_raw, $col_log10_pro, \
 	 	\
 	 	$col_delta \
 	 	\
 	 	>> "compound.tsv"
 	 	}
  	}' $data
 ########################
 data="results/fingerid_first_score.tsv"
 list="compound.tsv"
 awk -F $'\t' '	
 	{
 	if(NR==FNR)
 	 	{
 	 	if(FNR==1)
 	 	 	{
 	 	 	for(i=1; i<=NF; i++)
 	 	 	 	{
 	 	 	 	if($i~/^id/)
 	 	 	 	 	{
 	 	 	 	 	col_id=i
 	 	 	 	 	}
 	 	 	 	if($i~/similarity/)
 	 	 	 	 	{
 	 	 	 	 	col_simi=i
 	 	 	 	 	}
 	 	 	 	if($i~/name/)
 	 	 	 	 	{
 	 	 	 	 	col_name=i
 	 	 	 	 	}
 	 	 	 	if($i~/formula/)
 	 	 	 	 	{
 	 	 	 	 	col_formula=i
 	 	 	 	 	}
 	 	 	 	if($i~/^inchi$/)
 	 	 	 	 	{
 	 	 	 	 	col_inchi=i
 	 	 	 	 	}
 	 	 	 	if($i~/smiles/)
 	 	 	 	 	{
 	 	 	 	 	col_smiles=i
 	 	 	 	 	}
 	 	 	 	if($i~/score/)
 	 	 	 	 	{
 	 	 	 	 	col_score=i
 	 	 	 	 	}
 	 	 	 	if($i~/xlogp/)
 	 	 	 	 	{
 	 	 	 	 	col_xlogp=i
 	 	 	 	 	}
 	 	 	 	if($i~/inchikey2D/)
 	 	 	 	 	{
 	 	 	 	 	col_inchikey2D=i
 	 	 	 	 	}
 	 	 	 	if($i~/links/)
 	 	 	 	 	{
 	 	 	 	 	col_links=i
 	 	 	 	 	}
 	 	 	 	}
 	 	 	}
 	 	if(FNR>=2)
 	 	 	{
 	 	 	simi[$col_id]=$col_simi
 	 	 	\
 	 	 	name[$col_id]=$col_name
 	 	 	\
 	 	 	formula[$col_id]=$col_formula
 	 	 	\
 	 	 	smiles[$col_id]=$col_smiles
 	 	 	\
 	 	 	inchi[$col_id]=$col_inchi
 	 	 	\
 	 	 	inchikey2D[$col_id]=$col_inchikey2D
 	 	 	\
 	 	 	score[$col_id]=$col_score
 	 	 	\
 	 	 	xlogp[$col_id]=$col_xlogp
 	 	 	\
 	 	 	links[$col_id]=$col_links
 	 	 	}
 	 	}
 	if(NR!=FNR)
 	 	{
 	 	if(FNR==1)
 	 	 	{
 	 	 	for(i=1; i<=NF; i++)
 	 	 	 	{
 	 	 	 	if($i~/^id/)
 	 	 	 	 	{
 	 	 	 	 	col_list_id=i
 	 	 	 	 	}
 	 	 	 	printf $i"\t" > "com_compound.tsv"
 	 	 	 	}
 	 	 	printf "similarity\t"  "name\t"  "formula\t"  "xlogp\t"  "smiles\t" \
 	 	 	\
 	 	 	"inchi\t"  "inchikey2D\t"  "links\n" >> "com_compound.tsv"
 	 	 	}
 	 	if(FNR>=2)
 	 	 	{
 	 	 	for(i=1; i<=NF; i++)
 	 	 	 	{
 	 	 	 	printf $i"\t" >> "com_compound.tsv"
 	 	 	 	}
 	 	 	printf simi[$col_list_id]"\t"  name[$col_list_id]"\t"  formula[$col_list_id]"\t"  xlogp[$col_list_id]"\t" \
 	 	 	\
 	 	 	smiles[$col_list_id]"\t" inchi[$col_list_id]"\t"  inchikey2D[$col_list_id]"\t" \
 	 	 	\
 	 	 	links[$col_list_id]"\n" >> "com_compound.tsv"
 	 	 	}
 	 	}
 	}' $data $list
 ##################
 #sort 
 data_o="com_compound.tsv"
 data_r=$(cat <(head -n 1 $data_o) <(sort -t $'\t' -k 6 -n -r <(sed '1d' $data_o)))
 echo "$data_r" > com_compound.tsv
 ##################
 #############################
 #############################
  ## transform principle
 data1="com_compound.tsv"
 data2="results/stat_classification.tsv"
 tolerance="0.01"
 ratio_limit="1.5"
 #similarity_limit="0.5"
 awk -F $'\t' '
 	{
 	if(NR==FNR)
 	 	{
	 	if(NR==1)
	 	 	{
	 	 	for(i=1; i<=NF; i++)
	 	 	 	{
	 	 	 	if($i~/^id/)
	 	 	 	 	{
	 	 	 	 	col_id=i
	 	 	 	 	}
	 	 	 	if($i~/norm_delta/)
	 	 	 	 	{
	 	 	 	 	col_delta=i
	 	 	 	 	}
	 	 	 	if($i~/class/)
	 	 	 	 	{
	 	 	 	 	col_class=i
	 	 	 	 	}
	 	 	 	if($i~/pro\/raw/)
	 	 	 	 	{
	 	 	 	 	col_ratio=i
	 	 	 	 	}
	 	 	 	}
	 	 	}
	 	if(NR>=2)
	 	 	{
	 	 	id[FNR]=$col_id
	 	 	\
	 	 	norm_delta[$col_id]=$col_delta
	 	 	\
	 	 	class[$col_id]=$col_class
	 	 	\
	 	 	ratio[$col_id]=$col_ratio
	 	 	}
	 	}
 	if(NR!=FNR)
 	 	{
 	 	if(FNR==1)
	 	 	{
	 	 	for(i=1; i<=NF; i++)
	 	 	 	{
	 	 	 	if($i~/^id$/)
	 	 	 	 	{
	 	 	 	 	col_id=i
	 	 	 	 	}
	 	 	 	if($i~/definition_source/)
	 	 	 	 	{
	 	 	 	 	col_source=i
	 	 	 	 	}
	 	 	 	if($i~/^definition$/)
	 	 	 	 	{
	 	 	 	 	col_definition=i
	 	 	 	 	}
	 	 	 	if($i~/^level_5$/)
	 	 	 	 	{
	 	 	 	 	col_level=i
	 	 	 	 	}
	 	 	 	if($i~/^subclass$/)
	 	 	 	 	{
	 	 	 	 	col_subclass=i
	 	 	 	 	}
	 	 	 	if($i~/^class$/)
	 	 	 	 	{
	 	 	 	 	col_class=i
	 	 	 	 	}
	 	 	 	if($i~/^superclass$/)
	 	 	 	 	{
	 	 	 	 	col_superclass=i
	 	 	 	 	}
	 	 	 	}
	 	 	}
	 	if(FNR>=2)
	 	 	{
	 	 	if($col_class!="")
	 	 	 	{
	 	 	 	comparison[$col_id]=$col_class
	 	 	 	}
	 	 	else
	 	 	 	{
	 	 	 	comparison[$col_id]=$col_superclass
	 	 	 	}
	 	 	}
 	 	}
 	}
 	END{
 	 	printf "source\t" "target\t" "source_delta\t" "target_delta\t" "trans_probability\t" \
 	 	\
 	 	"ratio\t" "co_classification\n" > "all_principle_'$tolerance'_'$ratio_limit'.tsv"
 	 	\
 	 	for(i in id)
 	 	 	{
 	 	 	if(ratio[id[i]]+0>="'$ratio_limit'"+0)
	 	 	 	{
	 	 	 	for(j in norm_delta)
	 	 	 	 	{
	 	 	 	 	if(norm_delta[id[i]]+0>0 && norm_delta[j]+0<0 || norom_delta[id[i]]+0<0 && norm_delta[j]+0>0)
	 	 	 	 	 	{
	 	 	 	 	 	l=(norm_delta[j])*(-1)-"'$tolerance'"
	 	 	 	 	 	\
	 	 	 	 	 	m=(norm_delta[j])*(-1)+"'$tolerance'"
	 	 	 	 	 	\
	 	 	 	 	 	if(norm_delta[id[i]]+0>=l && norm_delta[id[i]]+0<=m && comparison[id[i]]+0==comparison[j])
	 	 	 	 	 	 	{
	 	 	 	 	 	 	trans=norm_delta[id[i]]+norm_delta[j]
	 	 	 	 	 	 	\
	 	 	 	 	 	 	if(trans+0<0)
	 	 	 	 	 	 	 	{
	 	 	 	 	 	 	 	trans*=(-1)
	 	 	 	 	 	 	 	}
	 	 	 	 	 	 	if(id[i]+0>j)
	 	 	 	 	 	 	 	{
	 	 	 	 	 	 	 	printf id[i]"\t" j"\t" norm_delta[id[i]]"\t" norm_delta[j]"\t" \
	 	 	 	 	 	 	 	\
	 	 	 	 	 	 	 	trans"\t" id[i]":"ratio[id[i]]" | "j":"ratio[j]"\t" \
	 	 	 	 	 	 	 	\
	 	 	 	 	 	 	 	comparison[id[i]]"\n" >> "all_principle_'$tolerance'_'$ratio_limit'.tsv"
	 	 	 	 	 	 	 	}
	 	 	 	 	 	 	if(id[i]+0<j)
	 	 	 	 	 	 	 	{
	 	 	 	 	 	 	 	printf j"\t" id[i]"\t" norm_delta[j]"\t" norm_delta[id[i]]"\t" \
	 	 	 	 	 	 	 	\
	 	 	 	 	 	 	 	trans"\t" j":"ratio[j]" | "id[i]":"ratio[id[i]]"\t" \
	 	 	 	 	 	 	 	\
	 	 	 	 	 	 	 	comparison[id[i]]"\n" >> "all_principle_'$tolerance'_'$ratio_limit'.tsv"
	 	 	 	 	 	 	 	}
	 	 	 	 	 	 	}
	 	 	 	 	 	}
	 	 	 	 	}
	 	 	 	}
 	 	 	delete norm_delta[id[i]]
 	 	 	}
 	 	}' $data1 $data2
 ######################
 ######################
 #data(alignment)
 data1=neg.csv
 data2=pos.csv
 awk -F "," '
  	{
  	if(NR==FNR)
  	 	{
  	 	if(FNR==1)
  	 	 	{
  	 	 	for(i=1; i<=NF; i++)
  	 	 	 	{
  	 	 	 	if($i~/row ID/)
  	 	 	 	 	{
  	 	 	 	 	col_id=i
  	 	 	 	 	}
  	 	 	 	else if($i~/row m\/z/)
  	 	 	 	 	{
  	 	 	 	 	col_mz=i
  	 	 	 	 	}
  	 	 	 	else if($i~/row retention time/)
  	 	 	 	 	{
  	 	 	 	 	col_rt=i
  	 	 	 	 	}
  	 	 	 	else
  	 	 	 	 	{
  	 	 	 	 	col_name[$i]=i
  	 	 	 	 	}
  	 	 	 	}
  	 	 	n=asorti(col_name,sort_name)
  	 	 	}
  	 	if(FNR>=2)
  	 	 	{
  	 	 	for(i=1; i<=n; i++)
  	 	 	 	{
  	 	 	 	}
  	 	 	}
  	 	}
  	}' $data1 $data2
 #######################
 #######################
 #######################
 #search glycosides
 data="com_compound.tsv"
 savename="com_lignans_and_iridoids.tsv"
 awk -F $'\t' '
 	{
 	if(FNR==1)
 	 	{
 	 	for(i=1; i<=NF; i++)
 	 	 	{
 	 	 	if($i~/class/)
 	 	 	 	{
 	 	 	 	col_classification=i
 	 	 	 	}
 	 	 	}
 	 	printf $0"\n" > "'$savename'"
 	 	}
 	if(FNR>=2)
 	 	{
 	 	if(tolower($col_classification)~/iridoid/)
 	 	 	{
 	 	 	printf $0"\n" >> "'$savename'"
 	 	 	}
 	 	if(tolower($col_classification)~/lignan/)
 	 	 	{
 	 	 	printf $0"\n" >> "'$savename'"
 	 	 	}
 	 	}
 	}' $data
 ##database idenfication (mgf vs msp)
 data1="com_lignans_and_iridoids.tsv"
 datasource="../initial_8_neg.mgf"
 data2="../datasource.mgf"
 database="../MSMS-Public-Neg-VS15.msp"
 data3="../database.msp"
 tolerance=0.01
 ms2_tolerance=0.2
 in_tolerance=100
 weight1=80
 weight2=20
 point_limit=80
 sed 's/\r//g' $database > ../database.msp
 sed 's/\r//g' $datasource > ../datasource.mgf
 awk -F $'\t' '
 	{
 	if(NR==FNR)
 	 	{
 	 	if(NR==1)
 	 	 	{
 	 	 	p_file=FILENAME
 	 	 	\
 	 	 	for(i=1; i<=NF; i++)
 	 	 	 	{
 	 	 	 	if($i~/^id/)
 	 	 	 	 	{
 	 	 	 	 	col_id=i
 	 	 	 	 	}
 	 	 	 	if($i~/m\/z/)
 	 	 	 	 	{
 	 	 	 	 	col_mz=i
 	 	 	 	 	}
 	 	 	 	}
 	 	 	}
 	 	if(NR>=2)
 	 	 	{
 	 	 	pre_mz[$col_id]=$col_mz
 	 	 	\
 	 	 	printf "info: datafile1 is ready. The data is " $col_id " to " $col_mz "\n"  #info
 	 	 	}
 	 	}
 	if(FILENAME~/datasource.mgf/)
 	 	{
 	 	if(FNR==1)
 	 	 	{
 	 	 	close(p_file)
 	 	 	\
 	 	 	p_file=FILENAME
 	 	 	\
 	 	 	FS="[=]||[ ]"
 	 	 	\
 	 	 	printf "info: datafile2 is ready." #info
 	 	 	}
 	 	if(FNR>=2)
 	 	 	{
 	 	 	if($0~/FEATURE_ID/)
 	 	 	 	{
 	 	 	 	id=$2
 	 	 	 	}
 	 	 	if($0~/MSLEVEL/)
 	 	 	 	{
 	 	 	 	ms_level=$2
 	 	 	 	}
 	 	 	if(($0~/^[0-9]/) && ms_level=2)
 	 	 	 	{
 	 	 	 	count[id]+=1
 	 	 	 	\
 	 	 	 	data2_mz[id,count[id]]=$1
 	 	 	 	\
 	 	 	 	data2_in[id,count[id]]=$2
 	 	 	 	\
 	 	 	 	if(data2_max_intensity[id]<$2)
 	 	 	 	 	{
 	 	 	 	 	data2_max_intensity[id]=$2
 	 	 	 	 	}
 	 	 	 	printf "Info: "$1"_"$2" >>> "id"\n"
 	 	 	 	}
 	 	 	}
 	 	}
 	if(FILENAME~/.msp/)
 	 	{
 	 	if(FNR==1)
 	 	 	{
 	 	 	for(i in data2_in)
 	 	 	 	{
 	 	 	 	split(i,p,"[\034]")
 	 	 	 	\
 	 	 	 	data2_in[i]*=(100/data2_max_intensity[p[1]])
 	 	 	 	}
 	 	 	msp_num+=1
 	 	 	\
 	 	 	FS="[:][ ]||[\t]"
 	 	 	\
 	 	 	close(p_file)
 	 	 	\
 	 	 	p_file=FILENAME
 	 	 	\
 	 	 	n=split($0,c,"[:][ ]")
 	 	 	\
 	 	 	name=c[n]
 	 	 	\
 	 	 	printf "Info: datafile3 is ready. The first name is " name "\n"  #info
 	 	 	}
 	 	if(FNR>=2)
 	 	 	{
 	 	 	if($1~/NAME/)
 	 	 	 	{
 	 	 	 	if(belong_id[msp_num]+0>=1)
 	 	 	 	 	{
 	 	 	 	 	for(i=1; i<=database_count[msp_num]; i++)
 	 	 	 	 	 	{
 	 	 	 	 	 	mz=data3_mz[msp_num,i]
 	 	 	 	 	 	\
 	 	 	 	 	 	intensity=(data3_in[msp_num,i]/max_in[msp_num])*100
 	 	 	 	 	 	\
 	 	 	 	 	 	if(intensity+0>=5)
 	 	 	 	 	 	 	{
 	 	 	 	 	 	 	point='$weight1'
 	 	 	 	 	 	 	\
 	 	 	 	 	 	 	full_marks[msp_num]+=point
 	 	 	 	 	 	 	}
 	 	 	 	 	 	else
 	 	 	 	 	 	 	{
 	 	 	 	 	 	 	point='$weight2'
 	 	 	 	 	 	 	\
 	 	 	 	 	 	 	full_marks[msp_num]+=point
 	 	 	 	 	 	 	}
 	 	 	 	 	 	for(j=1; j<=belong_id[msp_num]; j++)
 	 	 	 	 	 	 	{
 	 	 	 	 	 	 	for(k=1; k<=count[subdirectory[msp_num,j]]; k++)
 	 	 	 	 	 	 	 	{
 	 	 	 	 	 	 	 	l1=data2_mz[subdirectory[msp_num,j],k]-'$ms2_tolerance'
 	 	 	 	 	 	 	 	\
 	 	 	 	 	 	 	 	m1=data2_mz[subdirectory[msp_num,j],k]+'$ms2_tolerance'
 	 	 	 	 	 	 	 	\
 	 	 	 	 	 	 	 	if(mz+0>=l1 && mz+0<=m1+0)
 	 	 	 	 	 	 	 	 	{
 	 	 	 	 	 	 	 	 	l2=data2_in[subdirectory[msp_num,j],k]-'$in_tolerance'
 	 	 	 	 	 	 	 	 	\
 	 	 	 	 	 	 	 	 	m2=data2_in[subdirectory[msp_num,j],k]+'$in_tolerance'
 	 	 	 	 	 	 	 	 	\
 	 	 	 	 	 	 	 	 	if(intensity+0>=l2+0 && intensity+0<=m2+0)
 	 	 	 	 	 	 	 	 	 	{
 	 	 	 	 	 	 	 	 	 	assign_point[subdirectory[msp_num,j],msp_num]+=point;
 	 	 	 	 	 	 	 	 	 	\
 	 	 	 	 	 	 	 	 	 	break;
 	 	 	 	 	 	 	 	 	 	}
 	 	 	 	 	 	 	 	 	}
 	 	 	 	 	 	 	 	}
 	 	 	 	 	 	 	}
 	 	 	 	 	 	}
 	 	 	 	 	}
 	 	 	 	msp_num+=1
 	 	 	 	\
 	 	 	 	name=$2
 	 	 	 	}
 	 	 	if($1~/PRECURSORMZ/)
 	 	 	 	{
 	 	 	 	for(i in pre_mz)
 	 	 	 	 	{
 	 	 	 	 	if($2+0>=pre_mz[i]-'$tolerance' && $2<=pre_mz[i]+'$tolerance')
 	 	 	 	 	 	{
 	 	 	 	 	 	printf "Info: the MS1 are " $2 " vs " pre_mz[i] "\n"
 	 	 	 	 	 	\
 	 	 	 	 	 	data3_mz[msp_num]=$2
 	 	 	 	 	 	\
 	 	 	 	 	 	belong_id[msp_num]+=1
 	 	 	 	 	 	\
 	 	 	 	 	 	subdirectory[msp_num,belong_id[msp_num]]=i
 	 	 	 	 	 	\
 	 	 	 	 	 	assign[i,msp_num]=name
 	 	 	 	 	 	\
 	 	 	 	 	 	sep[i,msp_num]=msp_num
 	 	 	 	 	 	}
 	 	 	 	 	}
 	 	 	 	}
 	 	 	if(belong_id[msp_num]+0>=1)
 	 	 	 	{
 	 	 	 	if($1~/PRECURSORTYPE/)
 	 	 	 	 	{
 	 	 	 	 	data3_type[msp_num]=$2; getline;
 	 	 	 	 	\
 	 	 	 	 	data3_formula[msp_num]=$2; getline;
 	 	 	 	 	\
 	 	 	 	 	data3_ontology[msp_num]=$2; getline;
 	 	 	 	 	\
 	 	 	 	 	data3_inchikey[msp_num]=$2; getline;
 	 	 	 	 	\
 	 	 	 	 	data3_smiles[msp_num]=$2; getline;
 	 	 	 	 	\
 	 	 	 	 	data3_rt[msp_num]=$2; getline;
 	 	 	 	 	\
 	 	 	 	 	data3_ccs[msp_num]=$2;
 	 	 	 	 	}
 	 	 	 	if($1~/Num Peaks/)
 	 	 	 	 	{
 	 	 	 	 	data3_peaks[msp_num]=$2
 	 	 	 	 	}
 	 	 	 	if($1~/^[0-9]/)
 	 	 	 	 	{
 	 	 	 	 	database_count[msp_num]+=1
 	 	 	 	 	\
 	 	 	 	 	data3_mz[msp_num,database_count[msp_num]]=$1
 	 	 	 	 	\
 	 	 	 	 	data3_in[msp_num,database_count[msp_num]]=$2
 	 	 	 	 	\
 	 	 	 	 	if(max_in[msp_num]<$2)
 	 	 	 	 	 	{
 	 	 	 	 	 	max_in[msp_num]=$2
 	 	 	 	 	 	}
 	 	 	 	 	}
 	 	 	 	}
 	 	 	}
 	 	}
 	if(msp_num!="" && (FILENAME~"'$data1'"))
 	 	{
 	 	if(FNR==1)
 	 	 	{
 	 	 	FS="\t"
 	 	 	\
 	 	 	close(p_file)
 	 	 	\
 	 	 	printf $0"\t" "custom_idenfication\n" > "../idenfication_'$data1'.tsv"
 	 	 	}
 	 	if(FNR>=2)
 	 	 	{
 	 	 	printf $0 >> "../idenfication_'$data1'.tsv"
 	 	 	\
 	 	 	for(i in assign_point)
 	 	 	 	{
 	 	 	 	if(i~"^"$1"\034" && assign_point[i]+0>='$point_limit')
 	 	 	 	 	{
 	 	 	 	 	score[i]=assign_point[i]
 	 	 	 	 	}
 	 	 	 	}
 	 	 	for(n=asort(score,sort_score); n>=1; n--)
 	 	 	 	{
 	 	 	 	for(i in score)
 	 	 	 	 	{
 	 	 	 	 	if(score[i]==sort_score[n])
 	 	 	 	 	 	{
 	 	 	 	 	 	printf "\t" score[i] "("  full_marks[sep[i]]  ")"  " | " \
 	 	 	 	 	 	\
 	 	 	 	 	 	data3_type[sep[i]] " | "  \
 	 	 	 	 	 	\
 	 	 	 	 	 	data3_formula[sep[i]] " | " \
 	 	 	 	 	 	\
 	 	 	 	 	 	data3_ontology[sep[i]] " | " \
 	 	 	 	 	 	\
 	 	 	 	 	 	assign[i] " | " \
 	 	 	 	 	 	\
 	 	 	 	 	 	>> "../idenfication_'$data1'.tsv"
 	 	 	 	 	 	\
 	 	 	 	 	 	delete score[i]; break;
 	 	 	 	 	 	}
 	 	 	 	 	}
 	 	 	 	}
 	 	 	delete score
 	 	 	\
 	 	 	printf "\n" >> "../idenfication_'$data1'.tsv"
 	 	 	}
 	 	}
 	}' $data1 $data2 $data3 $data1
 #############################
 #test xlogp parameter
 data="com_lignans_and_iridoids.tsv"
 awk -F $'\t' '
 	{
 	if(NR==1)
 	 	{
	 	for(i=1; i<=NF; i++)
	 	 	{
	 	 	if($i~/similarity/)
	 	 	 	{
	 	 	 	col_similarity=i
	 	 	 	}
	 	 	}
	 	printf $0"\n" > "0.4_'$data'"
	 	}
	if(NR>=2)
	 	{
	 	if($col_similarity+0>=0.4)
	 	 	{
	 	 	printf $0"\n" >> "0.4_'$data'"
	 	 	}
	 	}
 	}' $data
 data="0.5_com_compound.tsv"
 awk -F $'\t' '
  	{
  	if(NR==1)
  	 	{
  	 	for(i=1; i<=NF; i++)
  	 	 	{
  	 	 	if($i~/similarity/)
	 	 	 	{
	 	 	 	col_similarity=i
	 	 	 	}
	 	 	if($i~/^rt$/)
	 	 	 	{
	 	 	 	col_rt=i
	 	 	 	}
	 	 	if($i~/xlogp/)
	 	 	 	{
	 	 	 	col_xlogp=i
	 	 	 	}
	 	 	if($i~/m\/z/)
	 	 	 	{
	 	 	 	col_mz=i
	 	 	 	}
  	 	 	}
  	 	}
  	if(NR>=2)
  	 	{
  	 	if($col_xlogp!="" && $col_mz+0>=400 && $col_mz+0<=800)
  	 	 	{
  	 	 	n+=1
  	 	 	\
	  	 	sum_x+=$col_rt
	  	 	\
	  	 	figure_x[n]=$col_rt
	  	 	\
	  	 	sum_y+=$col_xlogp
	  	 	\
	  	 	figure_y[n]=$col_xlogp
	  	 	}
  	 	}
  	}
  	END{
  	 	average_x=sum_x/n
  	 	\
  	 	average_y=sum_y/n
  	 	\
  	 	for(i=1; i<=n; i++)
  	 	 	{
  	 	 	b_up+=((figure_x[i]-average_x)*(figure_y[i]+(-1)*average_y))
  	 	 	\
  	 	 	b_down+=((figure_x[i]-average_x)^2)
  	 	 	\
  	 	 	r_up_square_root=b_up
  	 	 	\
  	 	 	r_down_1+=((figure_x[i]-average_x)^2)
  	 	 	\
  	 	 	r_down_2+=((figure_y[i]+(-1)*average_y)^2)
  	 	 	}
  	 	b=b_up/b_down
  	 	\
  	 	a=average_y-b*average_x
  	 	\
  	 	r_square=(r_up_square_root^2)/(r_down_1*r_down_2)
  	 	\
  	 	printf "b="b  "\t"  "a="a  "\t"  "y=" b "x+" a "\t"  "r²="r_square  "\n"  average_x "\t"  average_y "\n"
  	 	}' $data
 ###########################
 ###B_ratio
 ################# need revise
 data1="../mobile_phase_system.tsv"
 data2="0.5_com_compound.tsv"
 awk -F $'\t' '
  	{
  	if(NR==FNR)
  	 	{
  	 	if(FNR==1)
  	 	 	{
	  	 	for(i=1; i<=NF; i++)
	  	 	 	{
	  	 	 	if($i~/^time/)
	  	 	 	 	{
	  	 	 	 	col_time=i
	  	 	 	 	}
	  	 	 	if($i~/^B/)
	  	 	 	 	{
	  	 	 	 	col_B=i
	  	 	 	 	}
	  	 	 	}
	  	 	}
  	 	if(FNR>=2)
  	 	 	{
  	 	 	x_rt[FNR-1]=$col_time
  	 	 	max_rows=FNR-1
  	 	 	x1=$col_time
  	 	 	y1=$col_B
  	 	 	getline; 
  	 	 	x2=$col_time
  	 	 	y2=$col_B
  	 	 	if(x2!="")
  	 	 	 	{
  	 	 	 	b[FNR-1]=(y2-y1)/(x2-x1)
  	 	 	 	a[FNR-1]=y1-b[FNR-1]*x1
  	 	 	 	}
  	 	 	}
  	 	}
  	if(FILENAME~/'$data2'/)
  	 	{
  	 	if(FNR==1)
  	 	 	{
  	 	 	printf "" > "b_'$data2'"
  	 	 	for(i=1; i<=NF; i++)
	  	 	 	{
	 	 	 	if($i~/^rt$/)
	 	 	 	 	{
	 	 	 	 	col_rt=i
	 	 	 	 	}
	 	 	 	printf $i >> "b_'$data2'"
	 	 	 	if(i!=NF)
	 	 	 	 	{
	 	 	 	 	printf "\t" >> "b_'$data2'"
	 	 	 	 	}
	 	 	 	else
	 	 	 	 	{
	 	 	 	 	printf "\n" >> "b_'$data2'"
	 	 	 	 	}
	 	 	 	if(col_rt==i)
	 	 	 	 	{
	 	 	 	 	printf "B_ratio\t" >> "b_'$data2'"
	 	 	 	 	}
	  	 	 	}
  	 	 	}
  	 	if(FNR>=2)
  	 	 	{
  	 	 	for(i=1; i<=NF; i++)
  	 	 	 	{
  	 	 	 	printf $i >> "b_'$data2'"
	 	 	 	if(i!=NF)
	 	 	 	 	{
	 	 	 	 	printf "\t" >> "b_'$data2'"
	 	 	 	 	}
	 	 	 	else
	 	 	 	 	{
	 	 	 	 	printf "\n" >> "b_'$data2'"
	 	 	 	 	}
	 	 	 	if(col_rt==i)
	 	 	 	 	{
	 	 	 	 	for(j=1; j<=max_rows; j++)
	 	 	 	 	 	{
	 	 	 	 	 	if(x_rt[j]+0<=$col_rt+0 && x_rt[j+1]+0>=$col_rt+0)
	 	 	 	 	 	 	{
	 	 	 	 	 	 	B_ratio=b[j]*$col_rt+a[j]
	 	 	 	 	 	 	printf B_ratio >> "b_'$data2'"
	 	 	 	 	 	 	break;
	 	 	 	 	 	 	}
	 	 	 	 	 	}
	 	 	 	 	printf "\t" >> "b_'$data2'"
	 	 	 	 	}
  	 	 	 	}
  	 	 	}
  	 	}
  	}' $data1 $data2
 ###########################
 ### filter_class
 data="results/stat_classification.tsv"
 awk -F $'\t' '
 	{
 	if(FNR==1)
 	 	{
 	 	for(i=1; i<=NF; i++)
 	 	 	{
 	 	 	if($i~/^definition$/)
 	 	 	 	{
 	 	 	 	col_class=i
 	 	 	 	}
 	 	 	}
 	 	}
 	if(FNR>=2)
 	 	{
 	 	class[$col_class]=$col_class
 	 	}
 	}
 	END{
 	 	for(i in class)
 	 	 	{
 	 	 	printf "" > "filter_0_class.tsv"
 	 	 	printf class[i]"\n" >> "filter_0_class.tsv"
 	 	 	}
 	 	}' $data
 cat filter_0_class.tsv | trans :zh -b > filter_0_trans_class.tsv
 ###########################
 data1="filter_0_class.tsv"
 data2="results/canopus_pp.tsv"
 savepath="results/canopus_pp_filter.tsv"
 awk -F $'\t' '
  	{
  	if(NR==FNR)
  	 	{
	  	if(FNR==1)
	  	 	{
	  	 	}
	  	if(FNR>=2)
	  	 	{
	  	 	}
	  	}
	if(NR>FNR)
	 	{
	 	}
  	}' $data
 ###########################
 data1="filter_class.tsv"
 data2="com_compound.tsv"
 savename="less_com_compound.tsv"
 awk -F $'\t' '
  	{
  	if(NR==FNR)
  	 	{
  	 	filter_class[$2]=$1
  	 	}
  	if(NR>FNR)
  	 	{
  	 	if(FNR==1)
  	 	 	{
  	 	 	for(i=1; i<=NF; i++)
  	 	 	 	{
  	 	 	 	if($i~/classification/)
  	 	 	 	 	{
  	 	 	 	 	col_class=i
  	 	 	 	 	}
  	 	 	 	if($i~/pro\/raw/)
  	 	 	 	 	{
  	 	 	 	 	col_ratio=i
  	 	 	 	 	}
  	 	 	 	}
  	 	 	printf $0"\n" > "'$savename'"
  	 	 	print col_class,col_ratio
  	 	 	}
  	 	if(FNR>=2)
  	 	 	{
  	 	 	for(i in filter_class)
  	 	 	 	{
  	 	 	 	if($col_class==filter_class[i] && $col_ratio+0>=0)
  	 	 	 	 	{
  	 	 	 	 	printf $0"\n" >> "'$savename'"
  	 	 	 	 	\
  	 	 	 	 	break;
  	 	 	 	 	}
  	 	 	 	}
  	 	 	}
  	 	}
  	}' $data1 $data2
 ###################
 #boxplot
 Rscript=$(echo '
library(ggplot2)
source<-read.table(file="boxplot.tsv",header=T,sep="\t")
boxplot<-ggplot(source,aes(x=classification,y=pro.raw,fill=classification))+
  stat_boxplot(geom="errorbar",width=0.3)+
  geom_boxplot()+
  geom_point(position="jitter",shape=21,size=3)+
  theme(
       legend.position="none",
       axis.text.x = element_blank(),
       text = element_text(size=30),
       )+
  geom_text(data=source, aes(x=classification, y=30, label=classification),
	    color="black", fontface="bold", size=8, angle= 90, 
	    inherit.aes = FALSE )+
  stat_summary(fun="mean",geom="point",shape=23,size=2.5,fill="grey")+
  facet_zoom(ylim = c(0, 10))
pdf("boxplot.pdf",width=25,height=15)
boxplot
dev.off()
')
 ##################
 ###########################
 ###for sunplot
 #data1="filter_class.tsv"
 data1="filter_class.csv" #lignans and iridoids
 data2="results/canopus_pp.tsv"
 data3="com_compound.tsv"
 savename="for_sun.tsv"
 #ex_export="com_lignans_and_iridoids.tsv"
 ex_export="com_carboxylic_acids.tsv"
 similarity_limit="0.4"
 class_pp_limit="0.9"
 awk -F $'\t' '
  	{
  	if(NR==FNR)
  	 	{
  	 	filter_class[$1]=$2
  	 	}
  	if(FILENAME~/canopus/)
  	 	{
  	 	if(FNR==1)
  	 	 	{
  	 	 	col_id=1
  	 	 	for(i=2; i<=NF; i++)
  	 	 	 	{
  	 	 	 	for(j in filter_class)
  	 	 	 	 	{
  	 	 	 	 	if(j==$i)
  	 	 	 	 	 	{
  	 	 	 	 	 	col_class[j]=i
  	 	 	 	 	 	print i
  	 	 	 	 	 	}
  	 	 	 	 	}
  	 	 	 	}
  	 	 	}
  	 	if(FNR>=2)
  	 	 	{
  	 	 	for(i in col_class)
  	 	 	 	{
  	 	 	 	if(sprintf("%.3f",$col_class[i])+0>="'$class_pp_limit'"+0)
  	 	 	 	 	{
  	 	 	 	 	class_set[i,$col_id]=i
  	 	 	 	 	print i,$col_class[i]
  	 	 	 	 	}
  	 	 	 	}
  	 	 	}
  	 	}
  	if(FILENAME~/'$data3'/)
  	 	{
  	 	if(FNR==1)
  	 	 	{
  	 	 	for(i=1; i<=NF; i++)
  	 	 	 	{
  	 	 	 	if($i~/^id/)
	 	 	 	 	{
	 	 	 	 	col_id=i
	 	 	 	 	}
	 	 	 	if($i~/log10_raw/)
	 	 	 	 	{
	 	 	 	 	col_log_raw=i
	 	 	 	 	}
	 	 	 	if($i~/log10_pro/)
	 	 	 	 	{
	 	 	 	 	col_log_pro=i
	 	 	 	 	}
	 	 	 	if($i~/similarity/)
	 	 	 	 	{
	 	 	 	 	col_similarity=i
	 	 	 	 	}
  	 	 	 	}
  	 	 	printf "id\t"  "classification\t"  "log10_raw\t"  "log10_pro\n" > "'$savename'"
  	 	 	\
  	 	 	printf $0"\n" > "'$ex_export'"
  	 	 	}
  	 	if(FNR>=2)
  	 	 	{
  	 	 	if($col_similarity+0 >= "'$similarity_limit'")
  	 	 	 	{
	  	 	 	for(i in class_set)
	  	 	 	 	{
	  	 	 	 	if(i~"\034"$col_id"$")
	  	 	 	 	 	{
	  	 	 	 	 	printf $col_id"\t"  class_set[i]"\t"  $col_log_raw"\t"  $col_log_pro"\n" \
	  	 	 	 	 	\
	  	 	 	 	 	>> "'$savename'"
	  	 	 	 	 	\
	  	 	 	 	 	printf $0"\n" >> "'$ex_export'"
	  	 	 	 	 	}
	  	 	 	 	}
	  	 	 	}
  	 	 	}
  	 	}
  	}' $data1 $data2 $data3
 #########################
 ###sun.tsv
 ###matrix
#	 id	classification	log10_raw	log10_pro
#	147	Lignans, neolignans and related compounds	6.11895	6.51289
#	147	Furofuran lignans	6.11895	6.51289
#	147	O-methylated flavonoids	6.11895	6.51289
#	147	Coumaric acids and derivatives	6.11895	6.51289
#	147	Amino acids and derivatives	6.11895	6.51289
#	147	Terpene glycosides	6.11895	6.51289
 data="for_sun.tsv"
 awk -F $'\t' '
  	{
  	if(NR==1)
  	 	{
  	 	for(i=1; i<=NF; i++)
 	 	 	{
 	 	 	if($i~/^id/)
 	 	 	 	{
 	 	 	 	col_id=i
 	 	 	 	}
 	 	 	if($i~/class/)
 	 	 	 	{
 	 	 	 	col_class=i
 	 	 	 	}
 	 	 	if($i~/log10_raw/)
 	 	 	 	{
 	 	 	 	col_log_raw=i
 	 	 	 	}
 	 	 	if($i~/log10_pro/)
 	 	 	 	{
 	 	 	 	col_log_pro=i
 	 	 	 	}
 	 	 	}
  	 	}
  	if(NR>=2)
  	 	{
  	 	id[FNR]=$col_id
  	 	class[FNR]=$col_class
  	 	uniq_class[$col_class]=$col_class
  	 	log_raw[FNR]=$col_log_raw
  	 	log_pro[FNR]=$col_log_pro
  	 	}
  	}
  	END{
  	 	printf "name\t"  "group\t"
  	 	for(i=2; i<=NR; i++)
  	 	 	{
  	 	 	if(i<NR)
  	 	 	 	{
  	 	 	 	printf "raw_"id[i]"\t"  "pro_"id[i]"\t"
  	 	 	 	}
  	 	 	if(i==NR)
  	 	 	 	{
  	 	 	 	printf "raw_"id[i]"\t"  "pro_"id[i]"\n"
  	 	 	 	}
  	 	 	}
  	 	for(i in uniq_class)
  	 	 	{
  	 	 	printf uniq_class[i]"\t"  "NA\t"
  	 	 	 	{
  	 	 	 	for(j=2; j<=NR; j++)
  	 	 	 	 	{
  	 	 	 	 	if(j<NR)
  	 	 	 	 	 	{
	  	 	 	 	 	if(class[j]==uniq_class[i])
	  	 	 	 	 	 	{
	  	 	 	 	 	 	if(log_raw[j]!="-inf")
	  	 	 	 	 	 	 	{
	  	 	 	 	 	 	 	printf log_raw[j]*(-1)"\t"  log_pro[j]"\t"
	  	 	 	 	 	 	 	}
	  	 	 	 	 	 	else
	  	 	 	 	 	 	 	{
	  	 	 	 	 	 	 	printf 0"\t"  log_pro[j]"\t"
	  	 	 	 	 	 	 	}
	  	 	 	 	 	 	}
	  	 	 	 	 	else
	  	 	 	 	 	 	{
	  	 	 	 	 	 	printf "0\t"  "0\t"
	  	 	 	 	 	 	}
	  	 	 	 	 	}
	  	 	 	 	else
	  	 	 	 	 	{
	  	 	 	 	 	if(class[j]==uniq_class[i])
	  	 	 	 	 	 	{
	  	 	 	 	 	 	if(log_raw[j]!="-inf")
	  	 	 	 	 	 	 	{
	  	 	 	 	 	 	 	printf log_raw[j]*(-1)"\t"  log_pro[j]"\n"
	  	 	 	 	 	 	 	}
	  	 	 	 	 	 	else
	  	 	 	 	 	 	 	{
	  	 	 	 	 	 	 	printf 0"\t"  log_pro[j]"\n"
	  	 	 	 	 	 	 	}
	  	 	 	 	 	 	}
	  	 	 	 	 	else
	  	 	 	 	 	 	{
	  	 	 	 	 	 	printf "0\t"  "0\n"
	  	 	 	 	 	 	}
	  	 	 	 	 	}
  	 	 	 	 	}
  	 	 	 	}
  	 	 	}
  	 	}
  	' $data > sun.tsv
 ##########
 sort -t $'\t' -k 7 -n com_lignans_and_iridoids.tsv > test.tsv
 awk -F $'\t' '
  	{
  	if(NR==1)
  	 	{
  	 	printf "rank\t"  "log10_pro\t"  $0"\n"
  	 	rank=255
  	 	for(i=1; i<=NF; i++)
 	 	 	{
 	 	 	if($i~/pro\/raw/)
 	 	 	 	{
 	 	 	 	col_ratio=i
 	 	 	 	}
 	 	 	if($i~/log10_raw/)
 	 	 	 	{
 	 	 	 	col_log_raw=i
 	 	 	 	}
 	 	 	}
  	 	}
  	if(NR>=2)
  	 	{
  	 	printf rank"\t"  $col_log_raw+log($col_log_raw)/log(10)"\t"  $0"\n"
  	 	rank-=1
  	 	}
  	}' test.tsv > rank.tsv
 ######################################
 ##xcms
 data="com_lignans_and_iridoids.tsv"
 savepath="../thermo_mzML_0518/EIC_metadata.tsv"
 awk -F $'\t' '
  	{
  	if(NR==1)
  	 	{
  	 	for(i=i; i<=NF; i++)
  	 	 	{
  	 	 	if($i~/^id$/)
  	 	 	 	{
  	 	 	 	col_id=i
  	 	 	 	}
  	 	 	if($i~/m\/z/)
  	 	 	 	{
  	 	 	 	col_mz=i
  	 	 	 	}
  	 	 	}
  	 	printf "id\t"  "m/z\n" > "'$savepath'"
  	 	}
  	if(NR>=2)
  	 	{
  	 	printf $col_id"\t"  $col_mz"\n" >> "'$savepath'"
  	 	}
  	}' $data
 ######################################
 ######################################
 #peak during time Correction
 data1="results/neg_RT.tsv"
 data2="results/0924_neg_RT.tsv"
 savepath="results/re_neg_RT.tsv"
 mz_tolerance=0.005
 rt_tolerance=0.1
 awk -F $'\t' '
  	{
  	if(NR==FNR)
  	 	{
  	 	if(FNR==1)
  	 	 	{
  	 	 	for(i=1; i<=NF; i++)
  	 	 	 	{
  	 	 	 	if($i~/ID/)
  	 	 	 	 	{
  	 	 	 	 	col_id=i
  	 	 	 	 	}
  	 	 	 	if($i~/retention/)
  	 	 	 	 	{
  	 	 	 	 	col_rt=i
  	 	 	 	 	}
  	 	 	 	if($i~/m\/z/)
  	 	 	 	 	{
  	 	 	 	 	col_mz=i
  	 	 	 	 	}
  	 	 	 	}
  	 	 	}
  	 	if(FNR>=2)
  	 	 	{
  	 	 	data1_mz[$col_id]=$col_mz
  	 	 	data1_rt[$col_id]=$col_rt
  	 	 	set[$col_id]=$col_id
  	 	 	dataset[$col_id]=$0
  	 	 	}
  	 	}
  	if(NR>FNR)
  	 	{
  	 	if(FNR==1)
  	 	 	{
  	 	 	printf $0"\n" > "'$savepath'"
  	 	 	for(i=1; i<=NF; i++)
  	 	 	 	{
  	 	 	 	if($i~/ID/)
  	 	 	 	 	{
  	 	 	 	 	col_id=i
  	 	 	 	 	}
  	 	 	 	if($i~/retention/)
  	 	 	 	 	{
  	 	 	 	 	col_rt=i
  	 	 	 	 	}
  	 	 	 	if($i~/m\/z/)
  	 	 	 	 	{
  	 	 	 	 	col_mz=i
  	 	 	 	 	}
  	 	 	 	}
  	 	 	}
  	 	if(FNR>=2)
  	 	 	{
  	 	 	data2_mz[$col_id]=$col_mz
  	 	 	data2_rt[$col_id]=$col_rt
  	 	 	for(i in data1_mz)
  	 	 	 	{
  	 	 	 	if(data1_mz[i]<=$col_mz+"'$mz_tolerance'" && data1_mz[i]>=$col_mz-"'$mz_tolerance'")
  	 	 	 	 	{
  	 	 	 	 	if(data1_rt[i]<=$col_rt+"'$rt_tolerance'" && data1_rt[i]>=$col_rt-"'$rt_tolerance'")
  	 	 	 	 	 	{
  	 	 	 	 	 	data1_num[i]+=1
  	 	 	 	 	 	delete set[i];
  	 	 	 	 	 	print "data1",i,">>>","data2",$col_id,">>>",data1_num[i]
  	 	 	 	 	 	printf i"\t" data1_mz[i]"\t" data1_rt[i] >> "'$savepath'"
  	 	 	 	 	 	for(j=4; j<=NF; j++)
  	 	 	 	 	 	 	{
  	 	 	 	 	 	 	printf "\t"$j >> "'$savepath'"
  	 	 	 	 	 	 	}
  	 	 	 	 	 	printf "\n" >> "'$savepath'"
  	 	 	 	 	 	}
  	 	 	 	 	}
  	 	 	 	}
  	 	 	}
  	 	}
  	}
  	END{
  	 	for(i in set)
  	 	 	{
  	 	 	printf dataset[i]"\n" >> "'$savepath'"
  	 	 	printf set[i]"\n"
  	 	 	}
  	 	}' $data1 $data2
 ######################################
 datapath="/media/wizard/back/thermo_mzML_0518/EIC"
 mkdir $datapath/EIC_merge
 echo "" > $datapath/file.tsv
 data1="$datapath/../metadata.tsv"
 data2="$datapath/EIC*.mzML/*.tsv"
 awk -F $'\t' '
 	{
 	if(NR==FNR)
 	 	{
 	 	if(NR>=2)
 	 	 	{
 	 	 	total_id[FNR]=$1
 	 	 	}
 	 	}
 	if(FILENAME~/intensity/)
 	 	{
	 	if(FNR==1)
	 	 	{
	 	 	n=split(FILENAME,f,"[/]")
	 	 	split(f[n-1], g,"[_]")
	 	 	samplename=g[2]
	 	 	split(f[n], a, "[_]")
	 	 	id=a[1]
	 	 	if(samplename!=p_samplename)
	 	 	 	{
	 	 	 	num_sample+=1
	 	 	 	sample[num_sample]=samplename
	 	 	 	}
	 	 	p_samplename=samplename
	 	 	}
	 	if(FNR>=1)
	 	 	{
	 	 	data_scan[samplename,id,FNR]=$1
	 	 	if($2!="NA")
	 	 	 	{
	 	 	 	data_intensity[samplename,id,FNR]=$2
	 	 	 	}
	 	 	else
	 	 	 	{
	 	 	 	data_intensity[samplename,id,FNR]="0"
	 	 	 	}
	 	 	}
	 	}
	if(FILENAME~/rt.tsv/)
	 	{
	 	if(FNR==1)
	 	 	{
	 	 	n=split(FILENAME,f,"[/]")
	 	 	split(f[n-1], g,"[_]")
	 	 	samplename=g[2]
	 	 	printf samplename"\n"
	 	 	}
	 	if(FNR>=1)
	 	 	{
	 	 	data_scan[samplename,FNR]=$1
	 	 	data_rt[samplename,FNR]=$2
	 	 	max_rows[samplename]=FNR
	 	 	}
	 	}
 	}
 	END{
 	 	for(i in total_id)
 	 	 	{
 	 	 	printf "rt\t"  "intensity\t"  "sample\n" > "'$datapath'/EIC_merge/" total_id[i] ".tsv"
 	 	 	for(j in sample)
 	 	 	 	{
 	 	 	 	for(k=1; k<=max_rows[sample[j]]; k++)
 	 	 	 	 	{
 	 	 	 	 	printf data_rt[sample[j],k]"\t"  data_intensity[sample[j],total_id[i],k]"\t"  sample[j]"\n" \
 	 	 	 	 	\
 	 	 	 	 	>> "'$datapath'/EIC_merge/" total_id[i] ".tsv"
 	 	 	 	 	}
 	 	 	 	}
 	 	 	}
 	 	}' $data1 $data2
 ######################################
 mkdir results/EIC_rt_during
 data1="/media/wizard/back/thermo_mzML_0518/EIC/metadata.tsv"
 data2="results/re_neg_RT.tsv"
 data3="/media/wizard/back/thermo_mzML_0518/EIC/EIC_merge/*.tsv"
 savepath="results/EIC_rt_during/"
 excess_time="0.1"
 awk -F $'\t' '
  	{
  	if(NR==FNR)
  	 	{
  	 	group_name[$1]=$2
  	 	}
  	if(FILENAME~/results/)
  	 	{
  	 	if(FNR==1)
  	 	 	{
  	 	 	p_file=FILENAME
  	 	 	for(i=1; i<=NF; i++)
  	 	 	 	{
  	 	 	 	if($i~/ID/)
  	 	 	 	 	{
  	 	 	 	 	col_id=i
  	 	 	 	 	}
  	 	 	 	if($i~/m\/z/)
  	 	 	 	 	{
  	 	 	 	 	col_mz=i
  	 	 	 	 	}
  	 	 	 	if($i~/retention/)
  	 	 	 	 	{
  	 	 	 	 	col_rt=i
  	 	 	 	 	}
  	 	 	 	if($i~/start$/)
  	 	 	 	 	{
  	 	 	 	 	split($i,a,"[ ]")
  	 	 	 	 	samplename=a[1]
  	 	 	 	 	# print samplename
  	 	 	 	 	col_start[samplename]=i
  	 	 	 	 	}
  	 	 	 	if($i~/end$/)
  	 	 	 	 	{
  	 	 	 	 	split($i,a,"[ ]")
  	 	 	 	 	samplename=a[1]
  	 	 	 	 	col_end[samplename]=i
  	 	 	 	 	}
  	 	 	 	}
  	 	 	}
  	 	if(FNR>=2)
  	 	 	{
  	 	 	mz[$col_id]=$col_mz
  	 	 	# print $col_mz
  	 	 	center_rt[$col_id]=$col_rt
  	 	 	for(i in col_start)
  	 	 	 	{
  	 	 	 	if($col_start[i]!="0")
  	 	 	 	 	{
  	 	 	 	 	rt_start[$col_id,i]=$col_start[i]
  	 	 	 	 	# print $col_start[i]
  	 	 	 	 	}
  	 	 	 	else if(reference_sample[$col_id]=="")
  	 	 	 	 	{
  	 	 	 	 	for(j in col_start)
  	 	 	 	 	 	{
  	 	 	 	 	 	if($col_start[j]!="0")
  	 	 	 	 	 	 	{
  	 	 	 	 	 	 	rt_start[$col_id,i]=$col_start[j]
  	 	 	 	 	 	 	reference_sample[$col_id]=j
  	 	 	 	 	 	 	break;
  	 	 	 	 	 	 	}
  	 	 	 	 	 	}
  	 	 	 	 	}
  	 	 	 	else
  	 	 	 	 	{
  	 	 	 	 	rt_start[$col_id,i]=$col_start[reference_sample[$col_id]]
  	 	 	 	 	}
  	 	 	 	}
  	 	 	for(i in col_end)
  	 	 	 	{
  	 	 	 	if($col_end[i]!="0")
  	 	 	 	 	{
  	 	 	 	 	rt_end[$col_id,i]=$col_end[i]
  	 	 	 	 	}
  	 	 	 	else
  	 	 	 	 	{
  	 	 	 	 	rt_end[$col_id,i]=$col_end[reference_sample[$col_id]]
  	 	 	 	 	}
  	 	 	 	}
  	 	 	}
  	 	}
  	if(FILENAME~/EIC_merge/)
  	 	{
  	 	if(FNR==1)
  	 	 	{
  	 	 	close(p_file)
  	 	 	p_file=FILENAME
  	 	 	close("'$savepath'" p_id ".tsv")
  	 	 	num_id+=1
  	 	 	n=split(FILENAME,a,"[/]||[.]")
  	 	 	id=a[n-1]
  	 	 	# print id
  	 	 	p_id=id
  	 	 	if(num_id==1)
  	 	 	 	{
	  	 	 	for(i=1; i<=NF; i++)
	  	 	 	 	{
	  	 	 	 	if($i~/^rt/)
	  	 	 	 	 	{
	  	 	 	 	 	col_rt=i
	  	 	 	 	 	}
	  	 	 	 	if($i~/intensity/)
	  	 	 	 	 	{
	  	 	 	 	 	col_intensity=i
	  	 	 	 	 	}
	  	 	 	 	if($i~/sample/)
	  	 	 	 	 	{
	  	 	 	 	 	col_sample=i
	  	 	 	 	 	}
	  	 	 	 	}
  	 	 	 	}
  	 	 	printf $0"\t" "group\t" "label\t" "color\t" "mz\t" "center_rt\n" > "'$savepath'" id ".tsv"
  	 	 	}
  	 	if(FNR>=2)
  	 	 	{
  	 	 	rt_min=($col_rt)/60
  	 	 	if(threshold[id,$col_sample]=="")
  	 	 	 	{
  	 	 	 	threshold[id,$col_sample]=rt_start[id,$col_sample]+(rt_end[id,$col_sample]-rt_start[id,$col_sample])*(1/2)
  	 	 	 	}
  	 	 	if(rt_min>=rt_start[id,$col_sample]-"'$excess_time'" && rt_min<=rt_end[id,$col_sample]+"'$excess_time'")
  	 	 	 	{
  	 	 	 	if(rt_min+0>=threshold[id,$col_sample] && end_sig[id,$col_sample]!="1")
  	 	 	 	 	{
  	 	 	 	 	label_sig[id,$col_sample]=1
  	 	 	 	 	end_sig[id,$col_sample]=1
  	 	 	 	 	}
  	 	 	 	else
  	 	 	 	 	{
  	 	 	 	 	label_sig[id,$col_sample]=0
  	 	 	 	 	}
  	 	 	 	if(rt_min+0>=rt_start[id,$col_sample]+0 && rt_min+0<=rt_end[id,$col_sample]+0)
  	 	 	 	 	{
  	 	 	 	 	color[id,$col_sample]=group_name[$col_sample]
  	 	 	 	 	}
  	 	 	 	else
  	 	 	 	 	{
  	 	 	 	 	color[id,$col_sample]="Non feature"
  	 	 	 	 	}
  	 	 	 	printf sprintf("%.2f",rt_min)"\t"  $col_intensity"\t"  $col_sample"\t"  group_name[$col_sample]"\t" \
  	 	 	 	\
  	 	 	 	label_sig[id,$col_sample]"\t"  color[id,$col_sample] >> "'$savepath'" id ".tsv"
  	 	 	 	\
  	 	 	 	start_FNR[id]+=1
  	 	 	 	\
  	 	 	 	if(start_FNR[id]=="1")
  	 	 	 	 	{
  	 	 	 	 	printf "\t"sprintf("%.4f",mz[id])  "\t"sprintf("%.2f",center_rt[id]) >> "'$savepath'" id ".tsv"
  	 	 	 	 	}
  	 	 	 	printf "\n" >> "'$savepath'" id ".tsv"
  	 	 	 	}
  	 	 	}
  	 	}
  	}' $data1 $data2 $data3
 ##############################
 ##use python rdkit 
 conda activate my-rdkit-env
 savepath="results/structure_2d"
 cd $savepath
 data="../../com_compound.tsv"
 awk -F $'\t' '
  	{
  	if(FNR==1)
  	 	{
  	 	for(i=1; i<=NF; i++)
  	 	 	{
  	 	 	if($i~/^id/)
  	 	 	 	{
  	 	 	 	col_id=i
  	 	 	 	}
  	 	 	if($i~/smiles/)
  	 	 	 	{
  	 	 	 	col_smiles=i
  	 	 	 	}
  	 	 	}
  	 	}
  	if(FNR>=2)
  	 	{
  	 	printf $col_id "_" $col_smiles "|||"
  	 	}
  	}' $data > list
 python_script="/home/wizard/Downloads/codes/python_files/draw_structure.py"
 python $python_script list
 #### build instance data
 data1="0703_all/lignans_and_iridoids.tsv"
 data2="0703_all/ftalign.tsv"
 savepath="instance_data.tsv"
 awk -F $'\t' '
  	{
  	if(NR==FNR)
  	 	{
  	 	if(FNR==1)
  	 	 	{
  	 	 	for(i=1; i<=NF; i++)
  	 	 	 	{
  	 	 	 	if($i~/^id/)
  	 	 	 	 	{
  	 	 	 	 	col_id=i
  	 	 	 	 	}
  	 	 	 	if($i~/^classification/)
  	 	 	 	 	{
  	 	 	 	 	col_class=i
  	 	 	 	 	}
  	 	 	 	}
  	 	 	}
  	 	if(FNR>=2)
  	 	 	{
  	 	 	if($col_class~/Lignans/)
  	 	 	 	{
  	 	 	 	the_id[$col_id]=$col_id
  	 	 	 	}
  	 	 	}
  	 	}
  	if(NR>FNR)
  	 	{
  	 	if(FNR==1)
  	 	 	{
  	 	 	printf $1 > "'$savepath'"
  	 	 	for(i=2; i<=NF; i++)
  	 	 	 	{
  	 	 	 	n=split($i, a, "[_]")
  	 	 	 	for(j in the_id)
  	 	 	 	 	{
  	 	 	 	 	if(a[n]~"^"j"$")
  	 	 	 	 	 	{
  	 	 	 	 	 	col_the_id[a[n]]=i
  	 	 	 	 	 	printf "\t"a[n] >> "'$savepath'"
  	 	 	 	 	 	break;
  	 	 	 	 	 	}
  	 	 	 	 	}
  	 	 	 	}
  	 	 	printf "\n" >> "'$savepath'"
  	 	 	}
  	 	if(FNR>=2)
  	 	 	{
  	 	 	n=split($1, b, "[_]")
  	 	 	printf "Get row of "  FNR  " >>> " b[n] "\n"
  	 	 	for(k in the_id)
  	 	 	 	{
  	 	 	 	if(b[n]==k)
  	 	 	 	 	{
	 	  	 	 	printf b[n] >> "'$savepath'"
	 	  	 	 	for(i=2; i<=NF; i++)
	 	  	 	 	 	{
	 	  	 	 	 	for(j in col_the_id)
	 	  	 	 	 	 	{
	 	  	 	 	 	 	if(i==col_the_id[j])
	 	  	 	 	 	 	 	{
	 	  	 	 	 	 	 	printf "\t"$i >> "'$savepath'"
	 	  	 	 	 	 	 	break
	 	  	 	 	 	 	 	}
	 	  	 	 	 	 	}
	 	  	 	 	 	}
	 	  	 	 	printf "\n" >> "'$savepath'"
	 	  	 	 	break;
	  	 	 	 	}
	  	 	 	}
  	 	 	}
  	 	}
  	}' $data1 $data2 
 #### norm the instance data
 data="instance_data.tsv"
 savepath="norm_instance_data.tsv"
 awk -F $'\t' '
  	{
 	for(i=1; i<=NF; i++)
 	 	{
 	 	raw[NR,i]=$i
 	 	}
 	}
	END{ 	
	 	printf raw[1,1] > "'$savepath'"
	 	for(i=2; i<=NF; i++)
	 	 	{
	 	 	printf "\t"raw[1,i] >> "'$savepath'"
	 	 	}
	 	printf"\n" >> "'$savepath'"
 	 	for(a=2; a<=NR; a++)
 	 	 	{
 	 	 	printf raw[a,1] >> "'$savepath'"
	 	 	for(b=2; b<=NF; b++)
	 	 	 	{
	 	 	 	norm1[a,b]=raw[a,b]/raw[a,a];
	 	 	 	norm2[a,b]=raw[a,b]/raw[b,b];
	 	 	 	norms[a,b]=(norm1[a,b]+norm2[a,b])/2;
	 	 	 	printf "\t"norms[a,b] >> "'$savepath'"
	 	  	 	}
	 	  	printf "\n" >> "'$savepath'"
	  	 	}
 	 	}' $data
 #### cut the data
 data1="instance_data.tsv"
 data2="norm_instance_data.tsv"
 cut="51"
 awk -F $'\t' '
  	{
  	if(NR==FNR)
  	 	{
  	 	if(FNR<='$cut')
  	 	 	{
  	 	 	printf $1 > "cut_'$data1'"
  	 	 	for(i=2; i<='$cut'; i++)
  	 	 	 	{
  	 	 	 	printf "\t"$i >> "cut_'$data1'"
  	 	 	 	}
  	 	 	printf "\n" >> "cut_'$data1'"
  	 	 	}
  	 	}
  	if(NR>FNR)
  	 	{
  	 	if(FNR<='$cut')
  	 	 	{
  	 	 	printf $1 > "cut_'$data2'"
  	 	 	for(i=2; i<='$cut'; i++)
  	 	 	 	{
  	 	 	 	printf "\t"$i >> "cut_'$data2'"
  	 	 	 	}
  	 	 	printf "\n" >> "cut_'$data2'"
  	 	 	}
  	 	}
  	}' $data1 $data2
 ####
 Rscript ~/Downloads/codes/ggplot2_heatmap.R
 ################################### Add to Methodology Content ################################################################################
 #### violin plot
 mkdir multi_pp_class
 ###################################
 data1="filter_0_class.tsv" #lignans and iridoids
 data2="results/canopus_pp.tsv"
 data3="com_compound.tsv"
 ex_export="com_1011.tsv"
 similarity_limit="0.4"
 ###################################
 for i in 0.4 0.5 0.6 0.7 0.8 0.9 0.95 0.99
 do
 class_pp_limit=$i
 #class_pp_limit="0.9"
 savename="multi_pp_class/for_sun_$class_pp_limit.tsv"
 awk -F $'\t' '
  	{
  	if(NR==FNR)
  	 	{
  	 	filter_class[$1]=$2
  	 	}
  	if(FILENAME~/canopus/)
  	 	{
  	 	if(FNR==1)
  	 	 	{
  	 	 	col_id=1
  	 	 	for(i=2; i<=NF; i++)
  	 	 	 	{
  	 	 	 	for(j in filter_class)
  	 	 	 	 	{
  	 	 	 	 	if(j==$i)
  	 	 	 	 	 	{
  	 	 	 	 	 	col_class[j]=i
  	 	 	 	 	 	print i
  	 	 	 	 	 	}
  	 	 	 	 	}
  	 	 	 	}
  	 	 	}
  	 	if(FNR>=2)
  	 	 	{
  	 	 	for(i in col_class)
  	 	 	 	{
  	 	 	 	if(sprintf("%.3f",$col_class[i])+0>="'$class_pp_limit'"+0)
  	 	 	 	 	{
  	 	 	 	 	class_set[i,$col_id]=i
  	 	 	 	 	print i,$col_class[i]
  	 	 	 	 	}
  	 	 	 	}
  	 	 	}
  	 	}
  	if(FILENAME~/'$data3'/)
  	 	{
  	 	if(FNR==1)
  	 	 	{
  	 	 	for(i=1; i<=NF; i++)
  	 	 	 	{
  	 	 	 	if($i~/^id/)
	 	 	 	 	{
	 	 	 	 	col_id=i
	 	 	 	 	}
	 	 	 	if($i~/log10_raw/)
	 	 	 	 	{
	 	 	 	 	col_log_raw=i
	 	 	 	 	}
	 	 	 	if($i~/log10_pro/)
	 	 	 	 	{
	 	 	 	 	col_log_pro=i
	 	 	 	 	}
	 	 	 	if($i~/similarity/)
	 	 	 	 	{
	 	 	 	 	col_similarity=i
	 	 	 	 	}
  	 	 	 	}
  	 	 	printf "id\t"  "classification\t"  "log10_raw\t"  "log10_pro\n" > "'$savename'"
  	 	 	\
  	 	 	printf $0"\n" > "'$ex_export'"
  	 	 	}
  	 	if(FNR>=2)
  	 	 	{
  	 	 	if($col_similarity+0 >= "'$similarity_limit'"+0)
  	 	 	 	{
	  	 	 	for(i in class_set)
	  	 	 	 	{
	  	 	 	 	if(i~"\034"$col_id"$")
	  	 	 	 	 	{
	  	 	 	 	 	printf $col_id"\t"  class_set[i]"\t"  $col_log_raw"\t"  $col_log_pro"\n" \
	  	 	 	 	 	\
	  	 	 	 	 	>> "'$savename'"
	  	 	 	 	 	\
	  	 	 	 	 	printf $0"\n" >> "'$ex_export'"
	  	 	 	 	 	}
	  	 	 	 	}
	  	 	 	}
  	 	 	}
  	 	}
  	}' $data1 $data2 $data3
 done
 ###################################
 #### stat num
 for i in 0.4 0.5 0.6 0.7 0.8 0.9 0.95 0.99
 do
 class_pp_limit=$i
 data="multi_pp_class/for_sun_$class_pp_limit.tsv"
 savepath="multi_pp_class/for_violin_${class_pp_limit}_pattern.tsv"
 awk -F $'\t' '
  	{
  	if(FNR==1)
  	 	{
  	 	printf $0"\n" > "'$savepath'"
  	 	}
  	num[$2]+=1
  	data[FNR]=$0
  	class[FNR]=$2
  	}
  	END{
  	 	for(i in num)
  	 	 	{
  	 	 	print i,num[i]
  	 	 	if(num[i]+0>=50)
  	 	 	 	{
  	 	 	 	for(j in class)
  	 	 	 	 	{
  	 	 	 	 	if(class[j]==i)
  	 	 	 	 	 	{
  	 	 	 	 	 	printf data[j]"\n" >> "'$savepath'"
  	 	 	 	 	 	}
  	 	 	 	 	}
  	 	 	 	}
  	 	 	}
  	 	}' $data
 done;
 #################
 #####################################  the former is network_facet
 for i in 0.4 0.5 0.6 0.7 0.8 0.9 0.95 0.99
 do
 class_pp_limit=$i
 mkdir results/network_facet_ladder2_$class_pp_limit
 data1="multi_pp_class/for_violin_${class_pp_limit}_pattern.tsv"
 data2="results/source_target_tree_0.4.tsv" # "results/source_target_tree_0.4.tsv"
 save_class="results/filter_child_class.tsv"
 savepath="results/network_facet_ladder2_$class_pp_limit/"
 awk -F $'\t' '
  	{
  	if(NR==FNR)
  	 	{
  	 	if(FNR==1)
  	 	 	{
  	 	 	for(i=1; i<=NF; i++)
  	 	 	 	{
  	 	 	 	if($i~/classification/)
  	 	 	 	 	{
  	 	 	 	 	col_class=i
  	 	 	 	 	}
  	 	 	 	if($i~/^id$/)
  	 	 	 	 	{
  	 	 	 	 	col_id=i
  	 	 	 	 	}
  	 	 	 	}
  	 	 	}
  	 	if(FNR>=2)
  	 	 	{
  	 	 	class[$col_class]=$col_class
  	 	 	class_id[$col_class,$col_id]=$col_id
  	 	 	stat_id[$col_class,$col_id]=$col_id
  	 	 	belong[$col_class,$col_id]=$col_class
  	 	 	}
  	 	}
  	if(NR>FNR)
  	 	{
  	 	if(FNR==1)
  	 	 	{
  	 	 	printf "" > "'$save_class'"
  	 	 	for(i in class)
  	 	 	 	{
  	 	 	 	printf i"\n" >> "'$save_class'"
  	 	 	 	printf $0"\t"  "facet\n" > "'$savepath'" i ".tsv"
  	 	 	 	}
  	 	 	}
  	 	if(FNR>=2)
  	 	 	{
  	 	 	for(i in class)
  	 	 	 	{
  	 	 	 	if( class_id[i,$1]==$1 && class_id[i,$2]==$2 )
  	 	 	 	 	{
  	 	 	 	 	printf $0"\t"  i"\n" >> "'$savepath'" i ".tsv"
  	 	 	 	 	delete stat_id[i,$1]
  	 	 	 	 	delete stat_id[i,$2]
  	 	 	 	 	}
  	 	 	 	}
  	 	 	}
  	 	}
  	}
  	END{
  	 	for(i in stat_id)
  	 	 	{
  	 	 	## source target similarity delta_mz fp fp class
  	 	 	printf stat_id[i]"\t" stat_id[i]"\t"  "1\t"  "0\t"  "null\t"  "null\t"  belong[i]"\n" \
  	 	 	\
  	 	 	>> "'$savepath'" belong[i] ".tsv"
  	 	 	}
  	 	}' $data1 $data2
 done;
 #################################
 ### for ring plot
 data1="canopus.tsv"
 data2="results/filter_child_class.tsv"
 data3="results/canopus_pp.tsv"
 savepath="results/canopus_pp_filter.tsv"
 awk -F $'\t' '
  	{
  	if(FILENAME~/canopus.tsv/)
  	 	{
  	 	if(FNR==1)
  	 	 	{
  	 	 	for(i=1; i<=NF; i++)
  	 	 	 	{
  	 	 	 	if($i~/absolute/)
  	 	 	 	 	{
  	 	 	 	 	col_index=i
  	 	 	 	 	}
  	 	 	 	if($i~/^id/)
  	 	 	 	 	{
  	 	 	 	 	col_chemid=i
  	 	 	 	 	}
  	 	 	 	if($i~/name/)
  	 	 	 	 	{
  	 	 	 	 	col_name=i
  	 	 	 	 	}
  	 	 	 	if($i~/description/)
  	 	 	 	 	{
  	 	 	 	 	col_des=i
  	 	 	 	 	}
  	 	 	 	}
  	 	 	}
  	 	if(FNR>2)
  	 	 	{
  	 	 	ab_index[$col_name]=$col_index
  	 	 	chemid[$col_name]=$col_chemid
  	 	 	des[$col_name]=$col_des
  	 	 	}
  	 	}
  	if(FILENAME~/filter_child_class/)
  	 	{
  	 	class[$1]=$1
  	 	if(FNR==1)
  	 	 	{
  	 	 	printf "index\t"  "chem_id\t"  "name\t"  "description\n" > "results/child_class.tsv"
  	 	 	}
  	 	printf ab_index[$1]"\t"  chemid[$1]"\t"  $1"\t"  des[$1]"\n" >> "results/child_class.tsv"
  	 	}
  	if(FILENAME~/canopus_pp/)
  	 	{
  	 	if(FNR==1)
  	 	 	{
  	 	 	printf $1 > "'$savepath'"
  	 	 	for(i=2; i<=NF; i++)
  	 	 	 	{
  	 	 	 	if(class[$i]!="")
  	 	 	 	 	{
  	 	 	 	 	n+=1
  	 	 	 	 	printf "\tC"ab_index[$i] >> "'$savepath'"
  	 	 	 	 	col_set[n]=i
  	 	 	 	 	}
  	 	 	 	}
  	 	 	printf "\n" >> "'$savepath'"
  	 	 	}
  	 	if(FNR>=2)
  	 	 	{
  	 	 	printf $1 >> "'$savepath'"
  	 	 	for(i=1; i<=n; i++)
  	 	 	 	{
  	 	 	 	printf "\t"$col_set[i] >> "'$savepath'"
  	 	 	 	}
  	 	 	printf "\n" >> "'$savepath'"
  	 	 	}
  	 	}
  	}' $data1 $data2 $data3
 #################################
 ## Eucommia peak erea normalized
 # accoding: com_lignans_and_iridoids.tsv 
 data=com_lignans_and_iridoids.tsv
 awk -F $'\t' '
  	{
  	}' $data
 #### ############  instance for 3d plot
 ### step1 RT ~ intensity
 Rscript ~/Downloads/codes/instance_3d_xcms.R
 #################  json tree 
 mkdir json_tree
 data1="com_lignans_and_iridoids.tsv"
 id=2268
 formula=C17H24O10
 data2="/media/wizard/back/0703_all/*_$id/trees/$formula*.json" ####### in media
 cp $data2 json_tree/tree_$id.json
 # id	rt	m/z	classification	variety	pro/raw
 # 3918	13.2883753333333	701.22926	Terpene glycosides	increase	52.5192 
 # 2529	11.5328771666667	699.24926	Lignan glycosides	increase	4.73482
 # 3674	7.13257936666667	551.16124	Iridoid O-glycosides	increase	3.91387
 # 3380	12.6588768333333	613.21304	Terpene glycosides	increase	3.9104
 data="json_tree/tree_$id.json"
 savepath="json_tree/"
 awk -F "[ ][:][ ]||[,]" '
  	{
  	if($0~/"root"/)
  	 	{
  	 	root=$2
  	 	}
  	if($0~/"id"/)
  	 	{
  	 	id[$2]=$2;
  	 	the_id=$2
  	 	getline;
  	 	formula[the_id]=$2
  	 	}
  	if($0~/"source"/)
  	 	{
  	 	source[$2]=$2
  	 	link[$2]+=1
  	 	the_source=$2
  	 	getline;
  	 	target[the_source, link[the_source]]=$2
  	 	getline;
  	 	formula_edge[the_source, link[the_source]]=$2
  	 	}
  	}
  	END{
  	 	printf "id\t" "label\n" > "'$savepath'"  "nodes_'$id'.tsv"
  	 	printf "from\t" "to\t" "label\n" > "'$savepath'"  "edges_'$id'.tsv"
  	 	#####
  	 	printf "root\t" root"\n" >> "'$savepath'"  "nodes_'$id'.tsv"
  	 	for(i in id)
  	 	 	{
  	 	 	printf i"\t" formula[i]"\n" >> "'$savepath'"  "nodes_'$id'.tsv"
  	 	 	}
  	 	for(i in source)
  	 	 	{
  	 	 	for(j=1; j<=link[i]; j++)
  	 	 	 	{
  	 	 	 	printf i"\t"  target[i,j]"\t" formula_edge[i,j]"\n" >> "'$savepath'"  "edges_'$id'.tsv"
  	 	 	 	}
  	 	 	}
  	 	}' $data
 ######################
 Rscript ~/Downloads/codes/json_tree.R
 ######################
 ## Image reshape
 ######################
 metadata="canopus_neg.tsv"
 #data="/media/wizard/back/0703_all/490_initial_8_neg_495/canopus/C17H24O10_[M-H]-.fpt"
 savepath="canopus_parent_index.tsv"
 awk -F $'\t' '
  	{
  	if(FNR==1)
  	 	{
  	 	for(i=1; i<=NF; i++)
  	 	 	{
  	 	 	if($i~/^id/)
  	 	 	 	{
  	 	 	 	col_id=i
  	 	 	 	}
  	 	 	if($i~/^parent/)
  	 	 	 	{
  	 	 	 	col_parent=i
  	 	 	 	}
  	 	 	}
  	 	}
  	if(FNR>=2)
  	 	{
  	 	parent[$col_id]=$col_parent
  	 	rows[FNR]=$col_id
  	 	#print rows[FNR]
  	 	}
  	}
  	END{
  	 	print "END"
  	 	printf "id\t"  "parentid\t"  "num\n" > "'$savepath'"
  	 	for(i=2; i<=FNR; i++)
  	 	 	{
  	 	 	root=rows[i]
  	 	 	num[root]+=1
  	 	 	index_id[rows[i]]=root
  	 	 	while(root!="")
  	 	 	 	{
  	 	 	 	if(parent[root]!="")
  	 	 	 	 	{
  	 	 	 	 	index_id[rows[i]]=parent[root]"-"index_id[rows[i]]
  	 	 	 	 	num[parent[root]]+=1
  	 	 	 	 	}
  	 	 	 	root=parent[root]
  	 	 	 	}
  	 	 	}
  	 	for(i=2; i<=FNR; i++)
  	 	 	{
  	 	 	printf rows[i]"\t"  index_id[rows[i]]"\t"  num[rows[i]]"\n" > "'$savepath'"
  	 	 	}
  	 	}' $metadata
 ######################
 #### 1028 violin plot
 ###################################
 data1="filter_0_class.tsv" #lignans and iridoids
 data2="results/canopus_pp.tsv"
 data3="com_compound.tsv"
 ex_export="com_1011.tsv"
 similarity_limit="0.4"
 ###################################
 class_pp_limit="0.9"
 savename="for_sun_$class_pp_limit.tsv"
 awk -F $'\t' '
  	{
  	if(NR==FNR)
  	 	{
  	 	filter_class[$1]=$2
  	 	}
  	if(FILENAME~/canopus/)
  	 	{
  	 	if(FNR==1)
  	 	 	{
  	 	 	col_id=1
  	 	 	for(i=2; i<=NF; i++)
  	 	 	 	{
  	 	 	 	for(j in filter_class)
  	 	 	 	 	{
  	 	 	 	 	if(j==$i)
  	 	 	 	 	 	{
  	 	 	 	 	 	col_class[j]=i
  	 	 	 	 	 	print i
  	 	 	 	 	 	}
  	 	 	 	 	}
  	 	 	 	}
  	 	 	}
  	 	if(FNR>=2)
  	 	 	{
  	 	 	for(i in col_class)
  	 	 	 	{
  	 	 	 	if(sprintf("%.3f",$col_class[i])+0 > "'$class_pp_limit'"+0)
  	 	 	 	 	{
  	 	 	 	 	class_set[i,$col_id]=i
  	 	 	 	 	print i,$col_class[i]
  	 	 	 	 	}
  	 	 	 	}
  	 	 	}
  	 	}
  	if(FILENAME~/'$data3'/)
  	 	{
  	 	if(FNR==1)
  	 	 	{
  	 	 	for(i=1; i<=NF; i++)
  	 	 	 	{
  	 	 	 	if($i~/^id/)
	 	 	 	 	{
	 	 	 	 	col_id=i
	 	 	 	 	}
	 	 	 	if($i~/log10_raw/)
	 	 	 	 	{
	 	 	 	 	col_log_raw=i
	 	 	 	 	}
	 	 	 	if($i~/log10_pro/)
	 	 	 	 	{
	 	 	 	 	col_log_pro=i
	 	 	 	 	}
	 	 	 	if($i~/similarity/)
	 	 	 	 	{
	 	 	 	 	col_similarity=i
	 	 	 	 	}
  	 	 	 	}
  	 	 	printf "id\t"  "classification\t"  "log10_raw\t"  "log10_pro\n" > "'$savename'"
  	 	 	\
  	 	 	printf $0"\n" > "'$ex_export'"
  	 	 	}
  	 	if(FNR>=2)
  	 	 	{
  	 	 	if($col_similarity+0 > "'$similarity_limit'"+0)
  	 	 	 	{
	  	 	 	for(i in class_set)
	  	 	 	 	{
	  	 	 	 	if(i~"\034"$col_id"$")
	  	 	 	 	 	{
	  	 	 	 	 	printf $col_id"\t"  class_set[i]"\t"  $col_log_raw"\t"  $col_log_pro"\n" \
	  	 	 	 	 	\
	  	 	 	 	 	>> "'$savename'"
	  	 	 	 	 	\
	  	 	 	 	 	printf $0"\n" >> "'$ex_export'"
	  	 	 	 	 	}
	  	 	 	 	}
	  	 	 	}
  	 	 	}
  	 	}
  	}' $data1 $data2 $data3
 ###################################
 #### stat num
 class_pp_limit=0.9
 data="for_sun_$class_pp_limit.tsv"
 savepath="for_violin_${class_pp_limit}.tsv"
 awk -F $'\t' '
  	{
  	if(FNR==1)
  	 	{
  	 	printf $0"\n" > "'$savepath'"
  	 	}
  	num[$2]+=1
  	data[FNR]=$0
  	class[FNR]=$2
  	}
  	END{
  	 	for(i in num)
  	 	 	{
  	 	 	print i,num[i]
  	 	 	if(num[i]+0>=50)
  	 	 	 	{
  	 	 	 	for(j in class)
  	 	 	 	 	{
  	 	 	 	 	if(class[j]==i)
  	 	 	 	 	 	{
  	 	 	 	 	 	printf data[j]"\n" >> "'$savepath'"
  	 	 	 	 	 	}
  	 	 	 	 	}
  	 	 	 	}
  	 	 	}
  	 	}' $data
 #################
 #################
```

# File: blender.sh

```{r eval = F, echo = T}
source activate parl
tmux new -s parl
tmux attach -t parl
cd ~/ParlAI; python setup.py develop
python projects/personachat/scripts/kvmemnn_interactive.py
python parlai/scripts/safe_interactive.py -mf zoo:blender/blender_9B/model -t blended_skill_talk

```

# File: cas_reformate.sh

```{r eval = F, echo = T}
###############
data="cas"
savepath="cas_arrange.tsv"
awk -F "[:]||['][,][ ][']||['][,][ ][\"]||[\"][,][ ][\"]||[\"][,][ ][']" '
 	{
 	if($1~/^\[/)
 	 	{
 	 	name=$1
 	 	id_num+=1
 	 	id[id_num]=name
 	 	print id_num, id[id_num]
 	 	}
 	if($1~/BEGIN_compound/)
 	 	{
 	 	num[id_num]+=1
 	 	getline;
 	 	for(i=1; i<=NF; i++)
 	 	 	{
 	 	 	if($i ~ /[0-9](.*)-[0-9][0-9]-[0-9](.*)$/ || $i ~ /^CAS/)
	 	 	 	{
	 	 	 	data[id_num,num[id_num]]=$i
	 	 	 	break;
	 	 	 	}
 	 	 	}
 	 	}
 	}
 	END{
 	 	printf "number\t"  "name\t"  "cas\n" > "'$savepath'"
 	 	for(i=1; i<=id_num; i++)
 	 	 	{
 	 	 	printf i"\t"id[i] >> "'$savepath'"
 	 	 	print i"\t"id[i]
 	 	 	for(j=1; j<=num[i]; j++)
 	 	 	 	{
 	 	 	 	printf "\t"data[i,j] >> "'$savepath'"
 	 	 	 	}
 	 	 	printf "\n" >> "'$savepath'"
 	 	 	}
 	 	}' $data
```

```{r eval = F, echo = T}
##############
data="cas_arrange.tsv"
sed -i -e 's/\[//g; s/\]//g; s/{//g; s/}//g' $data
```

# File: clamscan.sh

```{r eval = F, echo = T}
clamscan -r --bell -i /home
```

# File: colorful_line_eucommia_bash.sh

```{r eval = F, echo = T}
datapath="/media/wizard/back/thermo_mzML_0518/EIC"
mkdir $datapath/EIC_merge
echo "" > $datapath/file.tsv
data1="$datapath/../metadata.tsv"
data2="$datapath/EIC*.mzML/*.tsv"
awk -F $'\t' '
{
  if(NR==FNR)
    {
      if(NR>=2)
        {
          total_id[FNR]=$1
        }
    }
  if(FILENAME~/intensity/)
    {
      if(FNR==1)
        {
          n=split(FILENAME,f,"[/]")
          split(f[n-1], g,"[_]")
          samplename=g[2]
          split(f[n], a, "[_]")
          id=a[1]
          if(samplename!=p_samplename)
            {
              num_sample+=1
              sample[num_sample]=samplename
            }
          p_samplename=samplename
        }
      if(FNR>=1)
        {
          data_scan[samplename,id,FNR]=$1
          if($2!="NA")
            {
              data_intensity[samplename,id,FNR]=$2
            }
        else
          {
            data_intensity[samplename,id,FNR]="0"
          }
      }
  }
if(FILENAME~/rt.tsv/)
  {
    if(FNR==1)
      {
        n=split(FILENAME,f,"[/]")
        split(f[n-1], g,"[_]")
        samplename=g[2]
        printf samplename"\n"
      }
    if(FNR>=1)
      {
        data_scan[samplename,FNR]=$1
        data_rt[samplename,FNR]=$2
        max_rows[samplename]=FNR
      }
  }
}
END{
for(i in total_id)
  {
    printf "rt\t"  "intensity\t"  "sample\n" > "'$datapath'/EIC_merge/" total_id[i] ".tsv"
    for(j in sample)
      {
        for(k=1; k<=max_rows[sample[j]]; k++)
          {
            printf data_rt[sample[j],k]"\t"  data_intensity[sample[j],total_id[i],k]"\t"  sample[j]"\n" \
              >> "'$datapath'/EIC_merge/" total_id[i] ".tsv"
            }
        }
    }
}' $data1 $data2
```

```{r eval = F, echo = T}
######################################
mkdir results/EIC_rt_during
data1="/media/wizard/back/thermo_mzML_0518/EIC/metadata.tsv"
data2="results/re_neg_RT.tsv"
data3="/media/wizard/back/thermo_mzML_0518/EIC/EIC_merge/*.tsv"
savepath="results/EIC_rt_during/"
excess_time="0.1"
awk -F $'\t' '
{
  if(NR==FNR)
    {
      group_name[$1]=$2
    }
  if(FILENAME~/results/)
    {
      if(FNR==1)
        {
          p_file=FILENAME
          for(i=1; i<=NF; i++)
            {
              if($i~/ID/)
                {
                  col_id=i
                }
              if($i~/m\/z/)
                {
                  col_mz=i
                }
              if($i~/retention/)
                {
                  col_rt=i
                }
              if($i~/start$/)
                {
                  split($i,a,"[ ]")
                  samplename=a[1]
                  # print samplename
                  col_start[samplename]=i
                }
              if($i~/end$/)
                {
                  split($i,a,"[ ]")
                  samplename=a[1]
                  col_end[samplename]=i
                }
            }
        }
      if(FNR>=2)
        {
          mz[$col_id]=$col_mz
          # print $col_mz
          center_rt[$col_id]=$col_rt
          for(i in col_start)
            {
              if($col_start[i]!="0")
                {
                  rt_start[$col_id,i]=$col_start[i]
                  # print $col_start[i]
                }
            else if(reference_sample[$col_id]=="")
              {
                for(j in col_start)
                  {
                    if($col_start[j]!="0")
                      {
                        rt_start[$col_id,i]=$col_start[j]
                        reference_sample[$col_id]=j
                        break;
                      }
                  }
              }
          else
            {
              rt_start[$col_id,i]=$col_start[reference_sample[$col_id]]
            }
        }
      for(i in col_end)
        {
          if($col_end[i]!="0")
            {
              rt_end[$col_id,i]=$col_end[i]
            }
        else
          {
            rt_end[$col_id,i]=$col_end[reference_sample[$col_id]]
          }
      }
  }
}
if(FILENAME~/EIC_merge/)
  {
    if(FNR==1)
      {
        close(p_file)
        p_file=FILENAME
        close("'$savepath'" p_id ".tsv")
        num_id+=1
        n=split(FILENAME,a,"[/]||[.]")
        id=a[n-1]
        # print id
        p_id=id
        if(num_id==1)
          {
            for(i=1; i<=NF; i++)
              {
                if($i~/^rt/)
                  {
                    col_rt=i
                  }
                if($i~/intensity/)
                  {
                    col_intensity=i
                  }
                if($i~/sample/)
                  {
                    col_sample=i
                  }
              }
          }
        printf $0"\t" "group\t" "label\t" "color\t" "mz\t" "center_rt\n" > "'$savepath'" id ".tsv"
      }
    if(FNR>=2)
      {
        rt_min=($col_rt)/60
        if(threshold[id,$col_sample]=="")
          {
            threshold[id,$col_sample]=rt_start[id,$col_sample]+(rt_end[id,$col_sample]-rt_start[id,$col_sample])*(1/2)
          }
        if(rt_min>=rt_start[id,$col_sample]-"'$excess_time'" && rt_min<=rt_end[id,$col_sample]+"'$excess_time'")
          {
            if(rt_min+0>=threshold[id,$col_sample] && end_sig[id,$col_sample]!="1")
              {
                label_sig[id,$col_sample]=1
                end_sig[id,$col_sample]=1
              }
          else
            {
              label_sig[id,$col_sample]=0
            }
          if(rt_min+0>=rt_start[id,$col_sample]+0 && rt_min+0<=rt_end[id,$col_sample]+0)
            {
              color[id,$col_sample]=group_name[$col_sample]
            }
        else
          {
            color[id,$col_sample]="Non feature"
          }
        printf sprintf("%.2f",rt_min)"\t"  $col_intensity"\t"  $col_sample"\t"  group_name[$col_sample]"\t" label_sig[id,$col_sample]"\t"  color[id,$col_sample] >> "'$savepath'" id ".tsv"
        start_FNR[id]+=1
        if(start_FNR[id]=="1")
          {
            printf "\t"sprintf("%.4f",mz[id])  "\t"sprintf("%.2f",center_rt[id]) >> "'$savepath'" id ".tsv"
          }
        printf "\n" >> "'$savepath'" id ".tsv"
      }
  }
}
}' $data1 $data2 $data3

```

# File: convert_margin.sh

```{r eval = F, echo = T}
convert cluster_accuracy_bar.png \
-define trim:edges=north,east,south,west \
-background white \
-fuzz 90% \
-trim \
test.png

```

# File: display.sh

```{r eval = F, echo = T}
read -p "The Display Mode >>> " parameter
if [ $parameter == 0 ]
then
  i=0
elif [ $parameter == 1 ]
then
  i=9
fi
xrandr -s $i
```

# File: eucommia_analysis.sh

```{r eval = F, echo = T}
## new algorithm (transform principle)
```

```{r eval = F, echo = T}
######## here the low pp will be filtered
data="results/stat_classification.tsv"
stat=$(awk -F $'\t' '
{
  if(NR==1)
    {
      for(i=1; i<=NF; i++)
        {
          if($i~/^id$/)
            {
              col_id=i
            }
          if($i~/^definition$/)
            {
              col_definition=i
            }
        }
    }
  if(NR>=2)
    {
      if($col_definition!="null")
        {
          id_class[$col_id]=$col_definition
          class_num[$col_definition]+=1
        }
    }
}
END{
for(i in class_num)
  {
    printf i"\t"  class_num[i]"\t"
    for(j in id_class)
      {
        if(id_class[j]==i)
          {
            printf j"@"
          }
      }
    printf "\n"
  }
}' $data | sed 's/@$//g')
data2="results/re_neg_RT.tsv"
echo "" > results/neg_RT.tsv
data3="results/neg_RT.tsv"
compar1="Raw"
compar2="Pro"
log=10
log_to=2
awk -F ["\t"@] -v OFS=$'\t' '
BEGIN{
maxNF=0
rows=0
compar1n=0
compar2n=0
}
{
  if(NR==FNR)
    {
      rows+=1
      if(maxNF<NF)
        {
          maxNF=NF
        }
      class[FNR]=$1
      num[FNR]=$2
      for(j=3; j<=NF; j++)
        {
          id[FNR,j]=$j
        }
    }
else
  {
    if(FNR==1 && FILENAME~/re_/)
      {
        for(i=1; i<=NF; i++)
          {
            if(($i~/'$compar1'/) && $i~/area/)
              {
                colum1[i]=i
                compar1n+=1
              }
            if(($i~/'$compar2'/) && $i~/area/)
              {
                colum2[i]=i
                compar2n+=1
              }
            if(($i~/retention/))
              {
                rtcolum=i
              }
            if(($i~/m\/z/))
              {
                mzcolum=i
              }
          }
      }
    if(FNR>=2 && $0!="")
      {
        if(sum[1,$1]=="" && sum[2,$1]=="") ######## revise data 
          {
            sum[1,$1]=0
            sum[2,$1]=0
            rt[$1]=$rtcolum
            mz[$1]=$mzcolum
            for(i=1; i<=NF; i++)
              {
                if(i==colum1[i] && colum1[i]!="")
                  {
                    sum[1,$1]+=$i
                  }
                if(i==colum2[i] && colum2[i]!="")
                  {
                    sum[2,$1]+=$i
                  }
              }
          }
      }
  }
}
END{
printf "class\t"  "id\t"  "log'$log'_raw\t"  "log'$log'_pro\t" \
  "log'$log'_delta_area\t"  "pro_to_raw\t"  "log'$log_to'_pro_to_raw\t"  "variety\t"  "number\t" > "algorithm.tsv"
  printf "rt\t"  "m/z\n" >> "algorithm.tsv"
  for(i=1; i<=rows; i++)
    {
      for(j=3; j<=maxNF; j++)
        {
          if(id[i,j]!="")
            {
              raw=(sum[1,id[i,j]]/compar1n)
              pro=(sum[2,id[i,j]]/compar2n)
              log_raw=log(raw)/log('$log')
              log_pro=log(pro)/log('$log')
              delta_area=pro-raw
              if(raw!=0)
                {
                  to_raw=pro/raw
                  norm_to_raw=log(to_raw)/log('$log_to')
                }
            else
              {
                to_raw="infinity"
                norm_to_raw="infinity"
              }
            if(delta_area+0>0)
              {
                norm_delta=log(delta_area)/log('$log')
                variety="increase"
              }
          else if(delta_area<0)
            {
              norm_delta=-1*(log(-1*delta_area)/log('$log'))
              variety="decrease"
            }
        else
          {
            norm_delta=0
          }
        printf class[i]"\t"  id[i,j]"\t"  log_raw"\t"  log_pro"\t" \
          norm_delta"\t"  to_raw"\t"  norm_to_raw"\t"  variety"\t"  num[i]"\t" \
          rt[id[i,j]]"\t"  mz[id[i,j]]"\n" >> "algorithm.tsv"
        }
    }
}
}' <(echo "$stat") $data2 $data3
```

```{r eval = F, echo = T}
#######################
data="algorithm.tsv"
awk -F $'\t' -v OFS=$'\t' '
{
  if(NR==1)
    {
      print "id","rt","m/z","classification","variety","pro/raw","log10_raw","log10_pro","norm_delta" > "compound.tsv"
      for(i=1; i<=NF; i++)
        {
          if($i~/^id/)
            {
              col_id=i
            }
          if($i~/^rt/)
            {
              col_rt=i
            }
          if($i~/m\/z/)
            {
              col_mz=i
            }
          if($i~/class/)
            {
              col_class=i
            }
          if($i~/variety/)
            {
              col_variety=i
            }
          if($i~/^pro_to_raw/)
            {
              col_ratio=i
            }
          if($i~/log10_raw/)
            {
              col_log10_raw=i
            }
          if($i~/log10_pro/)
            {
              col_log10_pro=i
            }
          if($i~/delta_area/)
            {
              col_delta=i
            }
        }
    }
  if(NR>=2)
    {
      print $col_id, $col_rt, sprintf("%.5f",$col_mz), $col_class, $col_variety, $col_ratio, $col_log10_raw, $col_log10_pro, \
        $col_delta \
        >> "compound.tsv"
      }
  }' $data
```

```{r eval = F, echo = T}
########################
data="results/fingerid_first_score.tsv"
list="compound.tsv"
awk -F $'\t' '	
{
  if(NR==FNR)
    {
      if(FNR==1)
        {
          for(i=1; i<=NF; i++)
            {
              if($i~/^id/)
                {
                  col_id=i
                }
              if($i~/similarity/)
                {
                  col_simi=i
                }
              if($i~/name/)
                {
                  col_name=i
                }
              if($i~/formula/)
                {
                  col_formula=i
                }
              if($i~/^inchi$/)
                {
                  col_inchi=i
                }
              if($i~/smiles/)
                {
                  col_smiles=i
                }
              if($i~/score/)
                {
                  col_score=i
                }
              if($i~/xlogp/)
                {
                  col_xlogp=i
                }
              if($i~/inchikey2D/)
                {
                  col_inchikey2D=i
                }
              if($i~/links/)
                {
                  col_links=i
                }
            }
        }
      if(FNR>=2)
        {
          simi[$col_id]=$col_simi
          name[$col_id]=$col_name
          formula[$col_id]=$col_formula
          smiles[$col_id]=$col_smiles
          inchi[$col_id]=$col_inchi
          inchikey2D[$col_id]=$col_inchikey2D
          score[$col_id]=$col_score
          xlogp[$col_id]=$col_xlogp
          links[$col_id]=$col_links
        }
    }
  if(NR!=FNR)
    {
      if(FNR==1)
        {
          for(i=1; i<=NF; i++)
            {
              if($i~/^id/)
                {
                  col_list_id=i
                }
              printf $i"\t" > "com_compound.tsv"
            }
          printf "similarity\t"  "name\t"  "formula\t"  "xlogp\t"  "smiles\t" \
            "inchi\t"  "inchikey2D\t"  "links\n" >> "com_compound.tsv"
          }
        if(FNR>=2)
          {
            for(i=1; i<=NF; i++)
              {
                printf $i"\t" >> "com_compound.tsv"
              }
            printf simi[$col_list_id]"\t"  name[$col_list_id]"\t"  formula[$col_list_id]"\t"  xlogp[$col_list_id]"\t" \
              smiles[$col_list_id]"\t" inchi[$col_list_id]"\t"  inchikey2D[$col_list_id]"\t" \
              links[$col_list_id]"\n" >> "com_compound.tsv"
            }
        }
    }' $data $list
  #############################
  #search 
  data="com_compound.tsv"
  savename="com_lignans_and_iridoids.tsv"
  awk -F $'\t' '
  {
    if(FNR==1)
      {
        for(i=1; i<=NF; i++)
          {
            if($i~/class/)
              {
                col_classification=i
              }
          }
        printf $0"\n" > "'$savename'"
      }
    if(FNR>=2)
      {
        if(tolower($col_classification)~/iridoid/)
          {
            printf $0"\n" >> "'$savename'"
          }
        if(tolower($col_classification)~/lignan/)
          {
            printf $0"\n" >> "'$savename'"
          }
      }
  }' $data
### filter_class
```

```{r eval = F, echo = T}
###########################
```

```{r eval = F, echo = T}
###########################
```

```{r eval = F, echo = T}
###################

 #########################
 ###sun.tsv
 ###matrix
 #	 id	classification	log10_raw	log10_pro
 #	147	Lignans, neolignans and related compounds	6.11895	6.51289
 #	147	Furofuran lignans	6.11895	6.51289
 #	147	O-methylated flavonoids	6.11895	6.51289
 #	147	Coumaric acids and derivatives	6.11895	6.51289
 #	147	Amino acids and derivatives	6.11895	6.51289
 #	147	Terpene glycosides	6.11895	6.51289
 data="for_sun.tsv"
 awk -F $'\t' '
 {
   if(NR==1)
     {
       for(i=1; i<=NF; i++)
         {
           if($i~/^id/)
             {
               col_id=i
             }
           if($i~/class/)
             {
               col_class=i
             }
           if($i~/log10_raw/)
             {
               col_log_raw=i
             }
           if($i~/log10_pro/)
             {
               col_log_pro=i
             }
         }
     }
   if(NR>=2)
     {
       id[FNR]=$col_id
       class[FNR]=$col_class
       uniq_class[$col_class]=$col_class
       log_raw[FNR]=$col_log_raw
       log_pro[FNR]=$col_log_pro
     }
 }
END{
printf "name\t"  "group\t"
for(i=2; i<=NR; i++)
  {
    if(i<NR)
      {
        printf "raw_"id[i]"\t"  "pro_"id[i]"\t"
      }
    if(i==NR)
      {
        printf "raw_"id[i]"\t"  "pro_"id[i]"\n"
      }
  }
for(i in uniq_class)
  {
    printf uniq_class[i]"\t"  "NA\t"
    {
      for(j=2; j<=NR; j++)
        {
          if(j<NR)
            {
              if(class[j]==uniq_class[i])
                {
                  if(log_raw[j]!="-inf")
                    {
                      printf log_raw[j]*(-1)"\t"  log_pro[j]"\t"
                    }
                else
                  {
                    printf 0"\t"  log_pro[j]"\t"
                  }
              }
          else
            {
              printf "0\t"  "0\t"
            }
        }
    else
      {
        if(class[j]==uniq_class[i])
          {
            if(log_raw[j]!="-inf")
              {
                printf log_raw[j]*(-1)"\t"  log_pro[j]"\n"
              }
          else
            {
              printf 0"\t"  log_pro[j]"\n"
            }
        }
    else
      {
        printf "0\t"  "0\n"
      }
  }
}
}
}
}
' $data > sun.tsv
```

```{r eval = F, echo = T}
##########
sort -t $'\t' -k 7 -n com_lignans_and_iridoids.tsv > test.tsv
awk -F $'\t' '
{
  if(NR==1)
    {
      printf "rank\t"  "log10_pro\t"  $0"\n"
      rank=255
      for(i=1; i<=NF; i++)
        {
          if($i~/pro\/raw/)
            {
              col_ratio=i
            }
          if($i~/log10_raw/)
            {
              col_log_raw=i
            }
        }
    }
  if(NR>=2)
    {
      printf rank"\t"  $col_log_raw+log($col_log_raw)/log(10)"\t"  $0"\n"
      rank-=1
    }
}' test.tsv > rank.tsv
```

```{r eval = F, echo = T}
######################################
##xcms
data="com_lignans_and_iridoids.tsv"
savepath="../thermo_mzML_0518/EIC_metadata.tsv"
awk -F $'\t' '
{
  if(NR==1)
    {
      for(i=i; i<=NF; i++)
        {
          if($i~/^id$/)
            {
              col_id=i
            }
          if($i~/m\/z/)
            {
              col_mz=i
            }
        }
      printf "id\t"  "m/z\n" > "'$savepath'"
    }
  if(NR>=2)
    {
      printf $col_id"\t"  $col_mz"\n" >> "'$savepath'"
    }
}' $data
```

```{r eval = F, echo = T}
######################################
```

```{r eval = F, echo = T}
######################################
#peak during time Correction
data1="results/neg_RT.tsv"
data2="results/0924_neg_RT.tsv"
savepath="results/re_neg_RT.tsv"
mz_tolerance=0.005
rt_tolerance=0.1
awk -F $'\t' '
{
  if(NR==FNR)
    {
      if(FNR==1)
        {
          for(i=1; i<=NF; i++)
            {
              if($i~/ID/)
                {
                  col_id=i
                }
              if($i~/retention/)
                {
                  col_rt=i
                }
              if($i~/m\/z/)
                {
                  col_mz=i
                }
            }
        }
      if(FNR>=2)
        {
          data1_mz[$col_id]=$col_mz
          data1_rt[$col_id]=$col_rt
          set[$col_id]=$col_id
          dataset[$col_id]=$0
        }
    }
  if(NR>FNR)
    {
      if(FNR==1)
        {
          printf $0"\n" > "'$savepath'"
          for(i=1; i<=NF; i++)
            {
              if($i~/ID/)
                {
                  col_id=i
                }
              if($i~/retention/)
                {
                  col_rt=i
                }
              if($i~/m\/z/)
                {
                  col_mz=i
                }
            }
        }
      if(FNR>=2)
        {
          data2_mz[$col_id]=$col_mz
          data2_rt[$col_id]=$col_rt
          for(i in data1_mz)
            {
              if(data1_mz[i]<=$col_mz+"'$mz_tolerance'" && data1_mz[i]>=$col_mz-"'$mz_tolerance'")
                {
                  if(data1_rt[i]<=$col_rt+"'$rt_tolerance'" && data1_rt[i]>=$col_rt-"'$rt_tolerance'")
                    {
                      data1_num[i]+=1
                      delete set[i];
                      print "data1",i,">>>","data2",$col_id,">>>",data1_num[i]
                      printf i"\t" data1_mz[i]"\t" data1_rt[i] >> "'$savepath'"
                      for(j=4; j<=NF; j++)
                        {
                          printf "\t"$j >> "'$savepath'"
                        }
                      printf "\n" >> "'$savepath'"
                    }
                }
            }
        }
    }
}
END{
for(i in set)
  {
    printf dataset[i]"\n" >> "'$savepath'"
    printf set[i]"\n"
  }
}' $data1 $data2
```

```{r eval = F, echo = T}
######################################
datapath="/media/wizard/back/thermo_mzML_0518/EIC"
mkdir $datapath/EIC_merge
echo "" > $datapath/file.tsv
data1="$datapath/../metadata.tsv"
data2="$datapath/EIC*.mzML/*.tsv"
awk -F $'\t' '
{
  if(NR==FNR)
    {
      if(NR>=2)
        {
          total_id[FNR]=$1
        }
    }
  if(FILENAME~/intensity/)
    {
      if(FNR==1)
        {
          n=split(FILENAME,f,"[/]")
          split(f[n-1], g,"[_]")
          samplename=g[2]
          split(f[n], a, "[_]")
          id=a[1]
          if(samplename!=p_samplename)
            {
              num_sample+=1
              sample[num_sample]=samplename
            }
          p_samplename=samplename
        }
      if(FNR>=1)
        {
          data_scan[samplename,id,FNR]=$1
          if($2!="NA")
            {
              data_intensity[samplename,id,FNR]=$2
            }
        else
          {
            data_intensity[samplename,id,FNR]="0"
          }
      }
  }
if(FILENAME~/rt.tsv/)
  {
    if(FNR==1)
      {
        n=split(FILENAME,f,"[/]")
        split(f[n-1], g,"[_]")
        samplename=g[2]
        printf samplename"\n"
      }
    if(FNR>=1)
      {
        data_scan[samplename,FNR]=$1
        data_rt[samplename,FNR]=$2
        max_rows[samplename]=FNR
      }
  }
}
END{
for(i in total_id)
  {
    printf "rt\t"  "intensity\t"  "sample\n" > "'$datapath'/EIC_merge/" total_id[i] ".tsv"
    for(j in sample)
      {
        for(k=1; k<=max_rows[sample[j]]; k++)
          {
            printf data_rt[sample[j],k]"\t"  data_intensity[sample[j],total_id[i],k]"\t"  sample[j]"\n" \
              >> "'$datapath'/EIC_merge/" total_id[i] ".tsv"
            }
        }
    }
}' $data1 $data2
```

```{r eval = F, echo = T}
######################################
mkdir results/EIC_rt_during
data1="/media/wizard/back/thermo_mzML_0518/EIC/metadata.tsv"
data2="results/re_neg_RT.tsv"
data3="/media/wizard/back/thermo_mzML_0518/EIC/EIC_merge/*.tsv"
savepath="results/EIC_rt_during/"
excess_time="0.1"
awk -F $'\t' '
{
  if(NR==FNR)
    {
      group_name[$1]=$2
    }
  if(FILENAME~/results/)
    {
      if(FNR==1)
        {
          p_file=FILENAME
          for(i=1; i<=NF; i++)
            {
              if($i~/ID/)
                {
                  col_id=i
                }
              if($i~/m\/z/)
                {
                  col_mz=i
                }
              if($i~/retention/)
                {
                  col_rt=i
                }
              if($i~/start$/)
                {
                  split($i,a,"[ ]")
                  samplename=a[1]
                  # print samplename
                  col_start[samplename]=i
                }
              if($i~/end$/)
                {
                  split($i,a,"[ ]")
                  samplename=a[1]
                  col_end[samplename]=i
                }
            }
        }
      if(FNR>=2)
        {
          mz[$col_id]=$col_mz
          # print $col_mz
          center_rt[$col_id]=$col_rt
          for(i in col_start)
            {
              if($col_start[i]!="0")
                {
                  rt_start[$col_id,i]=$col_start[i]
                  # print $col_start[i]
                }
            else if(reference_sample[$col_id]=="")
              {
                for(j in col_start)
                  {
                    if($col_start[j]!="0")
                      {
                        rt_start[$col_id,i]=$col_start[j]
                        reference_sample[$col_id]=j
                        break;
                      }
                  }
              }
          else
            {
              rt_start[$col_id,i]=$col_start[reference_sample[$col_id]]
            }
        }
      for(i in col_end)
        {
          if($col_end[i]!="0")
            {
              rt_end[$col_id,i]=$col_end[i]
            }
        else
          {
            rt_end[$col_id,i]=$col_end[reference_sample[$col_id]]
          }
      }
  }
}
if(FILENAME~/EIC_merge/)
  {
    if(FNR==1)
      {
        close(p_file)
        p_file=FILENAME
        close("'$savepath'" p_id ".tsv")
        num_id+=1
        n=split(FILENAME,a,"[/]||[.]")
        id=a[n-1]
        # print id
        p_id=id
        if(num_id==1)
          {
            for(i=1; i<=NF; i++)
              {
                if($i~/^rt/)
                  {
                    col_rt=i
                  }
                if($i~/intensity/)
                  {
                    col_intensity=i
                  }
                if($i~/sample/)
                  {
                    col_sample=i
                  }
              }
          }
        printf $0"\t" "group\t" "label\t" "color\t" "mz\t" "center_rt\n" > "'$savepath'" id ".tsv"
      }
    if(FNR>=2)
      {
        rt_min=($col_rt)/60
        if(threshold[id,$col_sample]=="")
          {
            threshold[id,$col_sample]=rt_start[id,$col_sample]+(rt_end[id,$col_sample]-rt_start[id,$col_sample])*(1/2)
          }
        if(rt_min>=rt_start[id,$col_sample]-"'$excess_time'" && rt_min<=rt_end[id,$col_sample]+"'$excess_time'")
          {
            if(rt_min+0>=threshold[id,$col_sample] && end_sig[id,$col_sample]!="1")
              {
                label_sig[id,$col_sample]=1
                end_sig[id,$col_sample]=1
              }
          else
            {
              label_sig[id,$col_sample]=0
            }
          if(rt_min+0>=rt_start[id,$col_sample]+0 && rt_min+0<=rt_end[id,$col_sample]+0)
            {
              color[id,$col_sample]=group_name[$col_sample]
            }
        else
          {
            color[id,$col_sample]="Non feature"
          }
        printf sprintf("%.2f",rt_min)"\t"  $col_intensity"\t"  $col_sample"\t"  group_name[$col_sample]"\t" label_sig[id,$col_sample]"\t"  color[id,$col_sample] >> "'$savepath'" id ".tsv"
        start_FNR[id]+=1
        if(start_FNR[id]=="1")
          {
            printf "\t"sprintf("%.4f",mz[id])  "\t"sprintf("%.2f",center_rt[id]) >> "'$savepath'" id ".tsv"
          }
        printf "\n" >> "'$savepath'" id ".tsv"
      }
  }
}
}' $data1 $data2 $data3
```

```{r eval = F, echo = T}
##############################
```

```{r eval = F, echo = T}
#### violin plot
mkdir multi_pp_class
```

```{r eval = F, echo = T}
###################################
data1="filter_0_class.tsv" #lignans and iridoids
data2="results/canopus_pp.tsv"
data3="com_compound.tsv"
ex_export="com_1011.tsv"
similarity_limit="0.4"
```

```{r eval = F, echo = T}
###################################
for i in 0.4 0.5 0.6 0.7 0.8 0.9 0.95 0.99
do
  class_pp_limit=$i
  #class_pp_limit="0.9"
  savename="multi_pp_class/for_sun_$class_pp_limit.tsv"
  awk -F $'\t' '
  {
    if(NR==FNR)
      {
        filter_class[$1]=$2
      }
    if(FILENAME~/canopus/)
      {
        if(FNR==1)
          {
            col_id=1
            for(i=2; i<=NF; i++)
              {
                for(j in filter_class)
                  {
                    if(j==$i)
                      {
                        col_class[j]=i
                        print i
                      }
                  }
              }
          }
        if(FNR>=2)
          {
            for(i in col_class)
              {
                if(sprintf("%.3f",$col_class[i])+0>="'$class_pp_limit'"+0)
                  {
                    class_set[i,$col_id]=i
                    print i,$col_class[i]
                  }
              }
          }
      }
    if(FILENAME~/'$data3'/)
      {
        if(FNR==1)
          {
            for(i=1; i<=NF; i++)
              {
                if($i~/^id/)
                  {
                    col_id=i
                  }
                if($i~/log10_raw/)
                  {
                    col_log_raw=i
                  }
                if($i~/log10_pro/)
                  {
                    col_log_pro=i
                  }
                if($i~/similarity/)
                  {
                    col_similarity=i
                  }
              }
            printf "id\t"  "classification\t"  "log10_raw\t"  "log10_pro\n" > "'$savename'"
            printf $0"\n" > "'$ex_export'"
          }
        if(FNR>=2)
          {
            if($col_similarity+0 >= "'$similarity_limit'"+0)
              {
                for(i in class_set)
                  {
                    if(i~"\034"$col_id"$")
                      {
                        printf $col_id"\t"  class_set[i]"\t"  $col_log_raw"\t"  $col_log_pro"\n" >> "'$savename'"
                        printf $0"\n" >> "'$ex_export'"
                      }
                  }
              }
          }
      }
  }' $data1 $data2 $data3
done
```

```{r eval = F, echo = T}
###################################
```

```{r eval = F, echo = T}
#### stat num
for i in 0.4 0.5 0.6 0.7 0.8 0.9 0.95 0.99
do
  class_pp_limit=$i
  data="multi_pp_class/for_sun_$class_pp_limit.tsv"
  savepath="multi_pp_class/for_violin_${class_pp_limit}_pattern.tsv"
  awk -F $'\t' '
  {
    if(FNR==1)
      {
        printf $0"\n" > "'$savepath'"
      }
    num[$2]+=1
    data[FNR]=$0
    class[FNR]=$2
  }
END{
for(i in num)
  {
    print i,num[i]
    if(num[i]+0>=50)
      {
        for(j in class)
          {
            if(class[j]==i)
              {
                printf data[j]"\n" >> "'$savepath'"
              }
          }
      }
  }
}' $data
done;
```

```{r eval = F, echo = T}
#################
```

```{r eval = F, echo = T}
#####################################  the former is network_facet
for i in 0.4 0.5 0.6 0.7 0.8 0.9 0.95 0.99
do
  class_pp_limit=$i
  mkdir results/network_facet_ladder2_$class_pp_limit
  data1="multi_pp_class/for_violin_${class_pp_limit}_pattern.tsv"
  data2="results/source_target_tree_0.4.tsv" # "results/source_target_tree_0.4.tsv"
  save_class="results/filter_child_class.tsv"
  savepath="results/network_facet_ladder2_$class_pp_limit/"
  awk -F $'\t' '
  {
    if(NR==FNR)
      {
        if(FNR==1)
          {
            for(i=1; i<=NF; i++)
              {
                if($i~/classification/)
                  {
                    col_class=i
                  }
                if($i~/^id$/)
                  {
                    col_id=i
                  }
              }
          }
        if(FNR>=2)
          {
            class[$col_class]=$col_class
            class_id[$col_class,$col_id]=$col_id
            stat_id[$col_class,$col_id]=$col_id
            belong[$col_class,$col_id]=$col_class
          }
      }
    if(NR>FNR)
      {
        if(FNR==1)
          {
            printf "" > "'$save_class'"
            for(i in class)
              {
                printf i"\n" >> "'$save_class'"
                printf $0"\t"  "facet\n" > "'$savepath'" i ".tsv"
              }
          }
        if(FNR>=2)
          {
            for(i in class)
              {
                if( class_id[i,$1]==$1 && class_id[i,$2]==$2 )
                  {
                    printf $0"\t"  i"\n" >> "'$savepath'" i ".tsv"
                    delete stat_id[i,$1]
                    delete stat_id[i,$2]
                  }
              }
          }
      }
  }
END{
for(i in stat_id)
  {
    ## source target similarity delta_mz fp fp class
    printf stat_id[i]"\t" stat_id[i]"\t"  "1\t"  "0\t"  "null\t"  "null\t"  belong[i]"\n" >> "'$savepath'" belong[i] ".tsv"
  }
}' $data1 $data2
done;
```

```{r eval = F, echo = T}
#################################
### for ring plot
data1="canopus.tsv"
data2="results/filter_child_class.tsv"
data3="results/canopus_pp.tsv"
savepath="results/canopus_pp_filter.tsv"
awk -F $'\t' '
{
  if(FILENAME~/canopus.tsv/)
    {
      if(FNR==1)
        {
          for(i=1; i<=NF; i++)
            {
              if($i~/absolute/)
                {
                  col_index=i
                }
              if($i~/^id/)
                {
                  col_chemid=i
                }
              if($i~/name/)
                {
                  col_name=i
                }
              if($i~/description/)
                {
                  col_des=i
                }
            }
        }
      if(FNR>2)
        {
          ab_index[$col_name]=$col_index
          chemid[$col_name]=$col_chemid
          des[$col_name]=$col_des
        }
    }
  if(FILENAME~/filter_child_class/)
    {
      class[$1]=$1
      if(FNR==1)
        {
          printf "index\t"  "chem_id\t"  "name\t"  "description\n" > "results/child_class.tsv"
        }
      printf ab_index[$1]"\t"  chemid[$1]"\t"  $1"\t"  des[$1]"\n" >> "results/child_class.tsv"
    }
  if(FILENAME~/canopus_pp/)
    {
      if(FNR==1)
        {
          printf $1 > "'$savepath'"
          for(i=2; i<=NF; i++)
            {
              if(class[$i]!="")
                {
                  n+=1
                  printf "\tC"ab_index[$i] >> "'$savepath'"
                  col_set[n]=i
                }
            }
          printf "\n" >> "'$savepath'"
        }
      if(FNR>=2)
        {
          printf $1 >> "'$savepath'"
          for(i=1; i<=n; i++)
            {
              printf "\t"$col_set[i] >> "'$savepath'"
            }
          printf "\n" >> "'$savepath'"
        }
    }
}' $data1 $data2 $data3
```

```{r eval = F, echo = T}
#################################
## Eucommia peak erea normalized
# accoding: com_lignans_and_iridoids.tsv 
data=com_lignans_and_iridoids.tsv
awk -F $'\t' '
{
}' $data
```

```{r eval = F, echo = T}
#### ############  instance for 3d plot
### step1 RT ~ intensity
Rscript ~/Downloads/codes/instance_3d_xcms.R
```

```{r eval = F, echo = T}
#################  json tree 
mkdir json_tree
data1="com_lignans_and_iridoids.tsv"
id=2268
formula=C17H24O10
data2="/media/wizard/back/0703_all/*_$id/trees/$formula*.json" ####### in media
cp $data2 json_tree/tree_$id.json
# id	rt	m/z	classification	variety	pro/raw
# 3918	13.2883753333333	701.22926	Terpene glycosides	increase	52.5192 
# 2529	11.5328771666667	699.24926	Lignan glycosides	increase	4.73482
# 3674	7.13257936666667	551.16124	Iridoid O-glycosides	increase	3.91387
# 3380	12.6588768333333	613.21304	Terpene glycosides	increase	3.9104
data="json_tree/tree_$id.json"
savepath="json_tree/"
awk -F "[ ][:][ ]||[,]" '
{
  if($0~/"root"/)
    {
      root=$2
    }
  if($0~/"id"/)
    {
      id[$2]=$2;
      the_id=$2
      getline;
      formula[the_id]=$2
    }
  if($0~/"source"/)
    {
      source[$2]=$2
      link[$2]+=1
      the_source=$2
      getline;
      target[the_source, link[the_source]]=$2
      getline;
      formula_edge[the_source, link[the_source]]=$2
    }
}
END{
printf "id\t" "label\n" > "'$savepath'"  "nodes_'$id'.tsv"
printf "from\t" "to\t" "label\n" > "'$savepath'"  "edges_'$id'.tsv"
```

```{r eval = F, echo = T}
#####
printf "root\t" root"\n" >> "'$savepath'"  "nodes_'$id'.tsv"
for(i in id)
  {
    printf i"\t" formula[i]"\n" >> "'$savepath'"  "nodes_'$id'.tsv"
  }
for(i in source)
  {
    for(j=1; j<=link[i]; j++)
      {
        printf i"\t"  target[i,j]"\t" formula_edge[i,j]"\n" >> "'$savepath'"  "edges_'$id'.tsv"
      }
  }
}' $data
```

```{r eval = F, echo = T}
######################
Rscript ~/Downloads/codes/json_tree.R
```

```{r eval = F, echo = T}
######################
## Image reshape
```

```{r eval = F, echo = T}
######################
metadata="canopus_neg.tsv"
#data="/media/wizard/back/0703_all/490_initial_8_neg_495/canopus/C17H24O10_[M-H]-.fpt"
savepath="canopus_parent_index.tsv"
awk -F $'\t' '
{
  if(FNR==1)
    {
      for(i=1; i<=NF; i++)
        {
          if($i~/^id/)
            {
              col_id=i
            }
          if($i~/^parent/)
            {
              col_parent=i
            }
        }
    }
  if(FNR>=2)
    {
      parent[$col_id]=$col_parent
      rows[FNR]=$col_id
      #print rows[FNR]
    }
}
END{
print "END"
printf "id\t"  "parentid\t"  "num\n" > "'$savepath'"
for(i=2; i<=FNR; i++)
  {
    root=rows[i]
    num[root]+=1
    index_id[rows[i]]=root
    while(root!="")
      {
        if(parent[root]!="")
          {
            index_id[rows[i]]=parent[root]"-"index_id[rows[i]]
            num[parent[root]]+=1
          }
        root=parent[root]
      }
  }
for(i=2; i<=FNR; i++)
  {
    printf rows[i]"\t"  index_id[rows[i]]"\t"  num[rows[i]]"\n" > "'$savepath'"
  }
}' $metadata
```

```{r eval = F, echo = T}
######################
```

```{r eval = F, echo = T}
#### 1028 violin plot
```

```{r eval = F, echo = T}
###################################
data1="results/filter_child_class.tsv"
data2="results/canopus_pp.tsv"
data3="com_compound.tsv"
ex_export="com_1011.tsv"
similarity_limit="0.4"
```

```{r eval = F, echo = T}
###################################
class_pp_limit="0.5"
savename="for_sun_$class_pp_limit.tsv"
awk -F $'\t' '
{
  if(NR==FNR)
    {
      filter_class[$1]=$2
    }
  if(FILENAME~/canopus/)
    {
      if(FNR==1)
        {
          col_id=1
          for(i=2; i<=NF; i++)
            {
              for(j in filter_class)
                {
                  if(j==$i)
                    {
                      col_class[j]=i
                      print i
                    }
                }
            }
        }
      if(FNR>=2)
        {
          for(i in col_class)
            {
              if(sprintf("%.3f",$col_class[i])+0 > "'$class_pp_limit'"+0)
                {
                  class_set[i,$col_id]=i
                  print i,$col_class[i]
                }
            }
        }
    }
  if(FILENAME~/'$data3'/)
    {
      if(FNR==1)
        {
          for(i=1; i<=NF; i++)
            {
              if($i~/^id/)
                {
                  col_id=i
                }
              if($i~/log10_raw/)
                {
                  col_log_raw=i
                }
              if($i~/log10_pro/)
                {
                  col_log_pro=i
                }
              if($i~/similarity/)
                {
                  col_similarity=i
                }
            }
          printf "id\t"  "classification\t"  "log10_raw\t"  "log10_pro\n" > "'$savename'"
          printf $0"\n" > "'$ex_export'"
        }
      if(FNR>=2)
        {
          if($col_similarity+0 > "'$similarity_limit'"+0)
            {
              for(i in class_set)
                {
                  if(i~"\034"$col_id"$")
                    {
                      printf $col_id"\t"  class_set[i]"\t"  $col_log_raw"\t"  $col_log_pro"\n" >> "'$savename'"
                      printf $0"\n" >> "'$ex_export'"
                    }
                }
            }
        }
    }
}' $data1 $data2 $data3
```

```{r eval = F, echo = T}
###################################
```

```{r eval = F, echo = T}
#### stat num
class_pp_limit=0.5
data="for_sun_$class_pp_limit.tsv"
savepath="for_violin_${class_pp_limit}.tsv"
awk -F $'\t' '
{
  if(FNR==1)
    {
      printf $0"\n" > "'$savepath'"
    }
  num[$2]+=1
  data[FNR]=$0
  class[FNR]=$2
}
END{
for(i in num)
  {
    print i,num[i]
    if(num[i]+0>=10)
      {
        for(j in class)
          {
            if(class[j]==i)
              {
                printf data[j]"\n" >> "'$savepath'"
              }
          }
      }
  }
}' $data
```

```{r eval = F, echo = T}
#################
```

```{r eval = F, echo = T}
#################
data1="filter_class.csv" #lignans and iridoids
data2="results/canopus_pp.tsv"
data3="com_compound.tsv"
ex_export="results/com_lignans_and_iridoids.tsv"
similarity_limit="0.4"
class_pp_limit="0.5"
awk -F $'\t' '
{
  if(NR==FNR)
    {
      filter_class[$1]=$1
    }
  if(FILENAME~/canopus/)
    {
      if(FNR==1)
        {
          col_id=1
          for(i=2; i<=NF; i++)
            {
              for(j in filter_class)
                {
                  if(j==$i)
                    {
                      col_class[j]=i
                      print i
                    }
                }
            }
        }
      if(FNR>=2)
        {
          for(i in col_class)
            {
              if(sprintf("%.3f",$col_class[i])+0>="'$class_pp_limit'"+0)
                {
                  class_set[i,$col_id]=i
                  print i,$col_class[i]
                }
            }
        }
    }
  if(FILENAME~/'$data3'/)
    {
      if(FNR==1)
        {
          for(i=1; i<=NF; i++)
            {
              if($i~/^id/)
                {
                  col_id=i
                }
              if($i~/log10_raw/)
                {
                  col_log_raw=i
                }
              if($i~/log10_pro/)
                {
                  col_log_pro=i
                }
              if($i~/similarity/)
                {
                  col_similarity=i
                }
            }
          printf $0"\n" > "'$ex_export'"
        }
      if(FNR>=2)
        {
          if($col_similarity+0 >= "'$similarity_limit'")
            {
              for(i in class_set)
                {
                  if(i~"\034"$col_id"$")
                    {
                      printf $0"\n" >> "'$ex_export'"
                    }
                }
            }
        }
    }
}' $data1 $data2 $data3

```

# File: for_com_lignans_and_iridoids.sh

```{r eval = F, echo = T}
list=$(awk '{print NR}' filter_class.csv)
for i in $list 
do
  data1=$(awk '{if(NR=='$i'){printf $0}}' filter_class.csv) #lignans and iridoids
  data2="results/canopus_pp.tsv"
  data3="com_compound.tsv"
  ex_export="results/com_${i}.tsv"
  similarity_limit="0.4"
  class_pp_limit="0.5"
  awk -F $'\t' '
  {
    if(NR==FNR)
      {
        filter_class[$1]=$1
        index_class=$1
      }
    if(FILENAME~/canopus/)
      {
        if(FNR==1)
          {
            col_id=1
            for(i=2; i<=NF; i++)
              {
                for(j in filter_class)
                  {
                    if(j==$i)
                      {
                        col_class[j]=i
                        print i
                      }
                  }
              }
          }
        if(FNR>=2)
          {
            for(i in col_class)
              {
                if(sprintf("%.3f",$col_class[i])+0>="'$class_pp_limit'"+0)
                  {
                    class_set[i,$col_id]=i
                    print i,$col_class[i]
                  }
              }
          }
      }
    if(FILENAME~/'$data3'/)
      {
        if(FNR==1)
          {
            for(i=1; i<=NF; i++)
              {
                if($i~/^id/)
                  {
                    col_id=i
                  }
                if($i~/log10_raw/)
                  {
                    col_log_raw=i
                  }
                if($i~/log10_pro/)
                  {
                    col_log_pro=i
                  }
                if($i~/similarity/)
                  {
                    col_similarity=i
                  }
              }
            printf "Index\t"$0"\n" > "'$ex_export'"
          }
        if(FNR>=2)
          {
            if($col_similarity+0 >= "'$similarity_limit'")
              {
                for(i in class_set)
                  {
                    if(i~"\034"$col_id"$")
                      {
                        printf index_class"\t"$0"\n" >> "'$ex_export'"
                      }
                  }
              }
          }
      }
  }' <(echo "$data1") $data2 $data3
done;
```

# File: for_gnps_facet.sh

```{r eval = F, echo = T}
plimit=0
until [[ "$plimit" > "0.5" ]] && [[ "$plimit" < "0.99" ]]
do
  read -p "If the minimum alignment similarity is greater than 0.3, this step will automatic calculate the discrepancy fingerprint between alignment features(in beta). Please enter the minimum posterior probability of the molecular fingerprint(plimit_1) to be filtered. 0.9-0.99 is recommended. >>> " plimit;
done;
plimit2=0
until [[ "$plimit2" > "0.1" ]] && [[ "$plimit2" < "$plimit" ]]
do
  read -p "The minimum posterior probability of the molecular fingerprint(plimit_2) to be controled. 0.1-0.5 may work well. >>> " plimit2;
done;
tlimit=$(ls temp/ftaligntemp/filter_net_* | awk -F _ '{print $NF}')
check_rep=$(awk 'END{print NR}' <(echo "$tlimit"))
if [[ "$check_rep" > "1" ]]
then
  tlimit=0
  until [ -f temp/ftaligntemp/filter_net_$tlimit ]
  do
    read -p "Plural and different fragment_tree_network files were found to exist locally. Please select a tlimit parameter you have utilized to run fragment_tree_network_delta. >>> " tlimit;
  done;
fi;
if [ -f temp/ftaligntemp/refilter_net_$tlimit ]
then rm temp/ftaligntemp/refilter_net_$tlimit
fi;
if [ -f temp/ftaligntemp/fpsample ]
then rm temp/ftaligntemp/fpsample
fi;
echo "Running delta_fingerprint computation..."
echo "Aquiring data from sirius index..."
data1="*_*/compound.info"
data2="temp/ftaligntemp/filter_net_$tlimit"
echo "Run fragment_tree_network_delta."
savepath="temp/ms_data_$tlimit"
echo "step 1: ms data"
if ! [ -f $savepath ]
then
  awk -F "[\t]||[:]||[_]" -v OFS=$'\t' '
  BEGIN{  
  printf "..."
  printf "id\t"  "m/z\t"  "rt\n" > "results/mz_and_rt.tsv"
}
{
  if(FILENAME~/compound.info/)
    {
      if(FNR==1)
        {
          printf "Info: catch >>> "FILENAME"\n"
        }
      if($1=="name")
        {
          i+=1;
          id[i]=$NF;
          n=split($NF,a,"[_]")
          printf a[n]"\t" >> "results/mz_and_rt.tsv"
        }
      if($1=="ionMass")
        {
          mz[id[i]]=$NF
          printf sprintf("%.4f",$NF)"\t" >> "results/mz_and_rt.tsv"
        }
      if($1=="ionType")
        {
          type[id[i]]=$NF
        }
      if($1=="rt")
        {
          rt[id[i]]=$2;
          printf sprintf("%.2f",$2/60)"\n" >> "results/mz_and_rt.tsv"
        }
    }
  if(FILENAME~/ftaligntemp/)
    {
      #source  target  ftalign  delta_mz  delta_rt  source_iontype  target_iontype;
      if(FNR==1)
        {
          printf "" > "'$savepath'"
        }
      print $1,$2,$3,sprintf("%.3f",mz[$2]-mz[$1]),sprintf("%.2f",rt[$2]-rt[$1]),type[$1],type[$2]  >> "'$savepath'"
    }
}' $data1 $data2
fi;
```

```{r eval = F, echo = T}
########################
echo "step 2: data path"
source_file="temp/Mo_filename"
data="temp/ms_data_$tlimit"
savepath="temp/datapath_$tlimit"
if ! [ -f $savepath ]
then
  awk -F $'\t' -v OFS=$'\t' '
  {
    if(NR==FNR)
      {
        n=split($2, a, "[_]")
        file[a[n]]=$2
        formu_type[a[n]]=$3
      }
    if(NR!=FNR)
      {
        #<path>sourceFormula  <path>targetFormula
        path1=file[$1]"/fingerprints/"formu_type[$1]".fpt"
        path2=file[$2]"/fingerprints/"formu_type[$2]".fpt"
        data[path1]=path1
        data[path2]=path2
      }
  }
END{
for(i in data)
  {
    n+=1
    print "Check file:",n
    if(getline<i==-1)
      {
        printf "Escape filename: " i "\n"
      }
  else
    {
      printf i" " > "'$savepath'"
    }
  close(i)
}
print "Sum:",n
}' $source_file $data
fi;
datapath=$(cat temp/datapath_$tlimit)
echo "step 3: fingerprint"
data_allfp="temp/data_allfp_$tlimit"
if ! [ -f $data_allfp ]
then
  awk -F $'\t' '
  BEGIN{
  n=0
}
{
  if(FNR==1)
    {
      if(n>1)
        {
          close(file)
        }
      file=FILENAME;
      print "Get fingerprints: ",FILENAME
      n+=1;
      printf FILENAME"\n"$0"\n" > "'$data_allfp'"
    }
else
  {
    print $0 > "'$data_allfp'"
  }
}' $datapath
fi;
```

```{r eval = F, echo = T}
###########################
awk -F $'\t' -v OFS=$'\t' '
{
  if(NR==1)
    {
      for(i=1; i<=NF; i++)
        {
          if($i~/absolute/)
            {
              col_index=i
            }
          if($i~/description/)
            {
              col_description=i
            }
        }
    }
  if(NR>=2)
    {
      print $col_index,$col_description
    }
}' csi_fingerid.tsv > temp/ftaligntemp/pos_fingerprint_index;
awk -F $'\t' -v OFS=$'\t' '
{
  if(NR==1)
    {
      for(i=1; i<=NF; i++)
        {
          if($i~/absolute/)
            {
              col_index=i
            }
          if($i~/description/)
            {
              col_description=i
            }
        }
    }
  if(NR>=2)
    {
      print $col_index,$col_description
    }
}' csi_fingerid_neg.tsv > temp/ftaligntemp/neg_fingerprint_index;
posindex="temp/ftaligntemp/pos_fingerprint_index"
negindex="temp/ftaligntemp/neg_fingerprint_index"
data="temp/ms_data_$tlimit"
echo "step 4: merge data"
awk -F $'\t' '
BEGIN{
file=0
x=0
count=0
f=0
posnum=0
negnum=0
}
{
  if(FNR==1)
    {
      file+=1
    }
  if(NR==FNR)
    {
      if(($1~/fingerprint/))
        {
          if(x+0>f+0)
            {
              f=x  # calculate the max index.
            }
          count+=1;  # calculate the all fingerprints file number.
          split($1,a,"[/]"); e=split(a[1],b,"[_]"); id=b[e]; #catch the id.
          x=0;
        }
    else
      {
        x+=1;
        fp[id,x]=$1;
      }
  }
if(file==2)
  {
    pos[FNR]=$1
    posnum+=1
  }
if(file==3)
  {
    neg[FNR]=$1
    negnum+=1
  }
if(file==4)
  {
    if("'$tlimit'"+0 >= 0.3)
      {
        if(fp[$1,1]!="" && fp[$2,1]!="")
          {
            n1=split($6, g, "[]]");
            n2=split($7, h, "[]]");
            if(g[n1]=="+" && h[n2]=="+")
              {
                for(x=1; x<=posnum; x++)
                  {
                    if(fp[$1,x]+0>='$plimit'+0 && fp[$2,x]+0<='$plimit2'+0)
                      {
                        data_s[FNR,x]=pos[x]
                      }
                  else if(fp[$2,x]+0>='$plimit'+0 && fp[$1,x]+0<='$plimit2'+0)
                    {
                      data_t[FNR,x]=pos[x]
                    }
                }
            }
          if(g[n1]=="-" && h[n2]=="-")
            {
              for(x=1; x<=negnum; x++)
                {
                  if(fp[$1,x]+0>='$plimit'+0 && fp[$2,x]+0<='$plimit2'+0)
                    {
                      data_s[FNR,x]=neg[x]
                    }
                else if(fp[$2,x]+0>='$plimit'+0 && fp[$1,x]+0<='$plimit2'+0)
                  {
                    data_t[FNR,x]=neg[x]
                  }
              }
          }
        if(g[n1]=="-" && h[n2]=="+" || h[n2]=="-" && g[n1]=="+")
          {
            for(i=1; i<=posnum; i++)
              {
                for(j=1; j<=negnum; j++)
                  {
                    if(pos[i]==neg[j])
                      {
                        mirror[i]=j  #if pos=i, the identical index of neg is mirror[i]
                      }
                  }
              }
          }
        if(g[n1]=="-" && h[n2]=="+") 
          {
            for(x=1; x<=f; x++)
              {
                if(fp[$1,mirror[x]]+0>='$plimit'+0 && fp[$2,x]+0<='$plimit2'+0)
                  {
                    data_s[FNR,x]=neg[mirror[x]]
                  }
              else if(fp[$2,x]+0>='$plimit'+0 && fp[$1,mirror[x]]+0<='$plimit2'+0)
                {
                  data_t[FNR,x]=neg[mirror[x]]
                }
            }
        }
      if(h[n2]=="-" && g[n1]=="+")
        {
          for(x=1; x<=f; x++)
            {
              if(fp[$1,x]+0>= '$plimit'+0 && fp[$2,mirror[x]]+0<='$plimit2'+0)
                {
                  data_s[FNR,x]=neg[mirror[x]]
                }
            else if(fp[$2,mirror[x]]+0>='$plimit'+0 && fp[$1,x]+0<='$plimit2'+0)
              {
                data_t[FNR,x]=neg[mirror[x]]
              }
          }   
      }
  }
}
if(FNR==1)
  {
    printf "source\t"  "target\t"  "ftalign_similarity\t"  "delta_m/z\t"  "source_fp_uniq\t"  "target_fp_uniq\n"
  }
else
  {
    printf $1"\t"  $2"\t"  $3"\t"  $4"\t";
    if('$tlimit'+0 >= 0.3)
      {
        if(fp[$1,1]=="" || fp[$2,1]=="")
          {
            printf "NA@NA\n"
          }
      else
        {
          printf "source:"  #the source fingerprint uniq.
          for(x=1; x<=f; x++)
            {
              if(data_s[FNR,x]!="")
                {
                  printf data_s[FNR,x]","
                }
            };
          printf "@target:"  #the target fingerprint uniq.
          for(x=1; x<=f; x++)
            {
              if(data_t[FNR,x]!="")
                {
                  printf data_t[FNR,x]","
                }
            }
          printf "\n"
        }
    }
else
  {
    printf "NA@NA\n"
  }
}
}
}' $data_allfp $posindex $negindex $data | sed -e 's/,@/\t/g; s/,$//g; s/@/\t/g'  > results/source_target_tree_$tlimit.tsv;
echo "All instances have written into <results/source_target_tree_$tlimit.tsv>."
```

```{r eval = F, echo = T}
#####################################
echo "step 5: separate child-nebula from parent-nebula."
data="results/stat_classification.tsv"
savepath="temp/filter_0_class.tsv"
awk -F $'\t' '
{
  if(FNR==1)
    {
      for(i=1; i<=NF; i++)
        {
          if($i~/^definition$/)
            {
              col_class=i
            }
        }
    }
  if(FNR>=2)
    {
      class[$col_class]=$col_class
    }
}
END{
for(i in class)
  {
    printf class[i]"\n" > "'$savepath'"
  }
}' $data
```

```{r eval = F, echo = T}
######################################
data1="temp/filter_0_class.tsv" 
data2="results/canopus_pp.tsv"
data3="results/fingerid_first_score.tsv"
until [[ "$similarity_limit" > 0 ]] && [[ "$similarity_limit" < 1 ]]
do
  read -p "Please set the Tanimoto similarity threshold contribute to child-nebula. >>> " similarity_limit;
done;
until [[ "$definition_limit" > 0.01 ]] && [[ "$definition_limit" < 1 ]]
do
  read -p "Please enter the classes posterior probabilities limition. 0.5~0.99 may work well. >>> " definition_limit;
done;
class_pp_limit=$definition_limit
savepath="temp/idenfication_filter_$class_pp_limit.tsv"
awk -F $'\t' '
{
  if(NR==FNR)
    {
      filter_class[$1]=$1
    }
  if(FILENAME~/canopus/)
    {
      if(FNR==1)
        {
          col_id=1
          for(i=2; i<=NF; i++)
            {
              for(j in filter_class)
                {
                  if(j==$i)
                    {
                      col_class[j]=i
                      print i
                    }
                }
            }
        }
      if(FNR>=2)
        {
          for(i in col_class)
            {
              if(sprintf("%.3f",$col_class[i])+0>="'$class_pp_limit'"+0)
                {
                  class_set[i,$col_id]=i
                  print "ID: ",$1,i,$col_class[i]
                }
            }
        }
    }
  if(FILENAME~/fingerid_first_score/)
    {
      if(FNR==1)
        {
          for(i=1; i<=NF; i++)
            {
              if($i~/^id/)
                {
                  col_id=i
                }
              if($i~/similarity/)
                {
                  col_similarity=i
                }
            }
          printf "class_nebula_facet\t"  $0"\n" > "'$savepath'"
        }
      if(FNR>=2)
        {
          if($col_similarity+0 >= "'$similarity_limit'"+0)
            {
              for(i in class_set)
                {
                  if(i~"\034"$col_id"$")
                    {
                      printf class_set[i]"\t"  $0"\n" > "'$savepath'"
                    }
                }
            }
        }
    }
}' $data1 $data2 $data3
```

```{r eval = F, echo = T}
###################################
data="temp/idenfication_filter_$class_pp_limit.tsv"
savepath="temp/idenfication_filter2_${class_pp_limit}.tsv"
until [[ "$num_limit_1" -gt 0 ]]
do
  read -p "Please enter the features number threshold contribute to child-nebula (min number). >>> " num_limit_1;
done;
until [[ "$num_limit_2" -gt "$num_limit_1" ]]
do
  read -p "Please enter the features number threshold contribute to child-nebula (max number). >>> " num_limit_2;
done;
awk -F $'\t' '
{
  if(FNR==1)
    {
      printf $0"\n" > "'$savepath'"
      for(i=1; i<=NF; i++)
        {
          if($i~/class_nebula_facet/)
            {
              col_class=i
            }
        }
    }
  if(FNR>=2)
    {
      num[$col_class]+=1
      data[FNR]=$0
      class[FNR]=$col_class
    }
}
END{
for(i in num)
  {
    if(num[i]+0 >= '$num_limit_1'+0 && num[i]+0 <= '$num_limit_2')
      {
        printf "The nodes number of the child-nebula is " num[i] ".\n"
        for(j in class)
          {
            if(class[j]==i)
              {
                printf data[j]"\n" >> "'$savepath'"
              }
          }
      }
  }
}' $data
```

```{r eval = F, echo = T}
##################################
mkdir results/network_facet_$class_pp_limit
data1="temp/idenfication_filter2_${class_pp_limit}.tsv"
data2="results/source_target_tree_$tlimit.tsv" # "results/source_target_tree_0.4.tsv"
save_class="results/filter_child_class.tsv"
savepath="results/network_facet_$class_pp_limit/"
awk -F $'\t' '
{
  if(NR==FNR)
    {
      if(FNR==1)
        {
          for(i=1; i<=NF; i++)
            {
              if($i~/class_nebula_facet/)
                {
                  col_class=i
                }
              if($i~/^id$/)
                {
                  col_id=i
                }
            }
        }
      if(FNR>=2)
        {
          class[$col_class]=$col_class
          class_id[$col_class,$col_id]=$col_id
          stat_id[$col_class,$col_id]=$col_id
          belong[$col_class,$col_id]=$col_class
        }
    }
  if(NR>FNR)
    {
      if(FNR==1)
        {
          for(i in class)
            {
              printf i"\n" > "'$save_class'"
              printf $0"\t"  "facet\n" > "'$savepath'" i ".tsv"
            }
        }
      if(FNR>=2)
        {
          for(i in class)
            {
              if( class_id[i,$1]==$1 && class_id[i,$2]==$2 )
                {
                  printf $0"\t"  i"\n" >> "'$savepath'" i ".tsv"
                  delete stat_id[i,$1]
                  delete stat_id[i,$2]
                }
            }
        }
    }
}
END{
for(i in stat_id)
  {
    ## source target similarity delta_mz fp fp class
    printf stat_id[i]"\t" stat_id[i]"\t"  "1\t"  "0\t"  "null\t"  "null\t"  belong[i]"\n"  >> "'$savepath'" belong[i] ".tsv"
  }
}' $data1 $data2
```

```{r eval = F, echo = T}
#####################
data1="canopus.tsv"
data2="results/filter_child_class.tsv"
data3="results/canopus_pp.tsv"
savepath="results/canopus_pp_filter.tsv"
awk -F $'\t' '
{
  if(FILENAME~/canopus.tsv/)
    {
      if(FNR==1)
        {
          for(i=1; i<=NF; i++)
            {
              if($i~/absolute/)
                {
                  col_index=i
                }
              if($i~/^id/)
                {
                  col_chemid=i
                }
              if($i~/name/)
                {
                  col_name=i
                }
              if($i~/description/)
                {
                  col_des=i
                }
            }
        }
      if(FNR>2)
        {
          ab_index[$col_name]=$col_index
          chemid[$col_name]=$col_chemid
          des[$col_name]=$col_des
        }
    }
  if(FILENAME~/filter_child_class/)
    {
      class[$1]=$1
      if(FNR==1)
        {
          printf "index\t"  "chem_id\t"  "name\t"  "description\n" > "results/child_class.tsv"
        }
      printf ab_index[$1]"\t"  chemid[$1]"\t"  $1"\t"  des[$1]"\n" >> "results/child_class.tsv"
    }
  if(FILENAME~/canopus_pp/)
    {
      if(FNR==1)
        {
          printf $1 > "'$savepath'"
          for(i=2; i<=NF; i++)
            {
              if(class[$i]!="")
                {
                  n+=1
                  printf "\tC"ab_index[$i] >> "'$savepath'"
                  col_set[n]=i
                }
            }
          printf "\n" >> "'$savepath'"
        }
      if(FNR>=2)
        {
          printf $1 >> "'$savepath'"
          for(i=1; i<=n; i++)
            {
              printf "\t"$col_set[i] >> "'$savepath'"
            }
          printf "\n" >> "'$savepath'"
        }
    }
}' $data1 $data2 $data3
mv results/network_facet_$class_pp_limit results/gnps_network_facet_$class_pp_limit
```

# File: for_violin.sh

```{r eval = F, echo = T}
data1="results/filter_child_class.tsv"
data2="results/canopus_pp.tsv"
data3="com_compound.tsv"
ex_export="com_1011.tsv"
similarity_limit="0.4"
```

```{r eval = F, echo = T}
###################################
class_pp_limit="0.5"
savename="for_sun_$class_pp_limit.tsv"
awk -F $'\t' '
{
  if(NR==FNR)
    {
      filter_class[$1]=$2
    }
  if(FILENAME~/canopus/)
    {
      if(FNR==1)
        {
          col_id=1
          for(i=2; i<=NF; i++)
            {
              for(j in filter_class)
                {
                  if(j==$i)
                    {
                      col_class[j]=i
                      print i
                    }
                }
            }
        }
      if(FNR>=2)
        {
          for(i in col_class)
            {
              if(sprintf("%.3f",$col_class[i])+0 > "'$class_pp_limit'"+0)
                {
                  class_set[i,$col_id]=i
                  print i,$col_class[i]
                }
            }
        }
    }
  if(FILENAME~/'$data3'/)
    {
      if(FNR==1)
        {
          for(i=1; i<=NF; i++)
            {
              if($i~/^id/)
                {
                  col_id=i
                }
              if($i~/log10_raw/)
                {
                  col_log_raw=i
                }
              if($i~/log10_pro/)
                {
                  col_log_pro=i
                }
              if($i~/similarity/)
                {
                  col_similarity=i
                }
            }
          printf "id\t"  "classification\t"  "log10_raw\t"  "log10_pro\n" > "'$savename'"
          printf $0"\n" > "'$ex_export'"
        }
      if(FNR>=2)
        {
          if($col_similarity+0 > "'$similarity_limit'"+0)
            {
              for(i in class_set)
                {
                  if(i~"\034"$col_id"$")
                    {
                      printf $col_id"\t"  class_set[i]"\t"  $col_log_raw"\t"  $col_log_pro"\n" >> "'$savename'"
                      printf $0"\n" >> "'$ex_export'"
                    }
                }
            }
        }
    }
}' $data1 $data2 $data3
```

```{r eval = F, echo = T}
###################################
```

```{r eval = F, echo = T}
#### stat num
class_pp_limit=0.5
data="for_sun_$class_pp_limit.tsv"
savepath="for_violin_${class_pp_limit}.tsv"
awk -F $'\t' '
{
  if(FNR==1)
    {
      printf $0"\n" > "'$savepath'"
    }
  num[$2]+=1
  data[FNR]=$0
  class[FNR]=$2
}
END{
for(i in num)
  {
    print i,num[i]
    if(num[i]+0>=10)
      {
        for(j in class)
          {
            if(class[j]==i)
              {
                printf data[j]"\n" >> "'$savepath'"
              }
          }
      }
  }
}' $data
```

# File: ftp_delete.sh

```{r eval = F, echo = T}
#!/bin/bash
path=$1
PUTFILE=$2
ftp -ivn <<EOF
passive
open ccms-ftp01.ucsd.edu 21
user Yellow xxk123456
binary
cd $path
prompt
delete $PUTFILE
by
EOF
echo "up file end . . ."

```

# File: ftp_upload_target_dir.sh

```{r eval = F, echo = T}
#!/bin/bash
path=$1
PUTFILE=$2
target=$3
ftp -ivn <<EOF
passive
open ccms-ftp01.ucsd.edu 21
user Yellow xxk123456
binary
cd $target
lcd $path
prompt
put $PUTFILE
by
EOF
echo "up file end . . ."

```

# File: ftp_upload.sh

```{r eval = F, echo = T}
#!/bin/bash
path=$1
PUTFILE=$2
ftp -ivn <<EOF
passive
open ccms-ftp01.ucsd.edu 21
user Yellow xxk123456
binary
cd .
lcd $path
prompt
put $PUTFILE
by
EOF
echo "up file end . . ."

```

# File: git.sh

```{r eval = F, echo = T}
## Wed Mar  2 10:57:48 AM CST 2022
# git config --global user.name "chi-med-pro"
# git config --global user.email "202011114011074@zcmu.edu.cn"
## ssh-keygen -t rsa -C "202011114011074@zcmu.edu.cn"
## ssh-add ~/.ssh/id_rsa_r
git remote add origin git@github.com:chi-med-pro/MCnebula.git
git add .
git commit -m "initial submit"
git pull origin master
# git add/rm .gitignore
# git rebase --continue
git push -u origin master

```

# File: install_name_iupuc.sh

```{r eval = F, echo = T}
# download the smi_to_iupac model
URL="https://bwsyncandshare.kit.edu/s/bRWQ4Y8bZmWnBEt/download"
GZ="./chem_iupac/download"

if [ -d "./chem_iupac/download" ]; then
    echo "Dataset has already been downloaded."
else
    wget "$URL" -P "./chem_iupac/"

    if [ -f $GZ ]; then
        echo "Dataset successfully downloaded."
    else
        echo "Dataset not successfully downloaded."
        exit
    fi
    tar zxvf $GZ -C ./chem_iupac/
fi


# download opsin
URL="https://github.com/dan2097/opsin/releases/download/2.4.0/opsin-2.4.0-jar-with-dependencies.jar"
GZ="./chem_iupac/opsin/opsin-2.4.0-jar-with-dependencies.jar"

if [ -d "./chem_iupac/opsin/opsin-2.4.0-jar-with-dependencies.jar" ]; then
    echo "Opsin has already been downloaded."
else
    wget "$URL" -P "./chem_iupac/opsin/"

    if [ -f $GZ ]; then
        echo "Opsin successfully downloaded."
    else
        echo "Opsin not successfully downloaded."
        exit
    fi
fi
```

# File: kegg_catch_smiles.sh

```{r eval = F, echo = T}
# location="~/operation/re_fecal_neg/kegg"”
cd ~/operation/re_fecal_neg/kegg
savepath="cnumber_cid.tsv"
awk -F "[:][ ]" '
{
  if(FNR==1)
    {
      printf "kegg number\t" "pubchem id" > "'$savepath'"
    }
  if($0~/BEGIN_COMPOUND/)
    {
      getline
      if($0~/C[0-9]*/)
        {
          cnum=$0
          next_sub=1
          print "Catch C number: ", $0
          printf "\n"cnum > "'$savepath'"
        }
    else
      {
        next_sub=0
        print "Invalid sublist."
      }
    }
  if($1~/PubChem/ && next_sub==1)
    {
      printf "\t"$2 > "'$savepath'"
    }
}' dblink.list 
## filter the blank and output the list
data="cnumber_cid.tsv"
nlimit=100
list=$(awk -F $'\t' '
{
  if($1~/C[0-9]*/)
    {
      if($2=="")
        {
          print "Escape CID of",$1
        }
      if($2!="")
        {
          gsub(/ /,"",$2)
          if(n>'$nlimit')
            {
              n=0
              print cid_set
            }
          n+=1
          if(n==1)
            {
              cid_set=$2
            }
        else
          {
            cid_set=cid_set","$2
          }
      }
  }
}
END{
print cid_set
}' $data)
## nrow
nrow=$(awk 'END{print NR}' <(echo "$list"))
##
for i in $(seq $nrow)
do
  cids=$(awk '{if(NR=='$i'){print $0}}' <(echo "$list"))
  check=$(echo "$cids" | awk '{if($0~/^[0-9]/){printf 0}else{printf 1}}')
  while [ $check == 0 ]
  do
    echo "Try catch pubchem API (${i}/${nrow})..."
    if [ -f ${i}_smiles.csv ]
    then
      check=$(awk '
      {
        if(FNR==1)
          {
            if($0~/CID/)
              {
                printf "1"
              }
          else
            {
              printf "0"
            }
        }
    }
  END{
  if(FNR==0)
    {
      printf "0"
    }
}' ${i}_smiles.csv)
    fi;
if [ $check == 0 ]
then
  curl --connect-timeout 20 --retry 100 --retry-delay 30 https://pubchem.ncbi.nlm.nih.gov/rest/pug/compound/cid/${cids}/property/CanonicalSMILES,IsomericSMILES/CSV > ${i}_smiles.csv
fi;
done;
done;
## merge and reformat
awk -F "[,]" '
{
  if(NR==1)
    {
      printf $1
      for(i=2; i<=NF; i++)
        {
          printf "\t"$i
        }
      printf "\n"
    }
  if(FNR>=2)
    {
      printf $1
      for(i=2; i<=NF; i++)
        {
          printf "\t"$i
        }
      printf "\n"
    }
}' *_smiles.csv | sed 's/\"//g' | awk '{if($2!=""){print $0}}' > merge_smiles.tsv
## as sirius db
Rscript ~/Downloads/codes/sirius_db.R

```

# File: ladder.sh

```{r eval = F, echo = T}

 similarity_limit=0.4
 num_limit_1=30
 num_limit_2=500
 tlimit=0.4
 for i in 0.4 0.5 0.6 0.7 0.8 0.9 0.95 0.99
 do
 definition_limit=$i
 data1="temp/filter_0_class.tsv" 
 data2="results/canopus_pp.tsv"
 data3="results/fingerid_first_score.tsv"
 class_pp_limit=$definition_limit
 savepath="temp/idenfication_filter_$class_pp_limit.tsv"
 awk -F $'\t' '
   {
   if(NR==FNR)
     {
     filter_class[$1]=$1
     }
   if(FILENAME~/canopus/)
     {
     if(FNR==1)
       {
       col_id=1
       for(i=2; i<=NF; i++)
         {
         for(j in filter_class)
           {
           if(j==$i)
             {
             col_class[j]=i
             print i
             }
           }
         }
       }
     if(FNR>=2)
       {
       for(i in col_class)
         {
         if(sprintf("%.3f",$col_class[i])+0>="'$class_pp_limit'"+0)
           {
           class_set[i,$col_id]=i
           print "ID: ",$1,i,$col_class[i]
           }
         }
       }
     }
   if(FILENAME~/fingerid_first_score/)
     {
     if(FNR==1)
       {
       for(i=1; i<=NF; i++)
         {
         if($i~/^id/)
         {
         col_id=i
         }
       if($i~/similarity/)
         {
         col_similarity=i
         }
         }
       printf "class_nebula_facet\t"  $0"\n" > "'$savepath'"
       }
     if(FNR>=2)
       {
       if($col_similarity+0 >= "'$similarity_limit'"+0)
         {
        for(i in class_set)
          {
          if(i~"\034"$col_id"$")
            {
            printf class_set[i]"\t"  $0"\n" > "'$savepath'"
            }
          }
        }
       }
     }
   }' $data1 $data2 $data3
```

```{r eval = F, echo = T}
###################################
 data="temp/idenfication_filter_$class_pp_limit.tsv"
 savepath="temp/idenfication_filter2_${class_pp_limit}.tsv"
 awk -F $'\t' '
   {
   if(FNR==1)
     {
     printf $0"\n" > "'$savepath'"
     for(i=1; i<=NF; i++)
       {
       if($i~/class_nebula_facet/)
         {
         col_class=i
         }
       }
     }
 if(FNR>=2)
   {
   num[$col_class]+=1
   data[FNR]=$0
     class[FNR]=$col_class
   }
  }
   END{
     for(i in num)
       {
       if(num[i]+0 >= '$num_limit_1'+0 && num[i]+0 <= '$num_limit_2')
         {
         printf "The nodes number of the child-nebula is " num[i] ".\n"
         for(j in class)
           {
           if(class[j]==i)
             {
             printf data[j]"\n" >> "'$savepath'"
             }
           }
         }
       }
     }' $data
 ##################################
 mkdir results/network_facet_$class_pp_limit
 data1="temp/idenfication_filter2_${class_pp_limit}.tsv"
 data2="results/source_target_tree_$tlimit.tsv" # "results/source_target_tree_0.4.tsv"
 save_class="results/filter_child_class.tsv"
 savepath="results/network_facet_$class_pp_limit/"
 awk -F $'\t' '
   {
   if(NR==FNR)
     {
     if(FNR==1)
       {
       for(i=1; i<=NF; i++)
         {
         if($i~/class_nebula_facet/)
           {
           col_class=i
           }
         if($i~/^id$/)
           {
           col_id=i
           }
         }
       }
     if(FNR>=2)
       {
       class[$col_class]=$col_class
       class_id[$col_class,$col_id]=$col_id
       stat_id[$col_class,$col_id]=$col_id
       belong[$col_class,$col_id]=$col_class
       }
     }
   if(NR>FNR)
     {
     if(FNR==1)
       {
       for(i in class)
         {
         printf i"\n" > "'$save_class'"
         printf $0"\t"  "facet\n" > "'$savepath'" i ".tsv"
         }
       }
     if(FNR>=2)
       {
       for(i in class)
         {
         if( class_id[i,$1]==$1 && class_id[i,$2]==$2 )
           {
           printf $0"\t"  i"\n" >> "'$savepath'" i ".tsv"
           delete stat_id[i,$1]
           delete stat_id[i,$2]
           }
         }
       }
     }
   }
   END{
     for(i in stat_id)
       {
       ## source target similarity delta_mz fp fp class
       printf stat_id[i]"\t" stat_id[i]"\t"  "1\t"  "0\t"  "null\t"  "null\t"  belong[i]"\n" \
       \
       >> "'$savepath'" belong[i] ".tsv"
       }
     }' $data1 $data2
 done;
```

# File: marvin.sh

```{r eval = F, echo = T}
### marvin
## location ~/operation/back/0703_all
data="results/fingerid_first_score.tsv"
savepath="results/structure_2d/smiles_draw"
awk -F $'\t' '
{
  if(FNR==1)
    {
      for(i=1; i<=NF; i++)
        {
          if($i~/^id/)
            {
              col_id=i
            }
          if($i~/smiles/)
            {
              col_smiles=i
            }
        }
    }
  if(FNR>=2)
    {
      system("molconvert mol \""  $col_smiles  "\" -o '$savepath'/"  $col_id  ".mol")
      close("molconvert mol \""  $col_smiles  "\" -o '$savepath'/"  $col_id  ".mol")
      printf "Info: the ID is "$col_id". Row number:"FNR".\n"
    }
}' $data
```

```{r eval = F, echo = T}
####################################
### use obabel to convert mol format
ls results/structure_2d/smiles_draw/[0-9]*.mol | awk -F $'\t' '
{
  split($0, a, "[.][m][o][l]")
  system("obabel "  $0  " -imol -osvg -O "  a[1]  ".mol.svg")
  close("obabel "  $0  " -imol -osvg -O "  a[1]  ".mol.svg")
  print a[1]".svg"
}'
```

```{r eval = F, echo = T}
###################################
sed -i -e 's/white/transparent/g; s/stroke-width="2.0"/stroke-width="4.0"/g;' results/structure_2d/smiles_draw/[0-9]*.mol.svg
```

```{r eval = F, echo = T}
###################################
ls results/structure_2d/smiles_draw/[0-9]*.mol.svg | awk '
{
  if($0~/cairo/)
    {
      next
    }
else
  {
    system("cairosvg "  $0  " -o "  $0 ".cairo.svg")
    close("cairosvg "  $0  " -o "  $0 ".cairo.svg")
    printf "Info: the filename is "$0"\n"
  }
}'
```

```{r eval = F, echo = T}
##################################
```

```{r eval = F, echo = T}
##################################              candidate structure
#mkdir results/structure_2d/candidate
data="results/structure_2d/candidate/*_class.tsv"
id_set=$(awk -F $'\t' '
{
  if(FNR==1)
    {
      for(i=1; i<=NF; i++)
        {
          if($i~/"group_sub"/ || $i~/^group_sub$/)
            {
              col_group_sub=i
              #print i,NF
            }
          if($i~/"group"/ || $i~/^group$/)
            {
              col_group=i
            }
        }
    }
  if(FNR>=2)
    {
      id[$col_group_sub]=$col_group_sub
      id[$col_group]=$col_group
    }
}
END{
for(i in id)
  {
    n+=1
    if(n==1)
      {
        printf i
      }
  else
    {
      printf "_"i
    }
}
}' $data)
```

```{r eval = F, echo = T}
##################################
path="/media/wizard/back/0703_all"
awk '
BEGIN{
path="'$path'"
file_set="'$id_set'"
n=split(file_set, a, "[_]")
for(i=1; i<=n; i++)
  {
    "ls -d "  path  "/*_" a[i] | getline
    close("ls -d "  path  "/*_" a[i] | getline)
    name=name""$0"/structure_candidates.tsv "
  }
printf name > "tmp"
}'
```

```{r eval = F, echo = T}
#################################
savepath="results/structure_2d/candidate"
can_num=30
awk -F $'\t' '
{
  if(FNR==1)
    {
      n=split(FILENAME, a, "[/]")
      for(i=1; i<=n; i++)
        {
          if(a[i]~/[0-9](.*)_(.*)_(.*)[0-9]/)
            {
              file=a[i]
            }
        }
      n=split(file, b, "[_]")
      id=b[n]
      for(i=1; i<=NF; i++)
        {
          if($i~/smiles/)
            {
              col_smiles=i
            }
        }
    }
  if(FNR>=2 && FNR <='$can_num')
    {
      num[id]+=1
      system("molconvert mol \"" $col_smiles "\" -o '$savepath'/" id "_can_" num[id] ".mol")
      close("molconvert mol \"" $col_smiles "\" -o '$savepath'/" id "_can_" num[id] ".mol")
      printf id " >>> " num[id] "\n"
    }
}' $(cat tmp)
```

```{r eval = F, echo = T}
#############################
ls results/structure_2d/candidate/3918_*.mol | awk -F $'\t' '
{
  split($0, a, "[.][m][o][l]")
  system("obabel "  $0  " -imol -osvg -O "  a[1]  ".mol.svg")
  close("obabel "  $0  " -imol -osvg -O "  a[1]  ".mol.svg")
  print a[1]".svg"
}'
```

```{r eval = F, echo = T}
############################
sed -i -e 's/white/transparent/g' results/structure_2d/candidate/3918_*.mol.svg
```

```{r eval = F, echo = T}
###################################
ls results/structure_2d/candidate/3918_*.mol.svg | awk '
{
  if($0~/cairo/)
    {
      next
    }
else
  {
    system("cairosvg "  $0  " -o "  $0 ".cairo.svg")
    close("cairosvg "  $0  " -o "  $0 ".cairo.svg")
    printf "Info: the filename is "$0"\n"
  }
}'
```

```{r eval = F, echo = T}
###################################

```

# File: MCnebula_1.0.sh

```{r eval = F, echo = T}
## bin/bash

echo "We are all in the gutter, 
but some of us are looking at the stars.";
PS3='Please select the workflow to be executed. >>> '
select command in \
  "MCnebula_workflow" \
  "structure_extract" \
  "classification_extract_sum" \
  "classification_extract_filter" \
  "fragment_tree_network" \
  "fragment_tree_network_delta" \
  "structure_candidate_top10" \
  "(beta)" \
  "exit" 
do
  if [[ $command == "MCnebula_workflow" ]]
  then
    confirm=0
    until [[ $confirm == "yes" ]] || [[ $confirm == "no" ]]
    do
      read -p "Running all proccesses sequentially? [yes/no] >>> " confirm
    done;
    if [[ $confirm == "no" ]]
    then exit
    fi;
    default="structure_extract classification_extract_sum classification_extract_filter fragment_tree_network fragment_tree_network_delta"
    list=$(echo $default);
  else list=$( echo $command)
  fi;
  for option in $(echo $list)
  do
    case $option in
      ###################################
      ###################################
      ###################################
      ###################################
      structure_extract)
      echo "Run structure_extract."
      projectpath=0
      until [ -d $projectpath ] && [ -f $projectpath/canopus_summary.tsv ] && [ -f $projectpath/.format ]
      do
        read -p "Please input the path of the sirius project >>> " projectpath;
      done;
      cd $projectpath;
      mkdir results;
      mkdir temp;
      mkdir temp/fintemp;
      if [ -f temp/Mo_filename ]
      then rm temp/Mo_filename
      fi;
      data="*_*/fingerid/*.tsv"
      awk -F $'\t' '
      BEGIN{
      all_id=0
      max_id=-1
      p_id="null"
      printf "Info: loading the data..."
    }
  {
    if(FNR==1)
      {
        if(NR>FNR)
          {
            close(pfile)
          }
        f=split(FILENAME,a,"[/]");
        n=split(a[1],b,"[_]");
        id=b[n];
        if(id!=p_id)
          {
            all_id+=1
            if(id>max_id)
              {
                max_id=id
              }
          }
        file[id]=a[1]
        split(a[f], g, "[.]")
        formu_type[id]=g[1]
        if(all_id==1)
          {
            for(i=1; i<=NF; i++)
              {
                if(($i~/inchikey2D/))
                  {
                    col_2D=i
                  }
                if($i=="inchi")
                  {
                    col_inchi=i
                  }
                if(($i~/Formula/))
                  {
                    col_formu=i
                  }
                if($i=="score")
                  {
                    col_score=i
                  }
                if($i=="name")
                  {
                    col_name=i
                  }
                if($i=="smiles")
                  {
                    col_smiles=i
                  }
                if($i=="xlogp")
                  {
                    col_x=i
                  }
                if(($i~/imilarity/))
                  {
                    col_simi=i
                  }
                if($i~/links/)
                  {
                    col_links=i
                  }
              }
          }
        pfile=FILENAME
        printf g[1]"\t"formu_type[id]"\n"
        printf "Info: the data of " id " (ID) has input. The filename is " FILENAME ".\n"
      }
    if(FNR>=2)
      {
        row_score=$col_score
        row_simi=$col_simi
        if(max["score",id]=="" || max["score",id]+0<row_score+0)
          {
            max["score",id]=row_score
            name["score",id]=$col_name
            formula["score",id]=$col_formu
            formu_type["score",id]=formu_type[id]
            simi["score",id]=$col_simi
            smiles["score",id]=$col_smiles
            inchi["score",id]=$col_inchi
            in2D["score",id]=$col_2D
            score["score",id]=$col_score
            xlogp["score",id]=$col_x
            links["score",id]=$col_links
          }
        if(max["simi",id]=="" || max["simi",id]+0<row_simi+0)
          {
            max["simi",id]=row_simi
            name["simi",id]=$col_name
            formula["simi",id]=$col_formu
            formu_type["simi",id]=formu_type[id]
            simi["simi",id]=$col_simi
            smiles["simi",id]=$col_smiles
            inchi["simi",id]=$col_inchi
            in2D["simi",id]=$col_2D
            score["simi",id]=$col_score
            xlogp["simi",id]=$col_x
            links["simi",id]=$col_links
          }
      }
  }
END{
printf "id\t"  "name\t"  "formula\t"  "similarity\t"  "smiles\t"  "inchi\t"  "inchikey2D\t"  "score\t"  "xlogp\t"  "links\n" > "results/fingerid_sum.tsv"
for(l in file)
  {
    if(max["score",l]!="")
      {
        printf l"\t"  name["score",l]"\t"  formula["score",l]"\t"  simi["score",l]"\t"  smiles["score",l]"\t"  inchi["score",l]"\t"  in2D["score",l]"\t"  score["score",l]"\t"  xlogp["score",l]"\t"  links["score",l]"\n" >> "results/fingerid_sum.tsv"
        printf formula["score",l]"\t"  file[l]"\t"  formu_type["score",l]"\n" > "temp/Mo_filename"
      }
    if(max["simi",l]!="" && max["simi",l]!=max["score",l])
      {
        printf l"\t"  name["simi",l]"\t"  formula["simi",l]"\t"  simi["simi",l]"\t"  smiles["simi",l]"\t"  inchi["simi",l]"\t"  in2D["simi",l]"\t"  score["simi",l]"\t"  xlogp["simi",l]"\t"  links["simi",l]"\n" >> "results/fingerid_sum.tsv"
      }
  }
}' $data
data_sum="results/fingerid_sum.tsv"
awk -F $'\t' '
{
  if(NR==1)
    {
      for(i=1; i<=NF; i++)
        {
          if($i~/id/)
            {
              col_id=i
            }
          if($i~/score/)
            {
              col_score=i
            }
        }
    }
  if(NR>=2)
    {
      id=$col_id
      if(max_id+0<id || max_id=="")
        {
          max_id=id
        }
      if(score[id]+0<$col_score+0 || score[id]=="")
        {
          score[id]=$col_score
          data[id]=$0
        }
    }
}
END{
printf "id\t"  "name\t"  "formula\t"  "similarity\t"  "smiles\t"  "inchi\t"  "inchikey2D\t"  "score\t"  "xlogp\t"  "links\n" > "results/fingerid_first_score.tsv"
for(i=1; i<=max_id; i++)
  {
    if(data[i]!="")
      {
        printf data[i] "\n" >> "results/fingerid_first_score.tsv"
      }
  }
}' $data_sum
echo "structure_extract results have been successfully assembled into <results/fingerid_sum.tsv> and <results/fingerid_first_score.tsv>";
;;
```

```{r eval = F, echo = T}
###################################
```

```{r eval = F, echo = T}
###################################
```

```{r eval = F, echo = T}
###################################
```

```{r eval = F, echo = T}
###################################
classification_extract_sum)
echo "Run classification_extract_sum.";
if [ -f temp/Mo_filename ] && [ -f canopus.tsv ] && [ -f canopus_neg.tsv ] && [ -f .format ]
then
  echo "Project path acknowledged."
else
  until [ -d $projectpath ] && [ -f $projectpath/canopus.tsv ] && [ -f $projectpath/.format ]
  do
    read -p "Please input the path of the sirius project >>> " projectpath;
  done;
  cd $projectpath;
fi;
data1="temp/Mo_filename"
data2="canopus.tsv"
data3="canopus_neg.tsv"
datas=$(awk -F $'\t' '
{
  x=$2"/canopus/"$3".fpt"
  if(getline < x == 1)
    {
      printf x" "
    }
  close(x)
}' $data1)
```

```{r eval = F, echo = T}
##################
awk -F $'\t' '
{
  if(NR==FNR)
    {
      i=split($2,s,"[_]")
      the_id[FNR]=s[i]
      n=FNR
    }
  if(FILENAME ~ /canopus.tsv/)
    {
      if(FNR==1)
        {
          for(i=1; i<=NF; i++)
            {
              if($i ~ /^name/)
                {
                  col_class=i
                }
              if($i ~ /absolute/)
                {
                  col_abindex=i
                }
            }
        }
      if(FNR>=2)
        {
          abindex[1,FNR]=$col_abindex
          indexset[$col_abindex]=$col_class
        }
    }
  if(FILENAME ~ /canopus_neg.tsv/)
    {
      p_filename=FILENAME
      if(FNR==1)
        {
          for(i=1; i<=NF; i++)
            {
              if($i ~ /name/)
                {
                  col_class=i
                }
              if($i ~ /absolute/)
                {
                  col_abindex=i
                }
            }
        }
      if(FNR>=2)
        {
          abindex[2,FNR]=$col_abindex
          indexset[$col_abindex]=$col_class
        }
    }
  if(FILENAME ~ /.fpt/)
    {
      if(FNR==1)
        {
          close(p_filename)
          printf "Info: data_file name of " p_filename " has been input.\n"
          p_filename=FILENAME
          split(FILENAME,a,"[/]");
          m=split(a[1],b,"[_]");
          id=b[m];
          if(FILENAME ~ /\+.fpt/)
            {
              ion=1
            }
          if(FILENAME ~ /\-.fpt/)
            {
              ion=2
            }
        }
      pp[id,abindex[ion,FNR+1]]=sprintf("%.3f",$1)
    }
}
END{
printf "id" > "results/canopus_pp.tsv"
for(i in indexset)
  {
    ord+=1
    orderlist[ord]=i
    printf "\t"indexset[i] >> "results/canopus_pp.tsv"
  }
printf "\n" >> "results/canopus_pp.tsv"
for(i=1; i<=n; i++)
  {
    printf the_id[i] >> "results/canopus_pp.tsv"
    for(j=1; j<=ord; j++)
      {
        if(pp[the_id[i],orderlist[j]]=="")
          {
            pp[the_id[i],orderlist[j]]=0
          }
        printf "\t"pp[the_id[i],orderlist[j]] >> "results/canopus_pp.tsv"
      }
    printf "\n" >> "results/canopus_pp.tsv"
  }
}' $data1 $data2 $data3 $datas
echo "classiication_extract_sum have been successfully written into <results/canopus_pp.tsv>"
;;
```

```{r eval = F, echo = T}
###################################
```

```{r eval = F, echo = T}
###################################
```

```{r eval = F, echo = T}
###################################
classification_extract_filter)
echo "Run classification_extract_filter.";
if [ -f results/canopus_pp.tsv ]
then
  echo "Project path acknowledged."
else
  until [ -d $projectpath ] && [ -f $projectpath/results/canopus_pp.tsv ] && [ -f $projectpath/results/canopus_summary.tsv ]
  do
    read -p "Please input the path of the sirius project >>> " projectpath;
  done;
  cd $projectpath;
fi; 
check=0
until [[ "$check" == "yes" ]] || [[ "$check" == "no" ]]
do
  read -p "Collate the posterior probabilities of the classification of each feature? [yes/no] >>> " check;
done;
if [[ $check == "yes" ]]
then
  definition_limit=0
  until [[ "$definition_limit" > "0.01" ]] && [[ "$definition_limit" < "1" ]]
  do
    read -p "Please enter the classes posterior probabilities limition. 0.5~0.99 may work well. >>> " definition_limit;
  done;
  data1="canopus_summary.tsv"
  data2="canopus.tsv"
  data3="results/canopus_pp.tsv"
  awk -F $'\t' '
  {
    if(NR==FNR)
      {
        if(FNR==1)
          {
            p_file=FILENAME
            for(i=1; i<=NF; i++)
              {
                if($i~/name/)
                  {
                    col_id=i
                  }
                if($i~/specific/)
                  {
                    col_specific=i
                  }
                if($i~/level/)
                  {
                    col_level=i
                  }
                if($i~/subclass/)
                  {
                    col_subclass=i
                  }
                if($i~/^class/)
                  {
                    col_class=i
                  }
                if($i~/superclass/)
                  {
                    col_superclass=i
                  }
              }
          }
        if(FNR>=2)
          {
            n=split($col_id,a,"[_]")
            id=a[n]
            specific[id]=$col_specific
            level[id]=$col_level
            subclass[id]=$col_subclass
            class[id]=$col_class
            superclass[id]=$col_superclass
          }
      }
    if(FILENAME~/canopus.tsv/)
      {
        if(FNR==1)
          {
            close(p_file)
            p_file=FILENAME
            for(i=1; i<=NF; i++)
              {
                if($i~/name/)
                  {
                    col_name=i
                  }
                if($i~/description/)
                  {
                    col_description=i
                  }
              }
          }
        if(FNR>=2)
          {
            description[$col_name]=$col_description
          }
      }
    if(FILENAME~"'$data3'")
      {
        if(FNR==1)
          {
            close(p_file)
            for(i=1; i<=NF; i++)
              {
                if($i~/^id$/)
                  {
                    col_id=i
                  }
                if(i>=2)
                  {
                    col_class_name[i]=$i
                  }
              }
            printf "id\t"  "definition_source\t"  "definition\t"  "definition_pp\t"  "definition_description\t"  "specific\t"  "specific_pp\t"  "level_5\t"  "level_5_pp\t"  "subclass\t"  "subclass_pp\t"  "class\t"  "class_pp\t"  "superclass\t"  "superclass_pp\n"  > "results/stat_classification.tsv"
          }
        if(FNR>=2)
          {
            for(i=2; i<=NF; i++)
              {
                c_pp[col_class_name[i]]=sprintf("%.4f",$i)
              }
            if(level[$col_id] != "" && c_pp[level[$col_id]] >= "'$definition_limit'")
              {
                definition_source="level_5"
                definition=level[$col_id]
              }
          else if(subclass[$col_id] != "" && c_pp[subclass[$col_id]] >= "'$definition_limit'")
            {
              definition_source="subclass"
              definition=subclass[$col_id]
            }
        else if(class[$col_id] != "" && c_pp[class[$col_id]] >= "'$definition_limit'")
          {
            definition_source="class"
            definition=class[$col_id]
          }
      else if(superclass[$col_id] != "" && c_pp[superclass[$col_id]] >= "'$definition_limit'")
        {
          definition_source="superclass"
          definition=superclass[$col_id]
        }
    else
      {
        definition_source="null"
        definition="null"
        c_pp[definition]="null"
        description[definition]="null"
      }
    printf $col_id"\t"  definition_source"\t"  definition"\t"  c_pp[definition]"\t"  description[definition]"\t"  specific[$col_id]"\t"  c_pp[specific[$col_id]]"\t"  level[$col_id]"\t"  c_pp[level[$col_id]]"\t"  subclass[$col_id]"\t"  c_pp[subclass[$col_id]]"\t"  class[$col_id]"\t"  c_pp[class[$col_id]]"\t"  superclass[$col_id]"\t"  c_pp[superclass[$col_id]]"\n" >> "results/stat_classification.tsv"
  }
}
}' $data1 $data2 $data3
echo "classification_extract_filter have been successfully written into <results/stat_classification.tsv>"
fi;
;;
```

```{r eval = F, echo = T}
###################################
```

```{r eval = F, echo = T}
###################################
```

```{r eval = F, echo = T}
###################################
```

```{r eval = F, echo = T}
###################################
fragment_tree_network)
echo "Run fragment_tree_network.";
if [ -d temp ] && [ -f ftalign.tsv ] && [ -f .format ]
then
  echo "Project path acknowledged."
else
  until [ -d $projectpath ] && [ -f $projectpath/ftalign.tsv ] && [ -f $projectpath/.format ]
  do
    read -p "Please input the path of the sirius project. Make sure you have moved the fragment tree alignment results to the directory where the project is located. >>> " projectpath;
  done;
  cd $projectpath;
fi;
echo "Please enter the minimum alignment similarity(tlimit) that you want to filter."
tlimit=0
until [[ "$tlimit" > "0.01" ]] && [[ "$tlimit" < "0.99" ]]
do
  read -p "0.4-0.7 is recommended >>> " tlimit;
done;
if ! [ -d temp/ftaligntemp ]
then 
  mkdir temp/ftaligntemp
fi;
data="ftalign.tsv"
savepath="temp/ftaligntemp/tmp"
awk -F $'\t' -v OFS=$'\t' '
{
  printf "Info: NR = " NR ". FNR = " FNR ".\n"
  if(NR==FNR)
    {
      for(i=1; i<=NF; i++)
        {
          if(NR==1 && i!=1 || NR!=1 && i==1)
            {
              n=split($i,x,"[_]")
              raw[NR,i]=x[n]
            }
        else
          {
            if(NR==i)
              {
                raw_norm[NR,i]=$i
              }
          }
      }
  }
if(NR>FNR && FNR>=2)
  {
    for(i=2; i<=NF; i++)
      {
        norm1=$i/raw_norm[i,i]
        norm2=$i/raw_norm[FNR,FNR]
        norms=sprintf("%.2f", ((norm1+norm2)/2))
        if((norms+0 > '$tlimit'+0))
          {
            if(raw[FNR,1]+0>=raw[1,i]+0)
              {
                print raw[FNR,1], raw[1,i], norms > "'$savepath'"
              }
            if(raw[FNR,1]+0<raw[1,i]+0)
              {
                print raw[1,i], raw[FNR,1], norms > "'$savepath'"
              }
          }
      }
  }
}' $data $data
sort -u $savepath > temp/ftaligntemp/tmp2
savepath="temp/ftaligntemp/filter_net_$tlimit"
awk -F $'\t' '
{
  if(NR==FNR)
    {
      if($1!=$2)
        {
          replink[$1]=$1
          replink[$2]=$2
        }
    }
  if(NR!=FNR)
    {
      if($1!=$2)
        {
          printf $0"\n" > "'$savepath'" 
        } 
      if($1==$2)
        {
          if(replink[$1]=="")
            {
              printf $0"\n" > "'$savepath'"
            }
        }
    }
}' temp/ftaligntemp/tmp2 temp/ftaligntemp/tmp2
echo "fragment_tree_network have been successfully written into <temp/ftaligntemp/filter_net_$tlimit>"
;;
```

```{r eval = F, echo = T}
###################################
```

```{r eval = F, echo = T}
###################################
```

```{r eval = F, echo = T}
###################################
```

```{r eval = F, echo = T}
###################################
fragment_tree_network_delta)
if [ -d temp ] && [ -f ftalign.tsv ] && [ -f .format ]
then
  echo "Project path acknowledged."
else
  until [ -d $projectpath ] && [ -f $projectpath/ftalign.tsv ] && [ -f $projectpath/.format ]
  do
    read -p "Please input the path of the sirius project >>> " projectpath;
  done;
  cd $projectpath;
fi;
echo "The following module attempts to compute the differential fingerprints of connected clusters based on the molecular fingerprint results of sirius 4."
```

```{r eval = F, echo = T}
###################
```

```{r eval = F, echo = T}
###################
```

```{r eval = F, echo = T}
###################
plimit=0
until [[ "$plimit" > "0.5" ]] && [[ "$plimit" < "0.99" ]]
do
  read -p "If the minimum alignment similarity is greater than 0.3, this step will automatic calculate the discrepancy fingerprint between alignment features(in beta). Please enter the minimum posterior probability of the molecular fingerprint(plimit_1) to be filtered. 0.9-0.99 is recommended. >>> " plimit;
done;
plimit2=0
until [[ "$plimit2" > "0.1" ]] && [[ "$plimit2" < "$plimit" ]]
do
  read -p "The minimum posterior probability of the molecular fingerprint(plimit_2) to be controled. 0.1-0.5 may work well. >>> " plimit2;
done;
tlimit=$(ls temp/ftaligntemp/filter_net_* | awk -F _ '{print $NF}')
check_rep=$(awk 'END{print NR}' <(echo "$tlimit"))
if [[ "$check_rep" > "1" ]]
then
  tlimit=0
  until [ -f temp/ftaligntemp/filter_net_$tlimit ]
  do
    read -p "Plural and different fragment_tree_network files were found to exist locally. Please select a tlimit parameter you have utilized to run fragment_tree_network_delta. >>> " tlimit;
  done;
fi;
if [ -f temp/ftaligntemp/refilter_net_$tlimit ]
then rm temp/ftaligntemp/refilter_net_$tlimit
fi;
if [ -f temp/ftaligntemp/fpsample ]
then rm temp/ftaligntemp/fpsample
fi;
echo "Running delta_fingerprint computation..."
echo "Aquiring data from sirius index..."
data1="*_*/compound.info"
data2="temp/ftaligntemp/filter_net_$tlimit"
echo "Run fragment_tree_network_delta."
savepath="temp/ms_data_$tlimit"
echo "step 1: ms data"
if ! [ -f $savepath ]
then
  awk -F "[\t]||[:]||[_]" -v OFS=$'\t' '
  BEGIN{  
  printf "..."
  printf "id\t"  "m/z\t"  "rt\n" > "results/mz_and_rt.tsv"
}
{
  if(FILENAME~/compound.info/)
    {
      if(FNR==1)
        {
          printf "Info: catch >>> "FILENAME"\n"
        }
      if($1=="name")
        {
          i+=1;
          id[i]=$NF;
          n=split($NF,a,"[_]")
          printf a[n]"\t" >> "results/mz_and_rt.tsv"
        }
      if($1=="ionMass")
        {
          mz[id[i]]=$NF
          printf sprintf("%.4f",$NF)"\t" >> "results/mz_and_rt.tsv"
        }
      if($1=="ionType")
        {
          type[id[i]]=$NF
        }
      if($1=="rt")
        {
          rt[id[i]]=$2;
          printf sprintf("%.2f",$2/60)"\n" >> "results/mz_and_rt.tsv"
        }
    }
  if(FILENAME~/ftaligntemp/)
    {
      #source  target  ftalign  delta_mz  delta_rt  source_iontype  target_iontype;
      if(FNR==1)
        {
          printf "" > "'$savepath'"
        }
      print $1,$2,$3,sprintf("%.3f",mz[$2]-mz[$1]),sprintf("%.2f",rt[$2]-rt[$1]),type[$1],type[$2]  >> "'$savepath'"
    }
}' $data1 $data2
fi;
```

```{r eval = F, echo = T}
########################
echo "step 2: data path"
source_file="temp/Mo_filename"
data="temp/ms_data_$tlimit"
savepath="temp/datapath_$tlimit"
if ! [ -f $savepath ]
then
  awk -F $'\t' -v OFS=$'\t' '
  {
    if(NR==FNR)
      {
        n=split($2, a, "[_]")
        file[a[n]]=$2
        formu_type[a[n]]=$3
      }
    if(NR!=FNR)
      {
        #<path>sourceFormula  <path>targetFormula
        path1=file[$1]"/fingerprints/"formu_type[$1]".fpt"
        path2=file[$2]"/fingerprints/"formu_type[$2]".fpt"
        data[path1]=path1
        data[path2]=path2
      }
  }
END{
for(i in data)
  {
    n+=1
    print "Check file:",n
    if(getline<i==-1)
      {
        printf "Escape filename: " i "\n"
      }
  else
    {
      printf i" " > "'$savepath'"
    }
  close(i)
}
print "Sum:",n
}' $source_file $data
fi;
datapath=$(cat temp/datapath_$tlimit)
echo "step 3: fingerprint"
data_allfp="temp/data_allfp_$tlimit"
if ! [ -f $data_allfp ]
then
  awk -F $'\t' '
  BEGIN{
  n=0
}
{
  if(FNR==1)
    {
      if(n>1)
        {
          close(file)
        }
      file=FILENAME;
      print "Get fingerprints: ",FILENAME
      n+=1;
      printf FILENAME"\n"$0"\n" > "'$data_allfp'"
    }
else
  {
    print $0 > "'$data_allfp'"
  }
}' $datapath
fi;
```

```{r eval = F, echo = T}
###########################
awk -F $'\t' -v OFS=$'\t' '
{
  if(NR==1)
    {
      for(i=1; i<=NF; i++)
        {
          if($i~/absolute/)
            {
              col_index=i
            }
          if($i~/description/)
            {
              col_description=i
            }
        }
    }
  if(NR>=2)
    {
      print $col_index,$col_description
    }
}' csi_fingerid.tsv > temp/ftaligntemp/pos_fingerprint_index;
awk -F $'\t' -v OFS=$'\t' '
{
  if(NR==1)
    {
      for(i=1; i<=NF; i++)
        {
          if($i~/absolute/)
            {
              col_index=i
            }
          if($i~/description/)
            {
              col_description=i
            }
        }
    }
  if(NR>=2)
    {
      print $col_index,$col_description
    }
}' csi_fingerid_neg.tsv > temp/ftaligntemp/neg_fingerprint_index;
posindex="temp/ftaligntemp/pos_fingerprint_index"
negindex="temp/ftaligntemp/neg_fingerprint_index"
data="temp/ms_data_$tlimit"
echo "step 4: merge data"
awk -F $'\t' '
BEGIN{
file=0
x=0
count=0
f=0
posnum=0
negnum=0
}
{
  if(FNR==1)
    {
      file+=1
    }
  if(NR==FNR)
    {
      if(($1~/fingerprint/))
        {
          if(x+0>f+0)
            {
              f=x  # calculate the max index.
            }
          count+=1;  # calculate the all fingerprints file number.
          split($1,a,"[/]"); e=split(a[1],b,"[_]"); id=b[e]; #catch the id.
          x=0;
        }
    else
      {
        x+=1;
        fp[id,x]=$1;
      }
  }
if(file==2)
  {
    pos[FNR]=$1
    posnum+=1
  }
if(file==3)
  {
    neg[FNR]=$1
    negnum+=1
  }
if(file==4)
  {
    if("'$tlimit'"+0 >= 0.3)
      {
        if(fp[$1,1]!="" && fp[$2,1]!="")
          {
            n1=split($6, g, "[]]");
            n2=split($7, h, "[]]");
            if(g[n1]=="+" && h[n2]=="+")
              {
                for(x=1; x<=posnum; x++)
                  {
                    if(fp[$1,x]+0>='$plimit'+0 && fp[$2,x]+0<='$plimit2'+0)
                      {
                        data_s[FNR,x]=pos[x]
                      }
                  else if(fp[$2,x]+0>='$plimit'+0 && fp[$1,x]+0<='$plimit2'+0)
                    {
                      data_t[FNR,x]=pos[x]
                    }
                }
            }
          if(g[n1]=="-" && h[n2]=="-")
            {
              for(x=1; x<=negnum; x++)
                {
                  if(fp[$1,x]+0>='$plimit'+0 && fp[$2,x]+0<='$plimit2'+0)
                    {
                      data_s[FNR,x]=neg[x]
                    }
                else if(fp[$2,x]+0>='$plimit'+0 && fp[$1,x]+0<='$plimit2'+0)
                  {
                    data_t[FNR,x]=neg[x]
                  }
              }
          }
        if(g[n1]=="-" && h[n2]=="+" || h[n2]=="-" && g[n1]=="+")
          {
            for(i=1; i<=posnum; i++)
              {
                for(j=1; j<=negnum; j++)
                  {
                    if(pos[i]==neg[j])
                      {
                        mirror[i]=j  #if pos=i, the identical index of neg is mirror[i]
                      }
                  }
              }
          }
        if(g[n1]=="-" && h[n2]=="+") 
          {
            for(x=1; x<=f; x++)
              {
                if(fp[$1,mirror[x]]+0>='$plimit'+0 && fp[$2,x]+0<='$plimit2'+0)
                  {
                    data_s[FNR,x]=neg[mirror[x]]
                  }
              else if(fp[$2,x]+0>='$plimit'+0 && fp[$1,mirror[x]]+0<='$plimit2'+0)
                {
                  data_t[FNR,x]=neg[mirror[x]]
                }
            }
        }
      if(h[n2]=="-" && g[n1]=="+")
        {
          for(x=1; x<=f; x++)
            {
              if(fp[$1,x]+0>= '$plimit'+0 && fp[$2,mirror[x]]+0<='$plimit2'+0)
                {
                  data_s[FNR,x]=neg[mirror[x]]
                }
            else if(fp[$2,mirror[x]]+0>='$plimit'+0 && fp[$1,x]+0<='$plimit2'+0)
              {
                data_t[FNR,x]=neg[mirror[x]]
              }
          }   
      }
  }
}
if(FNR==1)
  {
    printf "source\t"  "target\t"  "ftalign_similarity\t"  "delta_m/z\t"  "source_fp_uniq\t"  "target_fp_uniq\n"
  }
else
  {
    printf $1"\t"  $2"\t"  $3"\t"  $4"\t";
    if('$tlimit'+0 >= 0.3)
      {
        if(fp[$1,1]=="" || fp[$2,1]=="")
          {
            printf "NA@NA\n"
          }
      else
        {
          printf "source:"  #the source fingerprint uniq.
          for(x=1; x<=f; x++)
            {
              if(data_s[FNR,x]!="")
                {
                  printf data_s[FNR,x]","
                }
            };
          printf "@target:"  #the target fingerprint uniq.
          for(x=1; x<=f; x++)
            {
              if(data_t[FNR,x]!="")
                {
                  printf data_t[FNR,x]","
                }
            }
          printf "\n"
        }
    }
else
  {
    printf "NA@NA\n"
  }
}
}
}' $data_allfp $posindex $negindex $data | sed -e 's/,@/\t/g; s/,$//g; s/@/\t/g'  > results/source_target_tree_$tlimit.tsv;
echo "All instances have written into <results/source_target_tree_$tlimit.tsv>."
```

```{r eval = F, echo = T}
#####################################
echo "step 5: separate child-nebula from parent-nebula."
data="results/stat_classification.tsv"
savepath="temp/filter_0_class.tsv"
awk -F $'\t' '
{
  if(FNR==1)
    {
      for(i=1; i<=NF; i++)
        {
          if($i~/^definition$/)
            {
              col_class=i
            }
        }
    }
  if(FNR>=2)
    {
      class[$col_class]=$col_class
    }
}
END{
for(i in class)
  {
    printf class[i]"\n" > "'$savepath'"
  }
}' $data
```

```{r eval = F, echo = T}
######################################
data1="temp/filter_0_class.tsv" 
data2="results/canopus_pp.tsv"
data3="results/fingerid_first_score.tsv"
until [[ "$similarity_limit" > 0 ]] && [[ "$similarity_limit" < 1 ]]
do
  read -p "Please set the Tanimoto similarity threshold contribute to child-nebula. >>> " similarity_limit;
done;
until [[ "$definition_limit" > 0.01 ]] && [[ "$definition_limit" < 1 ]]
do
  read -p "Please enter the classes posterior probabilities limition. 0.5~0.99 may work well. >>> " definition_limit;
done;
class_pp_limit=$definition_limit
savepath="temp/idenfication_filter_$class_pp_limit.tsv"
awk -F $'\t' '
{
  if(NR==FNR)
    {
      filter_class[$1]=$1
    }
  if(FILENAME~/canopus/)
    {
      if(FNR==1)
        {
          col_id=1
          for(i=2; i<=NF; i++)
            {
              for(j in filter_class)
                {
                  if(j==$i)
                    {
                      col_class[j]=i
                      print i
                    }
                }
            }
        }
      if(FNR>=2)
        {
          for(i in col_class)
            {
              if(sprintf("%.3f",$col_class[i])+0>="'$class_pp_limit'"+0)
                {
                  class_set[i,$col_id]=i
                  print "ID: ",$1,i,$col_class[i]
                }
            }
        }
    }
  if(FILENAME~/fingerid_first_score/)
    {
      if(FNR==1)
        {
          for(i=1; i<=NF; i++)
            {
              if($i~/^id/)
                {
                  col_id=i
                }
              if($i~/similarity/)
                {
                  col_similarity=i
                }
            }
          printf "class_nebula_facet\t"  $0"\n" > "'$savepath'"
        }
      if(FNR>=2)
        {
          if($col_similarity+0 >= "'$similarity_limit'"+0)
            {
              for(i in class_set)
                {
                  if(i~"\034"$col_id"$")
                    {
                      printf class_set[i]"\t"  $0"\n" > "'$savepath'"
                    }
                }
            }
        }
    }
}' $data1 $data2 $data3
```

```{r eval = F, echo = T}
###################################
data="temp/idenfication_filter_$class_pp_limit.tsv"
savepath="temp/idenfication_filter2_${class_pp_limit}.tsv"
until [[ "$num_limit_1" -gt 0 ]]
do
  read -p "Please enter the features number threshold contribute to child-nebula (min number). >>> " num_limit_1;
done;
until [[ "$num_limit_2" -gt "$num_limit_1" ]]
do
  read -p "Please enter the features number threshold contribute to child-nebula (max number). >>> " num_limit_2;
done;
awk -F $'\t' '
{
  if(FNR==1)
    {
      printf $0"\n" > "'$savepath'"
      for(i=1; i<=NF; i++)
        {
          if($i~/class_nebula_facet/)
            {
              col_class=i
            }
        }
    }
  if(FNR>=2)
    {
      num[$col_class]+=1
      data[FNR]=$0
      class[FNR]=$col_class
    }
}
END{
for(i in num)
  {
    if(num[i]+0 >= '$num_limit_1'+0 && num[i]+0 <= '$num_limit_2')
      {
        printf "The nodes number of the child-nebula is " num[i] ".\n"
        for(j in class)
          {
            if(class[j]==i)
              {
                printf data[j]"\n" >> "'$savepath'"
              }
          }
      }
  }
}' $data
```

```{r eval = F, echo = T}
##################################
mkdir results/network_facet_$class_pp_limit
data1="temp/idenfication_filter2_${class_pp_limit}.tsv"
data2="results/source_target_tree_$tlimit.tsv" # "results/source_target_tree_0.4.tsv"
save_class="results/filter_child_class.tsv"
savepath="results/network_facet_$class_pp_limit/"
awk -F $'\t' '
{
  if(NR==FNR)
    {
      if(FNR==1)
        {
          for(i=1; i<=NF; i++)
            {
              if($i~/class_nebula_facet/)
                {
                  col_class=i
                }
              if($i~/^id$/)
                {
                  col_id=i
                }
            }
        }
      if(FNR>=2)
        {
          class[$col_class]=$col_class
          class_id[$col_class,$col_id]=$col_id
          stat_id[$col_class,$col_id]=$col_id
          belong[$col_class,$col_id]=$col_class
        }
    }
  if(NR>FNR)
    {
      if(FNR==1)
        {
          for(i in class)
            {
              printf i"\n" > "'$save_class'"
              printf $0"\t"  "facet\n" > "'$savepath'" i ".tsv"
            }
        }
      if(FNR>=2)
        {
          for(i in class)
            {
              if( class_id[i,$1]==$1 && class_id[i,$2]==$2 )
                {
                  printf $0"\t"  i"\n" >> "'$savepath'" i ".tsv"
                  delete stat_id[i,$1]
                  delete stat_id[i,$2]
                }
            }
        }
    }
}
END{
for(i in stat_id)
  {
    ## source target similarity delta_mz fp fp class
    printf stat_id[i]"\t" stat_id[i]"\t"  "1\t"  "0\t"  "null\t"  "null\t"  belong[i]"\n"  >> "'$savepath'" belong[i] ".tsv"
  }
}' $data1 $data2
```

```{r eval = F, echo = T}
#####################
data1="canopus.tsv"
data2="results/filter_child_class.tsv"
data3="results/canopus_pp.tsv"
savepath="results/canopus_pp_filter.tsv"
awk -F $'\t' '
{
  if(FILENAME~/canopus.tsv/)
    {
      if(FNR==1)
        {
          for(i=1; i<=NF; i++)
            {
              if($i~/absolute/)
                {
                  col_index=i
                }
              if($i~/^id/)
                {
                  col_chemid=i
                }
              if($i~/name/)
                {
                  col_name=i
                }
              if($i~/description/)
                {
                  col_des=i
                }
            }
        }
      if(FNR>2)
        {
          ab_index[$col_name]=$col_index
          chemid[$col_name]=$col_chemid
          des[$col_name]=$col_des
        }
    }
  if(FILENAME~/filter_child_class/)
    {
      class[$1]=$1
      if(FNR==1)
        {
          printf "index\t"  "chem_id\t"  "name\t"  "description\n" > "results/child_class.tsv"
        }
      printf ab_index[$1]"\t"  chemid[$1]"\t"  $1"\t"  des[$1]"\n" >> "results/child_class.tsv"
    }
  if(FILENAME~/canopus_pp/)
    {
      if(FNR==1)
        {
          printf $1 > "'$savepath'"
          for(i=2; i<=NF; i++)
            {
              if(class[$i]!="")
                {
                  n+=1
                  printf "\tC"ab_index[$i] >> "'$savepath'"
                  col_set[n]=i
                }
            }
          printf "\n" >> "'$savepath'"
        }
      if(FNR>=2)
        {
          printf $1 >> "'$savepath'"
          for(i=1; i<=n; i++)
            {
              printf "\t"$col_set[i] >> "'$savepath'"
            }
          printf "\n" >> "'$savepath'"
        }
    }
}' $data1 $data2 $data3
;;
```

```{r eval = F, echo = T}
###################################
```

```{r eval = F, echo = T}
###################################
structure_candidate_top10)
echo "structure_candidate_top10 (awk version ≥ 3.1)."
projectpath=0
until [ -d $projectpath ] && [ -f $projectpath/.format ]
do
  read -p "Please input the path of the sirius project >>> " projectpath;
done;
cd $projectpath;
if [ -f results ]
then echo "Expand into target dir <results>"
else mkdir results
  mkdir temp
  mkdir temp/fintemp;
fi;
## gather all structure candidate
data="*_*/fingerid/*.tsv"
awk -F $'\t' '
BEGIN{
all_id=0
max_id=-1
p_id="null"
printf "Info: loading the data..."
}
{
  if(FNR==1)
    {
      if(NR>FNR)
        {
          close(pfile)
        }
      f=split(FILENAME,a,"[/]");
      n=split(a[1],b,"[_]");
      id=b[n];
      if(id!=p_id)
        {
          all_id+=1
          if(id>max_id)
            {
              max_id=id
            }
        }
      file[id]=a[1]
      split(a[f], g, "[.]")
      formu_type[id]=g[1]
      if(all_id==1)
        {
          printf "id\t"  "name\t"  "formula\t"  "similarity\t"  "smiles\t"  "inchi\t"  "inchikey2D\t"  "score\t"  "xlogp\t"  "links\n" > "results/fingerid_candidate_all.tsv"
          targetfile="results/fingerid_candidate_all.tsv"
          for(i=1; i<=NF; i++)
            {
              if(($i~/inchikey2D/))
                {
                  col_2D=i
                }
              if($i=="inchi")
                {
                  col_inchi=i
                }
              if(($i~/Formula/))
                {
                  col_formu=i
                }
              if($i=="score")
                {
                  col_score=i
                }
              if($i=="name")
                {
                  col_name=i
                }
              if($i=="smiles")
                {
                  col_smiles=i
                }
              if($i=="xlogp")
                {
                  col_x=i
                }
              if(($i~/imilarity/))
                {
                  col_simi=i
                }
              if($i~/links/)
                {
                  col_links=i
                }
            }
        }
      pfile=FILENAME
      printf g[1]"\t"formu_type[id]"\n"
      printf "Info: the data of " id " (ID) has input. The filename is " FILENAME ".\n"
    }
  if(FNR>=2)
    {
    ##  "id\t"  "name\t"  "formula\t"  "similarity\t"  "smiles\t"  "inchi\t"  "inchikey2D\t"  "score\t"  "xlogp\t"  "links\n" > targetfile
    printf id"\t" $col_name"\t" $col_formu"\t" $col_simi"\t" $col_smiles"\t" $col_inchi"\t" $col_2D"\t" $col_score"\t" $col_x"\t" $col_links"\n" > targetfile
    }
} ' $data
## sort the candidates to get top 10
data="results/fingerid_candidate_all.tsv"
version=0
version=$(awk 'BEGIN{a[1]=1; asort(a, b); print b[1]}')
if [ $version != 1 ]
then
  echo "Awk version ≤ 3.1. Function <asort> not available."
fi
awk -F $'\t' '
{
  if(FNR==1)
    {
      printf "id\t"  "name\t"  "formula\t"  "similarity\t"  "smiles\t"  "inchi\t"  "inchikey2D\t"  "score\t"  "xlogp\t"  "links\n" > "results/fingerid_candidate_top10.tsv"
      targetfile="results/fingerid_candidate_top10.tsv"
      for(i=1; i<=NF; i++)
        {
          if($i~/^id$/)
            {
              col_id=i
            }
          if($i~/^score/)
            {
              col_score=i
            }
        }
    }
  if(FNR>=2)
    {
      if(id!=$col_id)
        {
          ## output data top10
          if(id!="")
            {
              j=asort(score, a)
              for(i=j; i>=(j-9); i--)
                {
                  if(i==0)
                    {
                      break
                    }
                  if(data[a[i]]=="")
                    {
                      print "yes"
                    }
                  printf data[a[i]]"\n" > targetfile
                }
              delete data
              delete score
            }
          ## gather first row of the id
          n=1
          score[n]=$col_score
          if(data[$col_score]!="")
            {
              $col_score+=0.00000001
            }
          data[$col_score]=$0
        }
    else
        {
          n+=1
          score[n]=$col_score
          if(data[$col_score]!="")
            {
              $col_score+=0.00000001
            }
          data[$col_score]=$0
        }
      id=$col_id
    }
}
END{
{
  j=asort(score, a)
  for(i=j; i>=j-9; i--)
    {
      if(i==0)
        {
          break
        }
      printf data[a[i]]"\n" > targetfile
    }
}
}' $data
exit
;;
```

```{r eval = F, echo = T}
###################################
```

```{r eval = F, echo = T}
###################################
"(beta)")
exit;
;;
```

```{r eval = F, echo = T}
###################################
```

```{r eval = F, echo = T}
###################################
```

```{r eval = F, echo = T}
###################################
```

```{r eval = F, echo = T}
###################################
exit)
echo "The mystery of creation is like the darkness of night--it is great.
Delusions of knowledge are like the fog of the morning."
exit;
;;
```

```{r eval = F, echo = T}
###################################
```

```{r eval = F, echo = T}
###################################
```

```{r eval = F, echo = T}
###################################
```

```{r eval = F, echo = T}
###################################
*)
echo "error"
exit;
;;
esac;
done;#(for)
done;#(select)
```

# File: mcnebula1023.sh

```{r eval = F, echo = T}
##########################
```

```{r eval = F, echo = T}
##########################
echo "We are all in the gutter, 
but some of us are looking at the stars.";

PS3='Please select the workflow to be executed. >>> '

select command in \
  	\
 	"default" \
 	\
 	"structure_extract" \
 	\
 	"classification_extract_sum" \
 	\
 	"classification_extract_filter" \
 	\
 	"fragment_tree_network" \
 	\
 	"fragment_tree_network_delta" \
 	\
 	"compound_idenfication" \
 	\
 	"double_ion_network" \
 	\
 	"exit" 
do
	
	if [[ $command == "default" ]]
	then
	
	confirm=0
	
	 	until [[ $confirm == "yes" ]] || [[ $confirm == "no" ]]
	 	do
	 	read -p "Running all proccesses sequentially? [yes/no] >>> " confirm
	 	done;
	 	if [[ $confirm == "no" ]]
	 	then exit
	 	fi;
	 	
	default="structure_extract classification_extract_sum classification_extract_filter fragment_tree_network fragment_tree_network_delta"
	
	list=$(echo $default);
	
	else list=$( echo $command)
	fi;
	
	for option in $(echo $list)
	do
	 	case $option in
```

```{r eval = F, echo = T}
###################################
```

```{r eval = F, echo = T}
###################################
```

```{r eval = F, echo = T}
###################################
```

```{r eval = F, echo = T}
###################################
structure_extract)
echo "Run structure_extract."
projectpath=0
	until [ -d $projectpath ] && [ -f $projectpath/canopus_summary.tsv ] && [ -f $projectpath/.format ]
	do
	read -p "Please input the path of the sirius project >>> " projectpath;
	done;
	
cd $projectpath;
mkdir results;
mkdir temp;
mkdir temp/fintemp;

	if [ -f temp/Mo_filename ]
	then rm temp/Mo_filename
	fi;

data="*_*/fingerid/*.tsv"

awk -F $'\t' '
 	BEGIN{
 	 	all_id=0
 	 	\
 	 	max_id=-1
 	 	\
 	 	p_id="null"
 	 	\
 	 	printf "Info: loading the data..."
 	 	}
 	{
 	if(FNR==1)
 	 	{
 	 	if(NR>FNR)
 	 	 	{
 	 	 	close(pfile)
 	 	 	}
 	 	f=split(FILENAME,a,"[/]");
 	
 	 	n=split(a[1],b,"[_]");
 	
 	 	id=b[n];
 	
 	 	if(id!=p_id)
 	 	 	{
 	 	 	all_id+=1
 	 	 	\
 	 	 	if(id>max_id)
 	 	 	 	{
 	 	 	 	max_id=id
 	 	 	 	}
 	 	 	}
 	 	file[id]=a[1]
 	 	
 	 	split(a[f], g, "[.]")
 	 	
 	 	formu_type[id]=g[1]
 	 	
 	 	if(all_id==1)
 	 	 	{
 	 	 	for(i=1; i<=NF; i++)
 	 	 	 	{
 	 	 	 	if(($i~/inchikey2D/))
 	 	 	 	 	{
 	 	 	 	 	col_2D=i
 	 	 	 	 	}
 	 	 	 	if($i=="inchi")
 	 	 	 	 	{
 	 	 	 	 	col_inchi=i
 	 	 	 	 	}
 	 	 	 	if(($i~/Formula/))
 	 	 	 	 	{
 	 	 	 	 	col_formu=i
 	 	 	 	 	}
 	 	 	 	if($i=="score")
 	 	 	 	 	{
 	 	 	 	 	col_score=i
 	 	 	 	 	}
 	 	 	 	if($i=="name")
 	 	 	 	 	{
 	 	 	 	 	col_name=i
 	 	 	 	 	}
 	 	 	 	if($i=="smiles")
 	 	 	 	 	{
 	 	 	 	 	col_smiles=i
 	 	 	 	 	}
 	 	 	 	if($i=="xlogp")
 	 	 	 	 	{
 	 	 	 	 	col_x=i
 	 	 	 	 	}
 	 	 	 	if(($i~/imilarity/))
 	 	 	 	 	{
 	 	 	 	 	col_simi=i
 	 	 	 	 	}
 	 	 	 	if($i~/links/)
 	 	 	 	 	{
 	 	 	 	 	col_links=i
 	 	 	 	 	}
 	 	 	 	}
 	 	 	}
 	 	pfile=FILENAME
 	 	
 	 	printf g[1]"\t"formu_type[id]"\n"
 	 	
 	 	printf "Info: the data of " id " (ID) has input. The filename is " FILENAME ".\n"
 	 	}
 	if(FNR>=2)
 	 	{
 	 	row_score=$col_score
 	 	
 	 	row_simi=$col_simi
 	 	
 	 	if(max["score",id]=="" || max["score",id]+0<row_score+0)
	 	 	{
 	 	 	max["score",id]=row_score
 	 	 	
 	 	 	name["score",id]=$col_name
 	 	
 	 	 	formula["score",id]=$col_formu
 	 	 	
 	 	 	simi["score",id]=$col_simi
 	 	
 	 	 	smiles["score",id]=$col_smiles
 	 	
 	 	 	inchi["score",id]=$col_inchi
 	 	
 	 	 	in2D["score",id]=$col_2D
 	 	 	
 	 	 	score["score",id]=$col_score
 	 	
 	 	 	xlogp["score",id]=$col_x
 	 	 	
 	 	 	links["score",id]=$col_links
 	 	 	}
 	 	if(max["simi",id]=="" || max["simi",id]+0<row_simi+0)
	 	 	{
 	 	 	max["simi",id]=row_simi
 	 	 	
 	 	 	name["simi",id]=$col_name
 	 	
 	 	 	formula["simi",id]=$col_formu
 	 	 	
 	 	 	simi["simi",id]=$col_simi
 	 	
 	 	 	smiles["simi",id]=$col_smiles
 	 	
 	 	 	inchi["simi",id]=$col_inchi

 	 	 	in2D["simi",id]=$col_2D
 	 	 	
 	 	 	score["simi",id]=$col_score
 	 	 
 	 	 	xlogp["simi",id]=$col_x
 	 	 	
 	 	 	links["simi",id]=$col_links
 	 	 	}
 	 	}
 	}
 	END{
 	 	printf "id\t"  "name\t"  "formula\t"  "similarity\t"  "smiles\t"  "inchi\t"  "inchikey2D\t" \
 	 	\
 	 	"score\t"  "xlogp\t"  "links\n" > "results/fingerid_sum.tsv"
 	 	\
 	 	printf "" > "temp/Mo_filename"
 	 	
 	 	for(l in file)
 	 	 	{
 	 	 	if(max["score",l]!="")
 	 	 	 	{
 	 	 	 	printf l"\t" \
 	 	 	 	\
 	 	 	 	name["score",l]"\t"  formula["score",l]"\t"  simi["score",l]"\t" \
 	 	 	 	\
 	 	 	 	smiles["score",l]"\t"  inchi["score",l]"\t"  in2D["score",l]"\t" \
 	 	 	 	\
 	 	 	 	score["score",l]"\t"  xlogp["score",l]"\t"  links["score",l]"\n" >> "results/fingerid_sum.tsv"
 	 	 	 	
 	 	 	 	printf formula["score",l]"\t"  file[l]"\t"  formu_type[l]"\n" >> "temp/Mo_filename"
 	 	 	 	}
 	 	 	if(max["simi",l]!="" && max["simi",l]!=max["score",l])
 	 	 	 	{
 	 	 	 	printf l"\t" \
 	 	 	 	\
 	 	 	 	name["simi",l]"\t"  formula["simi",l]"\t"  simi["simi",l]"\t" \
 	 	 	 	\
 	 	 	 	smiles["simi",l]"\t"  inchi["simi",l]"\t"  in2D["simi",l]"\t" \
 	 	 	 	\
 	 	 	 	score["simi",l]"\t"  xlogp["simi",l]"\t"  links["simi",l]"\n" >> "results/fingerid_sum.tsv"
 	 	 	 	}
 	 	 	}
 	 	}' $data

data_sum="results/fingerid_sum.tsv"

awk -F $'\t' '
 	{
 	if(NR==1)
 	 	{
 	 	for(i=1; i<=NF; i++)
 	 	 	{
 	 	 	if($i~/id/)
 	 	 	 	{
 	 	 	 	col_id=i
 	 	 	 	}
 	 	 	if($i~/score/)
 	 	 	 	{
 	 	 	 	col_score=i
 	 	 	 	}
 	 	 	}
 	 	}
 	if(NR>=2)
 	 	{
 	 	id=$col_id
 	 	\
 	 	if(max_id+0<id || max_id=="")
 	 	 	{
 	 	 	max_id=id
 	 	 	}
 	 	if(score[id]+0<$col_score+0 || score[id]=="")
 	 	 	{
 	 	 	score[id]=$col_score
 	 	 	\
 	 	 	data[id]=$0
 	 	 	}
 	 	}
 	}
 	END{
 	 	printf "id\t"  "name\t"  "formula\t"  "similarity\t"  "smiles\t"  "inchi\t"  "inchikey2D\t" \
 	 	\
 	 	"score\t"  "xlogp\t"  "links\n" > "results/fingerid_first_score.tsv"
 	 	\
 	 	for(i=1; i<=max_id; i++)
 	 	 	{
 	 	 	if(data[i]!="")
 	 	 	 	{
 	 	 	 	printf data[i] "\n" >> "results/fingerid_first_score.tsv"
 	 	 	 	}
 	 	 	}
 	 	}' $data_sum

echo "structure_extract results have been successfully assembled into <results/fingerid_sum.tsv> and <results/fingerid_first_score.tsv>";
;;
```

```{r eval = F, echo = T}
###################################
```

```{r eval = F, echo = T}
###################################
```

```{r eval = F, echo = T}
###################################
```

```{r eval = F, echo = T}
###################################
classification_extract_sum)

echo "Run classification_extract_sum.";
	if [ -f temp/Mo_filename ] && [ -f canopus.tsv ] && [ -f canopus_neg.tsv ] && [ -f .format ]
	then
	echo "Project path acknowledged."
	else
	 	until [ -d $projectpath ] && [ -f $projectpath/canopus.tsv ] && [ -f $projectpath/.format ]
	 	do
	 	read -p "Please input the path of the sirius project >>> " projectpath;
	 	done;
	 	cd $projectpath;
	fi;
	
data1="temp/Mo_filename"

data2="canopus.tsv"

data3="canopus_neg.tsv"

datas=$(awk -F $'\t' '
 	{
 	if(getline < $2"/canopus/"$3".fpt"==-1)
 	 	{
 	 	printf ""
 	 	}
 	else
 	 	{
 	 	printf $2"/canopus/"$3".fpt "
 	 	}
 	close($2"/canopus/"$3".fpt")
 	}' $data1)
	
awk -F $'\t' '
 	{
 	if(NR==FNR)
 	 	{
 	 	file[FNR]=$2
 	 	
 	 	mo[$2]=$1
 	 	
 	 	i=split($2,s,"[_]")
 	 	
 	 	the_id[FNR]=s[i]
 	 	
 	 	n=FNR
 	 	}
 	if((FILENAME ~ /'$data2'/))
 	 	{
 	 	if(FNR==1)
 	 	 	{
 	 	 	close("'$data1'")
 	 	 	
 	 	 	printf "Info: data_file name of '$data1' has been input.\n"
 	 	 	
 	 	 	for(i=1; i<=NF; i++)
 	 	 	 	{
 	 	 	 	if(($i ~ /name/))
 	 	 	 	 	{
 	 	 	 	 	col_class=i
 	 	 	 	 	}
 	 	 	 	if(($i ~ /absolute/))
 	 	 	 	 	{
 	 	 	 	 	col_abindex=i
 	 	 	 	 	}
 	 	 	 	}
 	 	 	}
 	 	if(FNR>=2)
 	 	 	{
 	 	 	abindex[1,FNR]=$col_abindex
 	 	 	
 	 	 	class[1,$col_abindex]=$col_class
 	 	 	
 	 	 	rows_data2=FNR
 	 	 	}
 	 	}
 	if((FILENAME ~ /'$data3'/))
 	 	{
 	 	if(FNR==1)
 	 	 	{
 	 	 	close("'$data2'")
 	 	 	
 	 	 	printf "Info: data_file name of '$data2' has been input.\n"
 	 	 	
 	 	 	for(i=1; i<=NF; i++)
 	 	 	 	{
 	 	 	 	if(($i ~ /name/))
 	 	 	 	 	{
 	 	 	 	 	col_class=i
 	 	 	 	 	}
 	 	 	 	if(($i ~ /absolute/))
 	 	 	 	 	{
 	 	 	 	 	col_abindex=i
 	 	 	 	 	}
 	 	 	 	}
 	 	 	}
 	 	if(FNR>=2)
 	 	 	{
 	 	 	abindex[2,FNR]=$col_abindex
 	 	 	
 	 	 	class[2,$col_abindex]=$col_class
 	 	 	
 	 	 	rows_data3=FNR
 	 	 	}
 	 	}
 	if((FILENAME ~ /fpt/))
 	 	{
 	 	if(FNR==1)
 	 	 	{
 	 	 	if(p_filename=="")
 	 	 	 	{
 	 	 	 	close("'$data3'")
 	 	 	 	}
 	 	 	else if(FILENAME!=p_filename)
 	 	 	 	{
 	 	 	 	close(p_filename)
 	 	 	 	
 	 	 	 	printf "Info: data_file name of " p_filename " has been input.\n"
 	 	 	 	}
 	 	 	p_filename=FILENAME
 	 	 	\
 	 	 	for(i=1; i<=n; i++)
 	 	 	 	{
 	 	 	 	if((FILENAME ~ file[i]) && (FILENAME ~ mo[file[i]]))
 	 	 	 	 	{
 	 	 	 	 	break
 	 	 	 	 	}
 	 	 	 	else
 	 	 	 	 	{
 	 	 	 	 	x=i+1
 	 	 	 	 	}
 	 	 	 	}
 	 	 	if(x==n+1)
 	 	 	 	{
 	 	 	 	nextfile
 	 	 	 	}
 	 	 	split(FILENAME,a,"[/]");

 	 	 	m=split(a[1],b,"[_]");

 	 	 	id=b[m];

 	 	 	if((FILENAME ~ /\+.fpt/))
 	 	 	 	{
 	 	 	 	ion=1
 	 	 	 	}
 	 	 	else
 	 	 	 	{
 	 	 	 	ion=2
 	 	 	 	}
 	 	 	pp[id,abindex[ion,2]]=$1
 	 	 	}
 	 	if(FNR>=2)
 	 	 	{
 	 	 	pp[id,abindex[ion,FNR+1]]=$1
 	 	 	}
 	 	}
 	}
 	END{
 	 	if(abindex[1,rows_data2] > abindex[2,rows_data3])
 	 	 	{
 	 	 	maxindex=abindex[1,rows_data2]
 	 	 	}
 	 	else
 	 	 	{
 	 	 	maxindex=abindex[2,rows_data3]
 	 	 	}
 	 	printf "id\t" > "results/canopus_pp.tsv"
 	 	\
 	 	for(i=0; i<=maxindex; i++)
 	 	 	{
 	 	 	if(class[1,i]!="" && i!=maxindex)
 	 	 	 	{
 	 	 	 	printf class[1,i]"\t" >> "results/canopus_pp.tsv"
 	 	 	 	}
 	 	 	else if(class[2,i]!="" && i!=maxindex)
 	 	 	 	{
 	 	 	 	printf class[2,i]"\t" >> "results/canopus_pp.tsv"
 	 	 	 	}
 	 	 	else if(i==maxindex && class[1,i]!="")
 	 	 	 	{
 	 	 	 	printf class[1,i]"\n" >> "results/canopus_pp.tsv"
 	 	 	 	}
 	 	 	else if(i==maxindex && class[2,i]!="")
 	 	 	 	{
 	 	 	 	printf class[2,i]"\n" >> "results/canopus_pp.tsv"
 	 	 	 	}
 	 	 	}
 	 	for(i=1; i<=n; i++)
 	 	 	{
 	 	 	printf the_id[i]"\t" >> "results/canopus_pp.tsv"
 	 	 	
 	 	 	for(j=0; j<=maxindex; j++)
 	 	 	 	{
 	 	 	 	if(class[1,j]!="" && j!=maxindex || class[2,j]!="" && j!=maxindex)
 	 	 	 	 	{
 	 	 	 	 	if(pp[the_id[i],j]=="")
 	 	 	 	 	 	{
 	 	 	 	 	 	printf 0"\t" >> "results/canopus_pp.tsv"
 	 	 	 	 	 	}
 	 	 	 	 	else
 	 	 	 	 	 	{
 	 	 	 	 	 	printf pp[the_id[i],j]"\t" >> "results/canopus_pp.tsv"
 	 	 	 	 	 	}
 	 	 	 	 	}
 	 	 	 	else if(class[1,j]!="" && j==maxindex || class[2,j]!="" && j==maxindex)
 	 	 	 	 	{
 	 	 	 	 	if(pp[the_id[i],j]=="")
 	 	 	 	 	 	{
 	 	 	 	 	 	printf 0"\n" >> "results/canopus_pp.tsv"
 	 	 	 	 	 	}
 	 	 	 	 	else
 	 	 	 	 	 	{
 	 	 	 	 	 	printf pp[the_id[i],j]"\n" >> "results/canopus_pp.tsv"
 	 	 	 	 	 	}
 	 	 	 	 	}
 	 	 	 	}
 	 	 	}
 	 	}' $data1 $data2 $data3 $datas

echo "classification_extract_sum have been successfully written into <results/canopus_pp.tsv>"
;;
```

```{r eval = F, echo = T}
###################################
```

```{r eval = F, echo = T}
###################################
```

```{r eval = F, echo = T}
###################################

classification_extract_filter)
echo "Run classification_extract_filter.";
	if [ -f results/canopus_pp.tsv ]
	then
	echo "Project path acknowledged."
	else
	 	until [ -d $projectpath ] && [ -f $projectpath/results/canopus_pp.tsv ] && [ -f $projectpath/results/canopus_summary.tsv ]
	 	do
	 	read -p "Please input the path of the sirius project >>> " projectpath;
	 	done;
	 	cd $projectpath;
	fi;	
	
check=0
	until [[ "$check" == "yes" ]] || [[ "$check" == "no" ]]
	do
	read -p "Collate the posterior probabilities of the classification of each feature? [yes/no] >>> " check;
	done;
	
	if [[ $check == "yes" ]]
	then
	definition_limit=0
	
	 	until [[ "$definition_limit" > "0.01" ]] && [[ "$definition_limit" < "1" ]]
	 	do
	 	read -p "Please enter the classes posterior probabilities limition. 0.5~0.99 may work well. >>> " definition_limit;
	 	done;
	
	data1="canopus_summary.tsv"
 
 	data2="canopus.tsv"
 
 	data3="results/canopus_pp.tsv"
	
	awk -F $'\t' '
	 	{
	 	if(NR==FNR)
	 	 	{
	 	 	if(FNR==1)
	 	 	 	{
	 	 	 	p_file=FILENAME
	 	 	 	\
	 	 	 	for(i=1; i<=NF; i++)
	 	 	 	 	{
	 	 	 	 	if($i~/name/)
	 	 	 	 	 	{
	 	 	 	 	 	col_id=i
	 	 	 	 	 	}
	 	 	 	 	if($i~/specific/)
	 	 	 	 	 	{
	 	 	 	 	 	col_specific=i
	 	 	 	 	 	}
	 	 	 	 	if($i~/level/)
	 	 	 	 	 	{
	 	 	 	 	 	col_level=i
	 	 	 	 	 	}
	 	 	 	 	if($i~/subclass/)
	 	 	 	 	 	{
	 	 	 	 	 	col_subclass=i
	 	 	 	 	 	}
	 	 	 	 	if($i~/^class/)
	 	 	 	 	 	{
	 	 	 	 	 	col_class=i
	 	 	 	 	 	}
	 	 	 	 	if($i~/superclass/)
	 	 	 	 	 	{
	 	 	 	 	 	col_superclass=i
	 	 	 	 	 	}
	 	 	 	 	}
	 	 	 	}
	 	 	if(FNR>=2)
	 	 	 	{
	 	 	 	n=split($col_id,a,"[_]")
	 	 	 	\
	 	 	 	id=a[n]
	 	 	 	\
	 	 	 	specific[id]=$col_specific
	 	 	 	\
	 	 	 	level[id]=$col_level
	 	 	 	\
	 	 	 	subclass[id]=$col_subclass
	 	 	 	\
	 	 	 	class[id]=$col_class
	 	 	 	\
	 	 	 	superclass[id]=$col_superclass
	 	 	 	}
	 	 	}
	 	if(FILENAME~/canopus.tsv/)
	 	 	{
	 	 	if(FNR==1)
	 	 	 	{
	 	 	 	close(p_file)
	 	 	 	\
	 	 	 	p_file=FILENAME
	 	 	 	\
	 	 	 	for(i=1; i<=NF; i++)
	 	 	 	 	{
	 	 	 	 	if($i~/name/)
	 	 	 	 	 	{
	 	 	 	 	 	col_name=i
	 	 	 	 	 	}
	 	 	 	 	if($i~/description/)
	 	 	 	 	 	{
	 	 	 	 	 	col_description=i
	 	 	 	 	 	}
	 	 	 	 	}
	 	 	 	}
	 	 	if(FNR>=2)
	 	 	 	{
	 	 	 	description[$col_name]=$col_description
	 	 	 	}
	 	 	}
	 	if(FILENAME~"'$data3'")
	 	 	{
	 	 	if(FNR==1)
	 	 	 	{
	 	 	 	close(p_file)
	 	 	 	\
	 	 	 	for(i=1; i<=NF; i++)
	 	 	 	 	{
	 	 	 	 	if($i~/^id$/)
	 	 	 	 	 	{
	 	 	 	 	 	col_id=i
	 	 	 	 	 	}
	 	 	 	 	if(i>=2)
	 	 	 	 	 	{
	 	 	 	 	 	col_class_name[i]=$i
	 	 	 	 	 	}
	 	 	 	 	}
	 	 	 	printf "id\t"  "definition_source\t"  "definition\t"  "definition_pp\t"  "definition_description\t" \
	 	 	 	\
	 	 	 	"specific\t"  "specific_pp\t"  "level_5\t"  "level_5_pp\t" \
	 	 	 	\
	 	 	 	"subclass\t"  "subclass_pp\t"  "class\t"  "class_pp\t"  "superclass\t"  "superclass_pp\n" \
	 	 	 	\
	 	 	 	> "results/stat_classification.tsv"
	 	 	 	}
	 	 	if(FNR>=2)
	 	 	 	{
	 	 	 	for(i=2; i<=NF; i++)
	 	 	 	 	{
	 	 	 	 	c_pp[col_class_name[i]]=sprintf("%.4f",$i)
	 	 	 	 	}
	 	 	 	if(level[$col_id] != "" && c_pp[level[$col_id]] >= "'$definition_limit'")
	 	 	 	 	{
	 	 	 	 	definition_source="level_5"
	 	 	 	 	\
	 	 	 	 	definition=level[$col_id]
	 	 	 	 	}
	 	 	 	else if(subclass[$col_id] != "" && c_pp[subclass[$col_id]] >= "'$definition_limit'")
	 	 	 	 	{
	 	 	 	 	definition_source="subclass"
	 	 	 	 	\
	 	 	 	 	definition=subclass[$col_id]
	 	 	 	 	}
	 	 	 	else if(class[$col_id] != "" && c_pp[class[$col_id]] >= "'$definition_limit'")
	 	 	 	 	{
	 	 	 	 	definition_source="class"
	 	 	 	 	\
	 	 	 	 	definition=class[$col_id]
	 	 	 	 	}
	 	 	 	else if(superclass[$col_id] != "" && c_pp[superclass[$col_id]] >= "'$definition_limit'")
	 	 	 	 	{
	 	 	 	 	definition_source="superclass"
	 	 	 	 	\
	 	 	 	 	definition=superclass[$col_id]
	 	 	 	 	}
	 	 	 	else
	 	 	 	 	{
	 	 	 	 	definition_source="null"
	 	 	 	 	\
	 	 	 	 	definition="null"
	 	 	 	 	\
	 	 	 	 	c_pp[definition]="null"
	 	 	 	 	\
	 	 	 	 	description[definition]="null"
	 	 	 	 	}
	 	 	 	printf $col_id"\t"  definition_source"\t"  definition"\t"  c_pp[definition]"\t"  description[definition]"\t" \
	 	 	 	\
	 	 	 	specific[$col_id]"\t"  c_pp[specific[$col_id]]"\t"  level[$col_id]"\t"  c_pp[level[$col_id]]"\t" \
	 	 	 	\
	 	 	 	subclass[$col_id]"\t"  c_pp[subclass[$col_id]]"\t"  class[$col_id]"\t"  c_pp[class[$col_id]]"\t" \
	 	 	 	\
	 	 	 	superclass[$col_id]"\t"  c_pp[superclass[$col_id]]"\n" >> "results/stat_classification.tsv"
	 	 	 	}
	 	 	}
	 	}' $data1 $data2 $data3
 	
 	echo "classification_extract_filter have been successfully written into <results/stat_classification.tsv>"
 	
 	fi;
;;
```

```{r eval = F, echo = T}
###################################
```

```{r eval = F, echo = T}
###################################
```

```{r eval = F, echo = T}
###################################
```

```{r eval = F, echo = T}
###################################
fragment_tree_network)

echo "Run fragment_tree_network.";

	if [ -d temp ] && [ -f ftalign.tsv ] && [ -f .format ]
	then
	echo "Project path acknowledged."
	
	else
	 	until [ -d $projectpath ] && [ -f $projectpath/ftalign.tsv ] && [ -f $projectpath/.format ]
	 	do
	 	read -p "Please input the path of the sirius project. Make sure you have moved the fragment tree alignment results to the directory where the project is located. >>> " projectpath;
	 	done;
	 	cd $projectpath;
	fi;

echo "Please enter the minimum alignment similarity(tlimit) that you want to filter."

tlimit=0
	until [[ "$tlimit" > "0.01" ]] && [[ "$tlimit" < "0.99" ]]
	do
	read -p "0.4-0.7 is recommended >>> " tlimit;
	done;

 	if ! [ -d temp/ftaligntemp ]
	then 
	mkdir temp/ftaligntemp
 	fi;
 	
data="ftalign.tsv"

savepath="temp/ftaligntemp/tmp"

awk -F $'\t' -v OFS=$'\t' '
 	{
 	print NR,FNR
 	
 	if(NR==FNR)
 	 	{
	 	for(i=1; i<=NF; i++)
	 	 	{
	 	 	if(NR==1 && i!=1 || NR!=1 && i==1)
	 	 	 	{
	 	 	 	n=split($i,x,"[_]")
	 	 	 	\
	 	 	 	raw[NR,i]=x[n]
	 	 	 	}
	 	 	else
	 	 	 	{
	 	 	 	if(NR==i)
	 	 	 	 	{
	 	 	 	 	raw_norm[NR,i]=$i
	 	 	 	 	}
	 	 	 	}
	 	 	}
	 	}
	if(NR>FNR && FNR>=2)
	 	{
	 	for(i=2; i<=NF; i++)
	 	 	{
	 	 	norm1=${i}/raw_norm[i,i]
	 	 	 	
	 	 	norm2=${i}/raw_norm[FNR,FNR]
	 	 	 	
	 	 	norms=sprintf("%.2f", ((norm1+norm2)/2))
	 	 	
	 	 	if((norms+0 > '$tlimit'+0) && (norms+0 < 1+0))
	 	 	 	{
	 	 	 	if(raw[FNR,1]+0>=raw[1,i]+0)
	 	 	 	 	{
	 	 	 	 	print raw[FNR,1], raw[1,i], norms > "'$savepath'"
	 	 	 	 	}
	 	 	 	if(raw[FNR,1]+0<raw[1,i]+0)
	 	 	 	 	{
	 	 	 	 	print raw[1,i], raw[FNR,1], norms > "'$savepath'"
	 	 	 	 	}
	 	 	 	}
	 	 	}
	 	}
 	}' $data $data

sort -u $savepath > temp/ftaligntemp/filter_net_$tlimit

echo "fragment_tree_network have been successfully written into <temp/ftaligntemp/filter_net_$tlimit>"
;;

```

```{r eval = F, echo = T}
###################################
```

```{r eval = F, echo = T}
###################################
```

```{r eval = F, echo = T}
###################################
```

```{r eval = F, echo = T}
###################################

fragment_tree_network_delta)

	if [ -d temp ] && [ -f ftalign.tsv ] && [ -f .format ]
	then
	echo "Project path acknowledged."
	else
	 	until [ -d $projectpath ] && [ -f $projectpath/ftalign.tsv ] && [ -f $projectpath/.format ]
	 	do
	 	read -p "Please input the path of the sirius project >>> " projectpath;
	 	done;
	cd $projectpath;
	fi;
echo "The following module attempts to compute the differential fingerprints of connected clusters based on the molecular fingerprint results of sirius 4."

```

```{r eval = F, echo = T}
###################
```

```{r eval = F, echo = T}
###################
```

```{r eval = F, echo = T}
###################

plimit=0
	until [[ "$plimit" > "0.5" ]] && [[ "$plimit" < "0.99" ]]
	do
	read -p "If the minimum alignment similarity is greater than 0.3, this step will automatic calculate the discrepancy fingerprint between alignment features(in beta). Please enter the minimum posterior probability of the molecular fingerprint(plimit_1) to be filtered. 0.9-0.99 is recommended. >>> " plimit;
	done;

plimit2=0
	until [[ "$plimit2" > "0.1" ]] && [[ "$plimit2" < "$plimit" ]]
	do
	read -p "The minimum posterior probability of the molecular fingerprint(plimit_2) to be controled. 0.1-0.5 may work well. >>> " plimit2;
	done;
	
tlimit=$(ls temp/ftaligntemp/filter_net_* | awk -F _ '{print $NF}')

check_rep=$(awk 'END{print NR}' <(echo "$tlimit"))

	if [[ "$check_rep" > "1" ]]
	then
	tlimit=0
	 	until [ -f temp/ftaligntemp/filter_net_$tlimit ]
	 	do
	 	read -p "Plural and different fragment_tree_network files were found to exist locally. Please select a tlimit parameter you have utilized to run fragment_tree_network_delta. >>> " tlimit;
	 	done;
	fi;
	
	
	if [ -f temp/ftaligntemp/refilter_net_$tlimit ]
	then rm temp/ftaligntemp/refilter_net_$tlimit
	fi;
	
	if [ -f temp/ftaligntemp/fpsample ]
	then rm temp/ftaligntemp/fpsample
	fi;

echo "Running delta_fingerprint computation..."

echo "Aquiring data from sirius index..."

data1="*_*/compound.info"

data2="temp/ftaligntemp/filter_net_$tlimit"

echo "Run fragment_tree_network_delta."

savepath="temp/ms_data_$tlimit"

echo "step 1: ms data"

 	if ! [ -f $savepath ]
 	then

	awk -F "[\t]||[:]||[_]" -v OFS=$'\t' '

	 	BEGIN{  
	 	 	printf "..."
	 	 	
	 	 	printf "id\t"  "m/z\t"  "rt\n" > "results/mz_and_rt.tsv"
	 	 	}
	 	{
	 	if(FILENAME~/compound.info/)
	 	 	{
	 	 	if(FNR==1)
	 	 	 	{
	 	 	 	printf "Info: catch >>> "FILENAME"\n"
	 	 	 	}
	 	 	if($1=="name")
	 	 	 	{
	 	 	 	i+=1;
	 	 	 	
	 	 	 	id[i]=$NF;
	 	 	 	
	 	 	 	n=split($NF,a,"[_]")
	 	 	 	
	 	 	 	printf a[n]"\t" >> "results/mz_and_rt.tsv"
	 	 	 	}
	 	 	if($1=="ionMass")
	 	 	 	{
	 	 	 	mz[id[i]]=$NF
	 	 	 	
	 	 	 	printf sprintf("%.4f",$NF)"\t" >> "results/mz_and_rt.tsv"
	 	 	 	}
	 	 	if($1=="ionType")
	 	 	 	{
	 	 	 	type[id[i]]=$NF
	 	 	 	}
	 	 	if($1=="rt")
	 	 	 	{
	 	 	 	rt[id[i]]=$2;
	 	 	 	
	 	 	 	printf sprintf("%.2f",$2/60)"\n" >> "results/mz_and_rt.tsv"
	 	 	 	}
	 	 	}
	 	if(FILENAME~/ftaligntemp/)
	 	 	{
	 	 	#source  target  ftalign  delta_mz  delta_rt  source_iontype  target_iontype;
	 	 	
	 	 	if(FNR==1)
	 	 	 	{
	 	 	 	printf "" > "'$savepath'"
	 	 	 	}
	 	 	print $1,$2,$3,sprintf("%.3f",mz[$2]-mz[$1]),sprintf("%.2f",rt[$2]-rt[$1]),type[$1],type[$2] \
	 	 	\
	 	 	>> "'$savepath'"
	 	 	}
	 	}' $data1 $data2
	 fi;

```

```{r eval = F, echo = T}
########################

echo "step 2: data path"

source_file="temp/Mo_filename"

data="temp/ms_data_$tlimit"

savepath="temp/datapath_$tlimit"

 	if ! [ -f $savepath ]
 	then
 	
	awk -F $'\t' -v OFS=$'\t' '
	 	{
	 	if(NR==FNR)
	 	 	{
	 	 	n=split($2, a, "[_]")
	 	 	
	 	 	file[a[n]]=$2
	 	 	
	 	 	formu_type[a[n]]=$3
	 	 	}
	 	if(NR!=FNR)
	 	 	{
	 	 	#<path>sourceFormula  <path>targetFormula
	 	 	
	 	 	path1=file[$1]"/fingerprints/"formu_type[$1]".fpt"
	 	 	
	 	 	path2=file[$2]"/fingerprints/"formu_type[$2]".fpt"
	 	 	
	 	 	data[path1]=path1
	 	 	
	 	 	data[path2]=path2
	 	 	}
	 	}
	 	END{
	 	 	for(i in data)
	 	 	 	{
	 	 	 	n+=1
	 	 	 	
	 	 	 	print "Check file:",n
	 	 	 	
	 	 	 	if(getline<i==-1)
	 	 	 	 	{
	 	 	 	 	printf "Escape filename: " i "\n"
	 	 	 	 	}
	 	 	 	else
	 	 	 	 	{
	 	 	 	 	printf i" " > "'$savepath'"
	 	 	 	 	}
	 	 	 	close(i)
	 	 	 	}
	 	 	print "Sum:",n
	 	 	
	 	 	}' $source_file $data
  	fi;
  	
datapath=$(cat temp/datapath_$tlimit)

echo "step 3: fingerprint"
 	
data_allfp="temp/data_allfp_$tlimit"

 	if ! [ -f $data_allfp ]
 	then
 	
	awk -F $'\t' '
	 	BEGIN{
	 	 	n=0
	 	 	}
	 	{
	 	if(FNR==1)
	 	 	{
	 	 	if(n>1)
	 	 	 	{
	 	 	 	close(file)
	 	 	 	}
	 	 	file=FILENAME;
	 	 	
	 	 	print "Get fingerprints: ",FILENAME
	 	 	
	 	 	n+=1;
	 	 	
	 	 	printf FILENAME"\n"$0"\n" > "'$data_allfp'"
	 	 	}
	 	else
	 	 	{
	 	 	print $0 > "'$data_allfp'"
	 	 	}
	 	}' $datapath
	 	
 	fi;

```

```{r eval = F, echo = T}
###########################


awk -F $'\t' -v OFS=$'\t' '
 	{
 	if(NR==1)
 	 	{
 	 	for(i=1; i<=NF; i++)
 	 	 	{
 	 	 	if($i~/absolute/)
 	 	 	 	{
 	 	 	 	col_index=i
 	 	 	 	}
 	 	 	if($i~/description/)
 	 	 	 	{
 	 	 	 	col_description=i
 	 	 	 	}
 	 	 	}
 	 	}
 	if(NR>=2)
 	 	{
 	 	print $col_index,$col_description
 	 	}
 	}' csi_fingerid.tsv > temp/ftaligntemp/pos_fingerprint_index;

awk -F $'\t' -v OFS=$'\t' '
 	{
 	if(NR==1)
 	 	{
 	 	for(i=1; i<=NF; i++)
 	 	 	{
 	 	 	if($i~/absolute/)
 	 	 	 	{
 	 	 	 	col_index=i
 	 	 	 	}
 	 	 	if($i~/description/)
 	 	 	 	{
 	 	 	 	col_description=i
 	 	 	 	}
 	 	 	}
 	 	}
 	if(NR>=2)
 	 	{
 	 	print $col_index,$col_description
 	 	}
 	}' csi_fingerid_neg.tsv > temp/ftaligntemp/neg_fingerprint_index;

posindex="temp/ftaligntemp/pos_fingerprint_index"

negindex="temp/ftaligntemp/neg_fingerprint_index"

data="temp/ms_data_$tlimit"

echo "step 4: merge data"

awk -F $'\t' '
 	BEGIN{
 	 	file=0
 	 	x=0
 	 	count=0
 	 	f=0
 	 	posnum=0
 	 	negnum=0
 	 	}
 	{
 	if(FNR==1)
 	 	{
 	 	file+=1
 	 	}
 	if(NR==FNR)
 	 	{
 	 	if(($1~/fingerprint/))
 	 	 	{
 	 	 	if(x+0>f+0)
 	 	 	 	{
 	 	 	 	f=x  # calculate the max index.
 	 	 	 	}
 	 	 	count+=1;  # calculate the all fingerprints file number.
 	 	 	\
 	 	 	split($1,a,"[/]"); e=split(a[1],b,"[_]"); id=b[e]; #catch the id.
 	 	 	\
 	 	 	x=0;
 	 	 	}
 	 	else
 	 	 	{
 	 	 	x+=1;
 	 	 	\
 	 	 	fp[id,x]=$1;
 	 	 	}
 	 	}
 	if(file==2)
 	 	{
 	 	pos[FNR]=$1
 	 	
 	 	posnum+=1
 	 	}
 	if(file==3)
 	 	{
 	 	neg[FNR]=$1
 	 	
 	 	negnum+=1
 	 	}
 	if(file==4)
 	 	{
 	 	if("'$tlimit'"+0 >= 0.3)
 	 	 	{
	 	 	if(fp[$1,1]!="" && fp[$2,1]!="")
	 	 	 	{
	 	 	 	n1=split($6, g, "[]]");
	 	 	 	
	 	 	 	n2=split($7, h, "[]]");
	 	 	 	
	 	 	 	if(g[n1]=="+" && h[n2]=="+")
	 	 	 	 	{
	 	 	 	 	for(x=1; x<=posnum; x++)
	 	 	 	 	 	{
	 	 	 	 	 	if(fp[$1,x]+0>='$plimit'+0 && fp[$2,x]+0<='$plimit2'+0)
	 	 	 	 	 	 	{
	 	 	 	 	 	 	data_s[FNR,x]=pos[x]
	 	 	 	 	 	 	}
	 	 	 	 	 	else if(fp[$2,x]+0>='$plimit'+0 && fp[$1,x]+0<='$plimit2'+0)
	 	 	 	 	 	 	{
	 	 	 	 	 	 	data_t[FNR,x]=pos[x]
	 	 	 	 	 	 	}
	 	 	 	 	 	}
	 	 	 	 	}
	 	 	 	if(g[n1]=="-" && h[n2]=="-")
	 	 	 	 	{
	 	 	 	 	for(x=1; x<=negnum; x++)
	 	 	 	 	 	{
	 	 	 	 	 	if(fp[$1,x]+0>='$plimit'+0 && fp[$2,x]+0<='$plimit2'+0)
	 	 	 	 	 	 	{
	 	 	 	 	 	 	data_s[FNR,x]=neg[x]
	 	 	 	 	 	 	}
	 	 	 	 	 	else if(fp[$2,x]+0>='$plimit'+0 && fp[$1,x]+0<='$plimit2'+0)
	 	 	 	 	 	 	{
	 	 	 	 	 	 	data_t[FNR,x]=neg[x]
	 	 	 	 	 	 	}
	 	 	 	 	 	}
	 	 	 	 	}
	 	 	 	if(g[n1]=="-" && h[n2]=="+" || h[n2]=="-" && g[n1]=="+")
	 	 	 	 	{
	 	 	 	 	for(i=1; i<=posnum; i++)
	 	 	 	 	 	{
	 	 	 	 	 	for(j=1; j<=negnum; j++)
	 	 	 	 	 	 	{
	 	 	 	 	 	 	if(pos[i]==neg[j])
	 	 	 	 	 	 	 	{
	 	 	 	 	 	 	 	mirror[i]=j 	#if pos=i, the identical index of neg is mirror[i]
	 	 	 	 	 	 	 	}
	 	 	 	 	 	 	}
	 	 	 	 	 	}
	 	 	 	 	}
	 	 	 	if(g[n1]=="-" && h[n2]=="+")	
	 	 	 	 	{
	 	 	 	 	for(x=1; x<=f; x++)
	 	 	 	 	 	{
	 	 	 	 	 	if(fp[$1,mirror[x]]+0>='$plimit'+0 && fp[$2,x]+0<='$plimit2'+0)
	 	 	 	 	 	 	{
	 	 	 	 	 	 	data_s[FNR,x]=neg[mirror[x]]
	 	 	 	 	 	 	}
	 	 	 	 	 	else if(fp[$2,x]+0>='$plimit'+0 && fp[$1,mirror[x]]+0<='$plimit2'+0)
	 	 	 	 	 	 	{
	 	 	 	 	 	 	data_t[FNR,x]=neg[mirror[x]]
	 	 	 	 	 	 	}
	 	 	 	 	 	}
	 	 	 	 	}
	 	 	 	if(h[n2]=="-" && g[n1]=="+")
	 	 	 	 	{
	 	 	 	 	for(x=1; x<=f; x++)
	 	 	 	 	 	{
	 	 	 	 	 	if(fp[$1,x]+0>= '$plimit'+0 && fp[$2,mirror[x]]+0<='$plimit2'+0)
	 	 	 	 	 	 	{
	 	 	 	 	 	 	data_s[FNR,x]=neg[mirror[x]]
	 	 	 	 	 	 	}
	 	 	 	 	 	else if(fp[$2,mirror[x]]+0>='$plimit'+0 && fp[$1,x]+0<='$plimit2'+0)
	 	 	 	 	 	 	{
	 	 	 	 	 	 	data_t[FNR,x]=neg[mirror[x]]
	 	 	 	 	 	 	}
	 	 	 	 	 	}	 	
	 	 	 	 	}
	 	 	 	}
	 	 	}
 	 	if(FNR==1)
 	 	 	{
 	 	 	printf "source\t"  "target\t"  "ftalign_similarity\t"  "delta_m/z\t"  "source_fp_uniq\t"  "target_fp_uniq\n"
 	 	 	}
 	 	else
 	 	 	{
 	 	 	printf $1"\t"  $2"\t"  $3"\t"  $4"\t";
 	 	 	\
 	 	 	if('$tlimit'+0 >= 0.3)
 	 	 	 	{
	 	 	 	if(fp[$1,1]=="" || fp[$2,1]=="")
	 	 	 	 	{
	 	 	 	 	printf "NA@NA\n"
	 	 	 	 	}
	 	 	 	else
	 	 	 	 	{
	 	 	 	 	printf "source:"  #the source fingerprint uniq.
	 	 	 	 	\
	 	 	 	 	for(x=1; x<=f; x++)
	 	 	 	 	 	{
	 	 	 	 	 	if(data_s[FNR,x]!="")
	 	 	 	 	 	 	{
	 	 	 	 	 	 	printf data_s[FNR,x]","
	 	 	 	 	 	 	}
	 	 	 	 	 	};
	 	 	 	 	printf "@target:"  #the target fingerprint uniq.
	 	 	 	 	\
	 	 	 	 	for(x=1; x<=f; x++)
	 	 	 	 	 	{
	 	 	 	 	 	if(data_t[FNR,x]!="")
	 	 	 	 	 	 	{
	 	 	 	 	 	 	printf data_t[FNR,x]","
	 	 	 	 	 	 	}
	 	 	 	 	 	}
	 	 	 	 	printf "\n"
	 	 	 	 	}
	 	 	 	}
	 	 	else
	 	 	 	{
	 	 	 	printf "NA@NA\n"
	 	 	 	}
 	 	 	}
 	 	}
 	}' $data_allfp $posindex $negindex $data | sed -e 's/,@/\t/g; s/,$//g; s/@/\t/g' \
 	\
 	> results/source_target_tree_$tlimit.tsv;

echo "All instances have written into <results/source_target_tree_$tlimit.tsv>."

```

```{r eval = F, echo = T}
#####################################

echo "step 5: separate child-nebula from parent-nebula."

data="results/stat_classification.tsv"

savepath="temp/filter_0_class.tsv"

awk -F $'\t' '
 	{
 	if(FNR==1)
 	 	{
 	 	for(i=1; i<=NF; i++)
 	 	 	{
 	 	 	if($i~/^definition$/)
 	 	 	 	{
 	 	 	 	col_class=i
 	 	 	 	}
 	 	 	}
 	 	}
 	if(FNR>=2)
 	 	{
 	 	class[$col_class]=$col_class
 	 	}
 	}
 	END{
	 	for(i in class)
 	 	 	{
 	 	 	printf class[i]"\n" > "'$savepath'"
 	 	 	}
 	 	}' $data
 
 ######################################
 
 data1="temp/filter_0_class.tsv" #lignans and iridoids
 
 data2="results/canopus_pp.tsv"
 
 data3="results/fingerid_first_score.tsv"

	until [[ "$similarity_limit" > 0 ]] && [[ "$similarity_limit" < 1 ]]
	do
	read -p "Please set the Tanimoto similarity threshold contribute to child-nebula. >>> " similarity_limit;
	done;
 
 	until [[ "$definition_limit" > 0.01 ]] && [[ "$definition_limit" < 1 ]]
 	do
 	read -p "Please enter the classes posterior probabilities limition. 0.5~0.99 may work well. >>> " definition_limit;
 	done;
 
 class_pp_limit=$definition_limit
 
 savepath="temp/idenfication_filter_$class_pp_limit.tsv"
 
 awk -F $'\t' '
  	{
  	if(NR==FNR)
  	 	{
  	 	filter_class[$1]=$1
  	 	}
  	if(FILENAME~/canopus/)
  	 	{
  	 	if(FNR==1)
  	 	 	{
  	 	 	col_id=1
  	 	 	
  	 	 	for(i=2; i<=NF; i++)
  	 	 	 	{
  	 	 	 	for(j in filter_class)
  	 	 	 	 	{
  	 	 	 	 	if(j==$i)
  	 	 	 	 	 	{
  	 	 	 	 	 	col_class[j]=i
  	 	 	 	 	 	
  	 	 	 	 	 	print i
  	 	 	 	 	 	}
  	 	 	 	 	}
  	 	 	 	}
  	 	 	}
  	 	if(FNR>=2)
  	 	 	{
  	 	 	for(i in col_class)
  	 	 	 	{
  	 	 	 	if(sprintf("%.3f",$col_class[i])+0>="'$class_pp_limit'"+0)
  	 	 	 	 	{
  	 	 	 	 	class_set[i,$col_id]=i
  	 	 	 	 	
  	 	 	 	 	print "ID: ",$1,i,$col_class[i]
  	 	 	 	 	}
  	 	 	 	}
  	 	 	}
  	 	}
  	if(FILENAME~/fingerid_first_score/)
  	 	{
  	 	if(FNR==1)
  	 	 	{
  	 	 	for(i=1; i<=NF; i++)
  	 	 	 	{
  	 	 	 	if($i~/^id/)
	 	 	 	 	{
	 	 	 	 	col_id=i
	 	 	 	 	}
	 	 	 	if($i~/similarity/)
	 	 	 	 	{
	 	 	 	 	col_similarity=i
	 	 	 	 	}
  	 	 	 	}
  	 	 	printf "class_nebula_facet\t"  $0"\n" > "'$savepath'"
  	 	 	}
  	 	if(FNR>=2)
  	 	 	{
  	 	 	if($col_similarity+0 >= "'$similarity_limit'"+0)
  	 	 	 	{
	  	 	 	for(i in class_set)
	  	 	 	 	{
	  	 	 	 	if(i~"\034"$col_id"$")
	  	 	 	 	 	{
	  	 	 	 	 	printf class_set[i]"\t"  $0"\n" > "'$savepath'"
	  	 	 	 	 	}
	  	 	 	 	}
	  	 	 	}
  	 	 	}
  	 	}
  	}' $data1 $data2 $data3
  	
```

```{r eval = F, echo = T}
###################################
 
 data="temp/idenfication_filter_$class_pp_limit.tsv"
 
 savepath="temp/idenfication_filter2_${class_pp_limit}.tsv"
 
 	until [[ "$num_limit" -gt 0 ]]
 	do
 	read -p "Please enter the features number threshold contribute to child-nebula. >>> " num_limit;
 	done;
 
 awk -F $'\t' '
  	{
  	if(FNR==1)
  	 	{
  	 	printf $0"\n" > "'$savepath'"
  	 	
  	 	for(i=1; i<=NF; i++)
  	 	 	{
  	 	 	if($i~/class_nebula_facet/)
  	 	 	 	{
  	 	 	 	col_class=i
  	 	 	 	}
  	 	 	}
  	 	}
	if(FNR>=2)
	 	{
	 	num[$col_class]+=1
  	 	
	 	data[FNR]=$0
	 	
  	 	class[FNR]=$col_class
	 	}
 	}
  	END{
  	 	for(i in num)
  	 	 	{
  	 	 	print num[i]	
  	 	 	if(num[i] >= '$num_limit')
  	 	 	 	{
  	 	 	 	for(j in class)
  	 	 	 	 	{
  	 	 	 	 	if(class[j]==i)
  	 	 	 	 	 	{
  	 	 	 	 	 	printf data[j]"\n" >> "'$savepath'"
  	 	 	 	 	 	}
  	 	 	 	 	}
  	 	 	 	}
  	 	 	}
  	 	}' $data
 
 ##################################
 
 mkdir results/network_facet_$class_pp_limit
 
 data1="temp/idenfication_filter2_${class_pp_limit}.tsv"
 
 data2="results/source_target_tree_$tlimit.tsv" # "results/source_target_tree_0.4.tsv"
 
 save_class="results/filter_child_class.tsv"
 
 savepath="results/network_facet_$class_pp_limit/"
 
 awk -F $'\t' '
  	{
  	if(NR==FNR)
  	 	{
  	 	if(FNR==1)
  	 	 	{
  	 	 	for(i=1; i<=NF; i++)
  	 	 	 	{
  	 	 	 	if($i~/class_nebula_facet/)
  	 	 	 	 	{
  	 	 	 	 	col_class=i
  	 	 	 	 	}
  	 	 	 	if($i~/^id$/)
  	 	 	 	 	{
  	 	 	 	 	col_id=i
  	 	 	 	 	}
  	 	 	 	}
  	 	 	}
  	 	if(FNR>=2)
  	 	 	{
  	 	 	class[$col_class]=$col_class
  	 	 	
  	 	 	class_id[$col_class,$col_id]=$col_id
  	 	 	
  	 	 	stat_id[$col_class,$col_id]=$col_id
  	 	 	
  	 	 	belong[$col_class,$col_id]=$col_class
  	 	 	}
  	 	}
  	if(NR>FNR)
  	 	{
  	 	if(FNR==1)
  	 	 	{
  	 	 	for(i in class)
  	 	 	 	{
  	 	 	 	printf i"\n" > "'$save_class'"
  	 	 	 	
  	 	 	 	printf $0"\t"  "facet\n" > "'$savepath'" i ".tsv"
  	 	 	 	}
  	 	 	}
  	 	if(FNR>=2)
  	 	 	{
  	 	 	for(i in class)
  	 	 	 	{
  	 	 	 	if( class_id[i,$1]==$1 && class_id[i,$2]==$2 )
  	 	 	 	 	{
  	 	 	 	 	printf $0"\t"  i"\n" >> "'$savepath'" i ".tsv"
  	 	 	 	 	
  	 	 	 	 	delete stat_id[i,$1]
  	 	 	 	 	
  	 	 	 	 	delete stat_id[i,$2]
  	 	 	 	 	}
  	 	 	 	}
  	 	 	}
  	 	}
  	}
  	END{
  	 	for(i in stat_id)
  	 	 	{
  	 	 	## source target similarity delta_mz fp fp class
  	 	 	
  	 	 	printf stat_id[i]"\t" stat_id[i]"\t"  "1\t"  "0\t"  "null\t"  "null\t"  belong[i]"\n" \
  	 	 	\
  	 	 	>> "'$savepath'" belong[i] ".tsv"
  	 	 	}
  	 	}' $data1 $data2
 
;;
```

```{r eval = F, echo = T}
###################################
```

```{r eval = F, echo = T}
###################################
compound_idenfication)

echo "Run compound_idenfication."







echo "compound_idenfication "

exit

;;
```

```{r eval = F, echo = T}
###################################
```

```{r eval = F, echo = T}
###################################
double_ion_network)

exit;

;;

```

```{r eval = F, echo = T}
###################################
```

```{r eval = F, echo = T}
###################################
```

```{r eval = F, echo = T}
###################################
```

```{r eval = F, echo = T}
###################################
exit)
echo "The mystery of creation is like the darkness of night--it is great.
Delusions of knowledge are like the fog of the morning."
exit;
;;
```

```{r eval = F, echo = T}
###################################
```

```{r eval = F, echo = T}
###################################
```

```{r eval = F, echo = T}
###################################
```

```{r eval = F, echo = T}
###################################
*)
echo "error"
exit;
;;
esac;
done;#(for)
done;#(select)

```

# File: mcnebula1110.sh

```{r eval = F, echo = T}
##########################
```

```{r eval = F, echo = T}
##########################
echo "We are all in the gutter, 
but some of us are looking at the stars.";
PS3='Please select the workflow to be executed. >>> '
select command in \
   \
  "default" \
  \
  "structure_extract" \
  \
  "classification_extract_sum" \
  \
  "classification_extract_filter" \
  \
  "fragment_tree_network" \
  \
  "fragment_tree_network_delta" \
  \
  "compound_idenfication" \
  \
  "double_ion_network" \
  \
  "exit" 
do
 if [[ $command == "default" ]]
 then
 confirm=0
   until [[ $confirm == "yes" ]] || [[ $confirm == "no" ]]
   do
   read -p "Running all proccesses sequentially? [yes/no] >>> " confirm
   done;
   if [[ $confirm == "no" ]]
   then exit
   fi;
 default="structure_extract classification_extract_sum classification_extract_filter fragment_tree_network fragment_tree_network_delta"
 list=$(echo $default);
 else list=$( echo $command)
 fi;
 for option in $(echo $list)
 do
   case $option in
```

```{r eval = F, echo = T}
###################################
```

```{r eval = F, echo = T}
###################################
```

```{r eval = F, echo = T}
###################################
```

```{r eval = F, echo = T}
###################################
structure_extract)
echo "Run structure_extract."
projectpath=0
 until [ -d $projectpath ] && [ -f $projectpath/canopus_summary.tsv ] && [ -f $projectpath/.format ]
 do
 read -p "Please input the path of the sirius project >>> " projectpath;
 done;
cd $projectpath;
mkdir results;
mkdir temp;
mkdir temp/fintemp;
 if [ -f temp/Mo_filename ]
 then rm temp/Mo_filename
 fi;
data="*_*/fingerid/*.tsv"
awk -F $'\t' '
  BEGIN{
    all_id=0
    \
    max_id=-1
    \
    p_id="null"
    \
    printf "Info: loading the data..."
    }
  {
  if(FNR==1)
    {
    if(NR>FNR)
      {
      close(pfile)
      }
    f=split(FILENAME,a,"[/]");
    n=split(a[1],b,"[_]");
    id=b[n];
    if(id!=p_id)
      {
      all_id+=1
      \
      if(id>max_id)
        {
        max_id=id
        }
      }
    file[id]=a[1]
    split(a[f], g, "[.]")
    formu_type[id]=g[1]
    if(all_id==1)
      {
      for(i=1; i<=NF; i++)
        {
        if(($i~/inchikey2D/))
          {
          col_2D=i
          }
        if($i=="inchi")
          {
          col_inchi=i
          }
        if(($i~/Formula/))
          {
          col_formu=i
          }
        if($i=="score")
          {
          col_score=i
          }
        if($i=="name")
          {
          col_name=i
          }
        if($i=="smiles")
          {
          col_smiles=i
          }
        if($i=="xlogp")
          {
          col_x=i
          }
        if(($i~/imilarity/))
          {
          col_simi=i
          }
        if($i~/links/)
          {
          col_links=i
          }
        }
      }
    pfile=FILENAME
    printf g[1]"\t"formu_type[id]"\n"
    printf "Info: the data of " id " (ID) has input. The filename is " FILENAME ".\n"
    }
  if(FNR>=2)
    {
    row_score=$col_score
    row_simi=$col_simi
    if(max["score",id]=="" || max["score",id]+0<row_score+0)
     {
      max["score",id]=row_score
      name["score",id]=$col_name
      formula["score",id]=$col_formu
      simi["score",id]=$col_simi
      smiles["score",id]=$col_smiles
      inchi["score",id]=$col_inchi
      in2D["score",id]=$col_2D
      score["score",id]=$col_score
      xlogp["score",id]=$col_x
      links["score",id]=$col_links
      }
    if(max["simi",id]=="" || max["simi",id]+0<row_simi+0)
     {
      max["simi",id]=row_simi
      name["simi",id]=$col_name
      formula["simi",id]=$col_formu
      simi["simi",id]=$col_simi
      smiles["simi",id]=$col_smiles
      inchi["simi",id]=$col_inchi
      in2D["simi",id]=$col_2D
      score["simi",id]=$col_score
      xlogp["simi",id]=$col_x
      links["simi",id]=$col_links
      }
    }
  }
  END{
    printf "id\t"  "name\t"  "formula\t"  "similarity\t"  "smiles\t"  "inchi\t"  "inchikey2D\t" \
    \
    "score\t"  "xlogp\t"  "links\n" > "results/fingerid_sum.tsv"
    \
    printf "" > "temp/Mo_filename"
    for(l in file)
      {
      if(max["score",l]!="")
        {
        printf l"\t" \
        \
        name["score",l]"\t"  formula["score",l]"\t"  simi["score",l]"\t" \
        \
        smiles["score",l]"\t"  inchi["score",l]"\t"  in2D["score",l]"\t" \
        \
        score["score",l]"\t"  xlogp["score",l]"\t"  links["score",l]"\n" >> "results/fingerid_sum.tsv"
        printf formula["score",l]"\t"  file[l]"\t"  formu_type[l]"\n" >> "temp/Mo_filename"
        }
      if(max["simi",l]!="" && max["simi",l]!=max["score",l])
        {
        printf l"\t" \
        \
        name["simi",l]"\t"  formula["simi",l]"\t"  simi["simi",l]"\t" \
        \
        smiles["simi",l]"\t"  inchi["simi",l]"\t"  in2D["simi",l]"\t" \
        \
        score["simi",l]"\t"  xlogp["simi",l]"\t"  links["simi",l]"\n" >> "results/fingerid_sum.tsv"
        }
      }
    }' $data
data_sum="results/fingerid_sum.tsv"
awk -F $'\t' '
  {
  if(NR==1)
    {
    for(i=1; i<=NF; i++)
      {
      if($i~/id/)
        {
        col_id=i
        }
      if($i~/score/)
        {
        col_score=i
        }
      }
    }
  if(NR>=2)
    {
    id=$col_id
    \
    if(max_id+0<id || max_id=="")
      {
      max_id=id
      }
    if(score[id]+0<$col_score+0 || score[id]=="")
      {
      score[id]=$col_score
      \
      data[id]=$0
      }
    }
  }
  END{
    printf "id\t"  "name\t"  "formula\t"  "similarity\t"  "smiles\t"  "inchi\t"  "inchikey2D\t" \
    \
    "score\t"  "xlogp\t"  "links\n" > "results/fingerid_first_score.tsv"
    \
    for(i=1; i<=max_id; i++)
      {
      if(data[i]!="")
        {
        printf data[i] "\n" >> "results/fingerid_first_score.tsv"
        }
      }
    }' $data_sum
echo "structure_extract results have been successfully assembled into <results/fingerid_sum.tsv> and <results/fingerid_first_score.tsv>";
;;
```

```{r eval = F, echo = T}
###################################
```

```{r eval = F, echo = T}
###################################
```

```{r eval = F, echo = T}
###################################
```

```{r eval = F, echo = T}
###################################
classification_extract_sum)
echo "Run classification_extract_sum.";
 if [ -f temp/Mo_filename ] && [ -f canopus.tsv ] && [ -f canopus_neg.tsv ] && [ -f .format ]
 then
 echo "Project path acknowledged."
 else
   until [ -d $projectpath ] && [ -f $projectpath/canopus.tsv ] && [ -f $projectpath/.format ]
   do
   read -p "Please input the path of the sirius project >>> " projectpath;
   done;
   cd $projectpath;
 fi;
data1="temp/Mo_filename"
data2="canopus.tsv"
data3="canopus_neg.tsv"
datas=$(awk -F $'\t' '
  {
  x=$2"/canopus/"$3".fpt"
  if(getline < x == 1)
    {
    printf x" "
    }
  close(x)
  }' $data1)
awk -F $'\t' '
  {
  if(NR==FNR)
    {
    file[FNR]=$2
    mo[$2]=$1
    i=split($2,s,"[_]")
    the_id[FNR]=s[i]
    n=FNR
    }
  if((FILENAME ~ /'$data2'/))
    {
    if(FNR==1)
      {
      close("'$data1'")
      printf "Info: data_file name of '$data1' has been input.\n"
      for(i=1; i<=NF; i++)
        {
        if(($i ~ /name/))
          {
          col_class=i
          }
        if(($i ~ /absolute/))
          {
          col_abindex=i
          }
        }
      }
    if(FNR>=2)
      {
      abindex[1,FNR]=$col_abindex
      class[1,$col_abindex]=$col_class
      rows_data2=FNR
      }
    }
  if((FILENAME ~ /'$data3'/))
    {
    if(FNR==1)
      {
      close("'$data2'")
      printf "Info: data_file name of '$data2' has been input.\n"
      for(i=1; i<=NF; i++)
        {
        if(($i ~ /name/))
          {
          col_class=i
          }
        if(($i ~ /absolute/))
          {
          col_abindex=i
          }
        }
      }
    if(FNR>=2)
      {
      abindex[2,FNR]=$col_abindex
      class[2,$col_abindex]=$col_class
      rows_data3=FNR
      }
    }
  if((FILENAME ~ /fpt/))
    {
    if(FNR==1)
      {
      if(p_filename=="")
        {
        close("'$data3'")
        }
      else if(FILENAME!=p_filename)
        {
        close(p_filename)
        printf "Info: data_file name of " p_filename " has been input.\n"
        }
      p_filename=FILENAME
      for(i=1; i<=n; i++)
        {
        if((FILENAME ~ file[i]) && (FILENAME ~ mo[file[i]]))
          {
          break
          }
        else
          {
          x=i+1
          }
        }
      if(x==n+1)
        {
        nextfile
        }
      split(FILENAME,a,"[/]");
      m=split(a[1],b,"[_]");
      id=b[m];
      if(FILENAME ~ /\+.fpt/)
        {
        ion=1
        }
      if(FILENAME ~ /\-.fpt/)
        {
        ion=2
        }
      pp[id,abindex[ion,2]]=$1
      }
    if(FNR>=2)
      {
      pp[id,abindex[ion,FNR+1]]=$1
      }
    }
  }
  END{
    if(abindex[1,rows_data2]+0 > abindex[2,rows_data3]+0)
      {
      maxindex=abindex[1,rows_data2]
      }
    else
      {
      maxindex=abindex[2,rows_data3]
      }
    printf "id\t" > "results/canopus_pp.tsv"
    \
    for(i=0; i<=maxindex; i++)
      {
      if(class[1,i]!="" && i!=maxindex)
        {
        printf class[1,i]"\t" >> "results/canopus_pp.tsv"
        }
      else if(class[2,i]!="" && i!=maxindex)
        {
        printf class[2,i]"\t" >> "results/canopus_pp.tsv"
        }
      else if(i==maxindex && class[1,i]!="")
        {
        printf class[1,i]"\n" >> "results/canopus_pp.tsv"
        }
      else if(i==maxindex && class[2,i]!="")
        {
        printf class[2,i]"\n" >> "results/canopus_pp.tsv"
        }
      }
    for(i=1; i<=n; i++)
      {
      printf the_id[i]"\t" >> "results/canopus_pp.tsv"
      for(j=0; j<=maxindex; j++)
        {
        if(class[1,j]!="" && j!=maxindex || class[2,j]!="" && j!=maxindex)
          {
          if(pp[the_id[i],j]=="")
            {
            printf 0"\t" >> "results/canopus_pp.tsv"
            }
          else
            {
            printf pp[the_id[i],j]"\t" >> "results/canopus_pp.tsv"
            }
          }
        else if(class[1,j]!="" && j==maxindex || class[2,j]!="" && j==maxindex)
          {
          if(pp[the_id[i],j]=="")
            {
            printf 0"\n" >> "results/canopus_pp.tsv"
            }
          else
            {
            printf pp[the_id[i],j]"\n" >> "results/canopus_pp.tsv"
            }
          }
        }
      }
    }' $data1 $data2 $data3 $datas
echo "classification_extract_sum have been successfully written into <results/canopus_pp.tsv>"
;;
```

```{r eval = F, echo = T}
###################################
```

```{r eval = F, echo = T}
###################################
```

```{r eval = F, echo = T}
###################################
classification_extract_filter)
echo "Run classification_extract_filter.";
 if [ -f results/canopus_pp.tsv ]
 then
 echo "Project path acknowledged."
 else
   until [ -d $projectpath ] && [ -f $projectpath/results/canopus_pp.tsv ] && [ -f $projectpath/results/canopus_summary.tsv ]
   do
   read -p "Please input the path of the sirius project >>> " projectpath;
   done;
   cd $projectpath;
 fi; 
check=0
 until [[ "$check" == "yes" ]] || [[ "$check" == "no" ]]
 do
 read -p "Collate the posterior probabilities of the classification of each feature? [yes/no] >>> " check;
 done;
 if [[ $check == "yes" ]]
 then
 definition_limit=0
   until [[ "$definition_limit" > "0.01" ]] && [[ "$definition_limit" < "1" ]]
   do
   read -p "Please enter the classes posterior probabilities limition. 0.5~0.99 may work well. >>> " definition_limit;
   done;
 data1="canopus_summary.tsv"
  data2="canopus.tsv"
  data3="results/canopus_pp.tsv"
 awk -F $'\t' '
   {
   if(NR==FNR)
     {
     if(FNR==1)
       {
       p_file=FILENAME
       \
       for(i=1; i<=NF; i++)
         {
         if($i~/name/)
           {
           col_id=i
           }
         if($i~/specific/)
           {
           col_specific=i
           }
         if($i~/level/)
           {
           col_level=i
           }
         if($i~/subclass/)
           {
           col_subclass=i
           }
         if($i~/^class/)
           {
           col_class=i
           }
         if($i~/superclass/)
           {
           col_superclass=i
           }
         }
       }
     if(FNR>=2)
       {
       n=split($col_id,a,"[_]")
       \
       id=a[n]
       \
       specific[id]=$col_specific
       \
       level[id]=$col_level
       \
       subclass[id]=$col_subclass
       \
       class[id]=$col_class
       \
       superclass[id]=$col_superclass
       }
     }
   if(FILENAME~/canopus.tsv/)
     {
     if(FNR==1)
       {
       close(p_file)
       \
       p_file=FILENAME
       \
       for(i=1; i<=NF; i++)
         {
         if($i~/name/)
           {
           col_name=i
           }
         if($i~/description/)
           {
           col_description=i
           }
         }
       }
     if(FNR>=2)
       {
       description[$col_name]=$col_description
       }
     }
   if(FILENAME~"'$data3'")
     {
     if(FNR==1)
       {
       close(p_file)
       \
       for(i=1; i<=NF; i++)
         {
         if($i~/^id$/)
           {
           col_id=i
           }
         if(i>=2)
           {
           col_class_name[i]=$i
           }
         }
       printf "id\t"  "definition_source\t"  "definition\t"  "definition_pp\t"  "definition_description\t" \
       \
       "specific\t"  "specific_pp\t"  "level_5\t"  "level_5_pp\t" \
       \
       "subclass\t"  "subclass_pp\t"  "class\t"  "class_pp\t"  "superclass\t"  "superclass_pp\n" \
       \
       > "results/stat_classification.tsv"
       }
     if(FNR>=2)
       {
       for(i=2; i<=NF; i++)
         {
         c_pp[col_class_name[i]]=sprintf("%.4f",$i)
         }
       if(level[$col_id] != "" && c_pp[level[$col_id]] >= "'$definition_limit'")
         {
         definition_source="level_5"
         \
         definition=level[$col_id]
         }
       else if(subclass[$col_id] != "" && c_pp[subclass[$col_id]] >= "'$definition_limit'")
         {
         definition_source="subclass"
         \
         definition=subclass[$col_id]
         }
       else if(class[$col_id] != "" && c_pp[class[$col_id]] >= "'$definition_limit'")
         {
         definition_source="class"
         \
         definition=class[$col_id]
         }
       else if(superclass[$col_id] != "" && c_pp[superclass[$col_id]] >= "'$definition_limit'")
         {
         definition_source="superclass"
         \
         definition=superclass[$col_id]
         }
       else
         {
         definition_source="null"
         \
         definition="null"
         \
         c_pp[definition]="null"
         \
         description[definition]="null"
         }
       printf $col_id"\t"  definition_source"\t"  definition"\t"  c_pp[definition]"\t"  description[definition]"\t" \
       \
       specific[$col_id]"\t"  c_pp[specific[$col_id]]"\t"  level[$col_id]"\t"  c_pp[level[$col_id]]"\t" \
       \
       subclass[$col_id]"\t"  c_pp[subclass[$col_id]]"\t"  class[$col_id]"\t"  c_pp[class[$col_id]]"\t" \
       \
       superclass[$col_id]"\t"  c_pp[superclass[$col_id]]"\n" >> "results/stat_classification.tsv"
       }
     }
   }' $data1 $data2 $data3
  echo "classification_extract_filter have been successfully written into <results/stat_classification.tsv>"
  fi;
;;
```

```{r eval = F, echo = T}
###################################
```

```{r eval = F, echo = T}
###################################
```

```{r eval = F, echo = T}
###################################
```

```{r eval = F, echo = T}
###################################
fragment_tree_network)
echo "Run fragment_tree_network.";
 if [ -d temp ] && [ -f ftalign.tsv ] && [ -f .format ]
 then
 echo "Project path acknowledged."
 else
   until [ -d $projectpath ] && [ -f $projectpath/ftalign.tsv ] && [ -f $projectpath/.format ]
   do
   read -p "Please input the path of the sirius project. Make sure you have moved the fragment tree alignment results to the directory where the project is located. >>> " projectpath;
   done;
   cd $projectpath;
 fi;
echo "Please enter the minimum alignment similarity(tlimit) that you want to filter."
tlimit=0
 until [[ "$tlimit" > "0.01" ]] && [[ "$tlimit" < "0.99" ]]
 do
 read -p "0.4-0.7 is recommended >>> " tlimit;
 done;
  if ! [ -d temp/ftaligntemp ]
 then 
 mkdir temp/ftaligntemp
  fi;
data="ftalign.tsv"
savepath="temp/ftaligntemp/tmp"
awk -F $'\t' -v OFS=$'\t' '
  {
  printf "Info: NR = " NR ". FNR = " FNR ".\n"
  if(NR==FNR)
    {
   for(i=1; i<=NF; i++)
     {
     if(NR==1 && i!=1 || NR!=1 && i==1)
       {
       n=split($i,x,"[_]")
       \
       raw[NR,i]=x[n]
       }
     else
       {
       if(NR==i)
         {
         raw_norm[NR,i]=$i
         }
       }
     }
   }
 if(NR>FNR && FNR>=2)
   {
   for(i=2; i<=NF; i++)
     {
     norm1=$i/raw_norm[i,i]
     norm2=$i/raw_norm[FNR,FNR]
     norms=sprintf("%.2f", ((norm1+norm2)/2))
     if((norms+0 > '$tlimit'+0))
       {
       if(raw[FNR,1]+0>=raw[1,i]+0)
         {
         print raw[FNR,1], raw[1,i], norms > "'$savepath'"
         }
       if(raw[FNR,1]+0<raw[1,i]+0)
         {
         print raw[1,i], raw[FNR,1], norms > "'$savepath'"
         }
       }
     }
   }
  }' $data $data
sort -u $savepath > temp/ftaligntemp/tmp2
savepath="temp/ftaligntemp/filter_net_$tlimit"
awk -F $'\t' '
{
  if(NR==FNR)
    {
      if($1!=$2)
        {
          replink[$1]=$1
          replink[$2]=$2
        }
    }
  if(NR!=FNR)
    {
      if($1!=$2)
        {
          printf $0"\n" > "'$savepath'" 
        } 
      if($1==$2)
        {
          if(replink[$1]=="")
            {
              printf $0"\n" > "'$savepath'"
            }
        }
    }
}' temp/ftaligntemp/tmp2 temp/ftaligntemp/tmp2
echo "fragment_tree_network have been successfully written into <temp/ftaligntemp/filter_net_$tlimit>"
;;
```

```{r eval = F, echo = T}
###################################
```

```{r eval = F, echo = T}
###################################
```

```{r eval = F, echo = T}
###################################
```

```{r eval = F, echo = T}
###################################
fragment_tree_network_delta)
 if [ -d temp ] && [ -f ftalign.tsv ] && [ -f .format ]
 then
 echo "Project path acknowledged."
 else
   until [ -d $projectpath ] && [ -f $projectpath/ftalign.tsv ] && [ -f $projectpath/.format ]
   do
   read -p "Please input the path of the sirius project >>> " projectpath;
   done;
 cd $projectpath;
 fi;
echo "The following module attempts to compute the differential fingerprints of connected clusters based on the molecular fingerprint results of sirius 4."
```

```{r eval = F, echo = T}
###################
```

```{r eval = F, echo = T}
###################
```

```{r eval = F, echo = T}
###################
plimit=0
 until [[ "$plimit" > "0.5" ]] && [[ "$plimit" < "0.99" ]]
 do
 read -p "If the minimum alignment similarity is greater than 0.3, this step will automatic calculate the discrepancy fingerprint between alignment features(in beta). Please enter the minimum posterior probability of the molecular fingerprint(plimit_1) to be filtered. 0.9-0.99 is recommended. >>> " plimit;
 done;
plimit2=0
 until [[ "$plimit2" > "0.1" ]] && [[ "$plimit2" < "$plimit" ]]
 do
 read -p "The minimum posterior probability of the molecular fingerprint(plimit_2) to be controled. 0.1-0.5 may work well. >>> " plimit2;
 done;
tlimit=$(ls temp/ftaligntemp/filter_net_* | awk -F _ '{print $NF}')
check_rep=$(awk 'END{print NR}' <(echo "$tlimit"))
 if [[ "$check_rep" > "1" ]]
 then
 tlimit=0
   until [ -f temp/ftaligntemp/filter_net_$tlimit ]
   do
   read -p "Plural and different fragment_tree_network files were found to exist locally. Please select a tlimit parameter you have utilized to run fragment_tree_network_delta. >>> " tlimit;
   done;
 fi;
 if [ -f temp/ftaligntemp/refilter_net_$tlimit ]
 then rm temp/ftaligntemp/refilter_net_$tlimit
 fi;
 if [ -f temp/ftaligntemp/fpsample ]
 then rm temp/ftaligntemp/fpsample
 fi;
echo "Running delta_fingerprint computation..."
echo "Aquiring data from sirius index..."
data1="*_*/compound.info"
data2="temp/ftaligntemp/filter_net_$tlimit"
echo "Run fragment_tree_network_delta."
savepath="temp/ms_data_$tlimit"
echo "step 1: ms data"
  if ! [ -f $savepath ]
  then
 awk -F "[\t]||[:]||[_]" -v OFS=$'\t' '
   BEGIN{  
     printf "..."
     printf "id\t"  "m/z\t"  "rt\n" > "results/mz_and_rt.tsv"
     }
   {
   if(FILENAME~/compound.info/)
     {
     if(FNR==1)
       {
       printf "Info: catch >>> "FILENAME"\n"
       }
     if($1=="name")
       {
       i+=1;
       id[i]=$NF;
       n=split($NF,a,"[_]")
       printf a[n]"\t" >> "results/mz_and_rt.tsv"
       }
     if($1=="ionMass")
       {
       mz[id[i]]=$NF
       printf sprintf("%.4f",$NF)"\t" >> "results/mz_and_rt.tsv"
       }
     if($1=="ionType")
       {
       type[id[i]]=$NF
       }
     if($1=="rt")
       {
       rt[id[i]]=$2;
       printf sprintf("%.2f",$2/60)"\n" >> "results/mz_and_rt.tsv"
       }
     }
   if(FILENAME~/ftaligntemp/)
     {
     #source  target  ftalign  delta_mz  delta_rt  source_iontype  target_iontype;
     if(FNR==1)
       {
       printf "" > "'$savepath'"
       }
     print $1,$2,$3,sprintf("%.3f",mz[$2]-mz[$1]),sprintf("%.2f",rt[$2]-rt[$1]),type[$1],type[$2] \
     \
     >> "'$savepath'"
     }
   }' $data1 $data2
  fi;
```

```{r eval = F, echo = T}
########################
echo "step 2: data path"
source_file="temp/Mo_filename"
data="temp/ms_data_$tlimit"
savepath="temp/datapath_$tlimit"
  if ! [ -f $savepath ]
  then
 awk -F $'\t' -v OFS=$'\t' '
   {
   if(NR==FNR)
     {
     n=split($2, a, "[_]")
     file[a[n]]=$2
     formu_type[a[n]]=$3
     }
   if(NR!=FNR)
     {
     #<path>sourceFormula  <path>targetFormula
     path1=file[$1]"/fingerprints/"formu_type[$1]".fpt"
     path2=file[$2]"/fingerprints/"formu_type[$2]".fpt"
     data[path1]=path1
     data[path2]=path2
     }
   }
   END{
     for(i in data)
       {
       n+=1
       print "Check file:",n
       if(getline<i==-1)
         {
         printf "Escape filename: " i "\n"
         }
       else
         {
         printf i" " > "'$savepath'"
         }
       close(i)
       }
     print "Sum:",n
     }' $source_file $data
   fi;
datapath=$(cat temp/datapath_$tlimit)
echo "step 3: fingerprint"
data_allfp="temp/data_allfp_$tlimit"
  if ! [ -f $data_allfp ]
  then
 awk -F $'\t' '
   BEGIN{
     n=0
     }
   {
   if(FNR==1)
     {
     if(n>1)
       {
       close(file)
       }
     file=FILENAME;
     print "Get fingerprints: ",FILENAME
     n+=1;
     printf FILENAME"\n"$0"\n" > "'$data_allfp'"
     }
   else
     {
     print $0 > "'$data_allfp'"
     }
   }' $datapath
  fi;
```

```{r eval = F, echo = T}
###########################
awk -F $'\t' -v OFS=$'\t' '
  {
  if(NR==1)
    {
    for(i=1; i<=NF; i++)
      {
      if($i~/absolute/)
        {
        col_index=i
        }
      if($i~/description/)
        {
        col_description=i
        }
      }
    }
  if(NR>=2)
    {
    print $col_index,$col_description
    }
  }' csi_fingerid.tsv > temp/ftaligntemp/pos_fingerprint_index;
awk -F $'\t' -v OFS=$'\t' '
  {
  if(NR==1)
    {
    for(i=1; i<=NF; i++)
      {
      if($i~/absolute/)
        {
        col_index=i
        }
      if($i~/description/)
        {
        col_description=i
        }
      }
    }
  if(NR>=2)
    {
    print $col_index,$col_description
    }
  }' csi_fingerid_neg.tsv > temp/ftaligntemp/neg_fingerprint_index;
posindex="temp/ftaligntemp/pos_fingerprint_index"
negindex="temp/ftaligntemp/neg_fingerprint_index"
data="temp/ms_data_$tlimit"
echo "step 4: merge data"
awk -F $'\t' '
  BEGIN{
    file=0
    x=0
    count=0
    f=0
    posnum=0
    negnum=0
    }
  {
  if(FNR==1)
    {
    file+=1
    }
  if(NR==FNR)
    {
    if(($1~/fingerprint/))
      {
      if(x+0>f+0)
        {
        f=x  # calculate the max index.
        }
      count+=1;  # calculate the all fingerprints file number.
      \
      split($1,a,"[/]"); e=split(a[1],b,"[_]"); id=b[e]; #catch the id.
      \
      x=0;
      }
    else
      {
      x+=1;
      \
      fp[id,x]=$1;
      }
    }
  if(file==2)
    {
    pos[FNR]=$1
    posnum+=1
    }
  if(file==3)
    {
    neg[FNR]=$1
    negnum+=1
    }
  if(file==4)
    {
    if("'$tlimit'"+0 >= 0.3)
      {
     if(fp[$1,1]!="" && fp[$2,1]!="")
       {
       n1=split($6, g, "[]]");
       n2=split($7, h, "[]]");
       if(g[n1]=="+" && h[n2]=="+")
         {
         for(x=1; x<=posnum; x++)
           {
           if(fp[$1,x]+0>='$plimit'+0 && fp[$2,x]+0<='$plimit2'+0)
             {
             data_s[FNR,x]=pos[x]
             }
           else if(fp[$2,x]+0>='$plimit'+0 && fp[$1,x]+0<='$plimit2'+0)
             {
             data_t[FNR,x]=pos[x]
             }
           }
         }
       if(g[n1]=="-" && h[n2]=="-")
         {
         for(x=1; x<=negnum; x++)
           {
           if(fp[$1,x]+0>='$plimit'+0 && fp[$2,x]+0<='$plimit2'+0)
             {
             data_s[FNR,x]=neg[x]
             }
           else if(fp[$2,x]+0>='$plimit'+0 && fp[$1,x]+0<='$plimit2'+0)
             {
             data_t[FNR,x]=neg[x]
             }
           }
         }
       if(g[n1]=="-" && h[n2]=="+" || h[n2]=="-" && g[n1]=="+")
         {
         for(i=1; i<=posnum; i++)
           {
           for(j=1; j<=negnum; j++)
             {
             if(pos[i]==neg[j])
               {
               mirror[i]=j  #if pos=i, the identical index of neg is mirror[i]
               }
             }
           }
         }
       if(g[n1]=="-" && h[n2]=="+") 
         {
         for(x=1; x<=f; x++)
           {
           if(fp[$1,mirror[x]]+0>='$plimit'+0 && fp[$2,x]+0<='$plimit2'+0)
             {
             data_s[FNR,x]=neg[mirror[x]]
             }
           else if(fp[$2,x]+0>='$plimit'+0 && fp[$1,mirror[x]]+0<='$plimit2'+0)
             {
             data_t[FNR,x]=neg[mirror[x]]
             }
           }
         }
       if(h[n2]=="-" && g[n1]=="+")
         {
         for(x=1; x<=f; x++)
           {
           if(fp[$1,x]+0>= '$plimit'+0 && fp[$2,mirror[x]]+0<='$plimit2'+0)
             {
             data_s[FNR,x]=neg[mirror[x]]
             }
           else if(fp[$2,mirror[x]]+0>='$plimit'+0 && fp[$1,x]+0<='$plimit2'+0)
             {
             data_t[FNR,x]=neg[mirror[x]]
             }
           }   
         }
       }
     }
    if(FNR==1)
      {
      printf "source\t"  "target\t"  "ftalign_similarity\t"  "delta_m/z\t"  "source_fp_uniq\t"  "target_fp_uniq\n"
      }
    else
      {
      printf $1"\t"  $2"\t"  $3"\t"  $4"\t";
      \
      if('$tlimit'+0 >= 0.3)
        {
       if(fp[$1,1]=="" || fp[$2,1]=="")
         {
         printf "NA@NA\n"
         }
       else
         {
         printf "source:"  #the source fingerprint uniq.
         \
         for(x=1; x<=f; x++)
           {
           if(data_s[FNR,x]!="")
             {
             printf data_s[FNR,x]","
             }
           };
         printf "@target:"  #the target fingerprint uniq.
         \
         for(x=1; x<=f; x++)
           {
           if(data_t[FNR,x]!="")
             {
             printf data_t[FNR,x]","
             }
           }
         printf "\n"
         }
       }
     else
       {
       printf "NA@NA\n"
       }
      }
    }
  }' $data_allfp $posindex $negindex $data | sed -e 's/,@/\t/g; s/,$//g; s/@/\t/g' \
  \
  > results/source_target_tree_$tlimit.tsv;
echo "All instances have written into <results/source_target_tree_$tlimit.tsv>."
```

```{r eval = F, echo = T}
#####################################
echo "step 5: separate child-nebula from parent-nebula."
data="results/stat_classification.tsv"
savepath="temp/filter_0_class.tsv"
awk -F $'\t' '
  {
  if(FNR==1)
    {
    for(i=1; i<=NF; i++)
      {
      if($i~/^definition$/)
        {
        col_class=i
        }
      }
    }
  if(FNR>=2)
    {
    class[$col_class]=$col_class
    }
  }
  END{
   for(i in class)
      {
      printf class[i]"\n" > "'$savepath'"
      }
    }' $data
 ######################################
 data1="temp/filter_0_class.tsv" 
 data2="results/canopus_pp.tsv"
 data3="results/fingerid_first_score.tsv"
 until [[ "$similarity_limit" > 0 ]] && [[ "$similarity_limit" < 1 ]]
 do
 read -p "Please set the Tanimoto similarity threshold contribute to child-nebula. >>> " similarity_limit;
 done;
  until [[ "$definition_limit" > 0.01 ]] && [[ "$definition_limit" < 1 ]]
  do
  read -p "Please enter the classes posterior probabilities limition. 0.5~0.99 may work well. >>> " definition_limit;
  done;
 class_pp_limit=$definition_limit
 savepath="temp/idenfication_filter_$class_pp_limit.tsv"
 awk -F $'\t' '
   {
   if(NR==FNR)
     {
     filter_class[$1]=$1
     }
   if(FILENAME~/canopus/)
     {
     if(FNR==1)
       {
       col_id=1
       for(i=2; i<=NF; i++)
         {
         for(j in filter_class)
           {
           if(j==$i)
             {
             col_class[j]=i
             print i
             }
           }
         }
       }
     if(FNR>=2)
       {
       for(i in col_class)
         {
         if(sprintf("%.3f",$col_class[i])+0>="'$class_pp_limit'"+0)
           {
           class_set[i,$col_id]=i
           print "ID: ",$1,i,$col_class[i]
           }
         }
       }
     }
   if(FILENAME~/fingerid_first_score/)
     {
     if(FNR==1)
       {
       for(i=1; i<=NF; i++)
         {
         if($i~/^id/)
         {
         col_id=i
         }
       if($i~/similarity/)
         {
         col_similarity=i
         }
         }
       printf "class_nebula_facet\t"  $0"\n" > "'$savepath'"
       }
     if(FNR>=2)
       {
       if($col_similarity+0 >= "'$similarity_limit'"+0)
         {
        for(i in class_set)
          {
          if(i~"\034"$col_id"$")
            {
            printf class_set[i]"\t"  $0"\n" > "'$savepath'"
            }
          }
        }
       }
     }
   }' $data1 $data2 $data3
```

```{r eval = F, echo = T}
###################################
 data="temp/idenfication_filter_$class_pp_limit.tsv"
 savepath="temp/idenfication_filter2_${class_pp_limit}.tsv"
  until [[ "$num_limit_1" -gt 0 ]]
  do
    read -p "Please enter the features number threshold contribute to child-nebula (min number). >>> " num_limit_1;
  done;
  until [[ "$num_limit_2" -gt "$num_limit_1" ]]
  do
    read -p "Please enter the features number threshold contribute to child-nebula (max number). >>> " num_limit_2;
  done;
 awk -F $'\t' '
   {
   if(FNR==1)
     {
     printf $0"\n" > "'$savepath'"
     for(i=1; i<=NF; i++)
       {
       if($i~/class_nebula_facet/)
         {
         col_class=i
         }
       }
     }
 if(FNR>=2)
   {
   num[$col_class]+=1
   data[FNR]=$0
     class[FNR]=$col_class
   }
  }
   END{
     for(i in num)
       {
       if(num[i]+0 >= '$num_limit_1'+0 && num[i]+0 <= '$num_limit_2')
         {
         printf "The nodes number of the child-nebula is " num[i] ".\n"
         for(j in class)
           {
           if(class[j]==i)
             {
             printf data[j]"\n" >> "'$savepath'"
             }
           }
         }
       }
     }' $data
 ##################################
 mkdir results/network_facet_$class_pp_limit
 data1="temp/idenfication_filter2_${class_pp_limit}.tsv"
 data2="results/source_target_tree_$tlimit.tsv" # "results/source_target_tree_0.4.tsv"
 save_class="results/filter_child_class.tsv"
 savepath="results/network_facet_$class_pp_limit/"
 awk -F $'\t' '
   {
   if(NR==FNR)
     {
     if(FNR==1)
       {
       for(i=1; i<=NF; i++)
         {
         if($i~/class_nebula_facet/)
           {
           col_class=i
           }
         if($i~/^id$/)
           {
           col_id=i
           }
         }
       }
     if(FNR>=2)
       {
       class[$col_class]=$col_class
       class_id[$col_class,$col_id]=$col_id
       stat_id[$col_class,$col_id]=$col_id
       belong[$col_class,$col_id]=$col_class
       }
     }
   if(NR>FNR)
     {
     if(FNR==1)
       {
       for(i in class)
         {
         printf i"\n" > "'$save_class'"
         printf $0"\t"  "facet\n" > "'$savepath'" i ".tsv"
         }
       }
     if(FNR>=2)
       {
       for(i in class)
         {
         if( class_id[i,$1]==$1 && class_id[i,$2]==$2 )
           {
           printf $0"\t"  i"\n" >> "'$savepath'" i ".tsv"
           delete stat_id[i,$1]
           delete stat_id[i,$2]
           }
         }
       }
     }
   }
   END{
     for(i in stat_id)
       {
       ## source target similarity delta_mz fp fp class
       printf stat_id[i]"\t" stat_id[i]"\t"  "1\t"  "0\t"  "null\t"  "null\t"  belong[i]"\n" \
       \
       >> "'$savepath'" belong[i] ".tsv"
       }
     }' $data1 $data2
 #####################
 data1="canopus.tsv"
 data2="results/filter_child_class.tsv"
 data3="results/canopus_pp.tsv"
 savepath="results/canopus_pp_filter.tsv"
 awk -F $'\t' '
  	{
  	if(FILENAME~/canopus.tsv/)
  	 	{
  	 	if(FNR==1)
  	 	 	{
  	 	 	for(i=1; i<=NF; i++)
  	 	 	 	{
  	 	 	 	if($i~/absolute/)
  	 	 	 	 	{
  	 	 	 	 	col_index=i
  	 	 	 	 	}
  	 	 	 	if($i~/^id/)
  	 	 	 	 	{
  	 	 	 	 	col_chemid=i
  	 	 	 	 	}
  	 	 	 	if($i~/name/)
  	 	 	 	 	{
  	 	 	 	 	col_name=i
  	 	 	 	 	}
  	 	 	 	if($i~/description/)
  	 	 	 	 	{
  	 	 	 	 	col_des=i
  	 	 	 	 	}
  	 	 	 	}
  	 	 	}
  	 	if(FNR>2)
  	 	 	{
  	 	 	ab_index[$col_name]=$col_index
  	 	 	chemid[$col_name]=$col_chemid
  	 	 	des[$col_name]=$col_des
  	 	 	}
  	 	}
  	if(FILENAME~/filter_child_class/)
  	 	{
  	 	class[$1]=$1
  	 	if(FNR==1)
  	 	 	{
  	 	 	printf "index\t"  "chem_id\t"  "name\t"  "description\n" > "results/child_class.tsv"
  	 	 	}
  	 	printf ab_index[$1]"\t"  chemid[$1]"\t"  $1"\t"  des[$1]"\n" >> "results/child_class.tsv"
  	 	}
  	if(FILENAME~/canopus_pp/)
  	 	{
  	 	if(FNR==1)
  	 	 	{
  	 	 	printf $1 > "'$savepath'"
  	 	 	for(i=2; i<=NF; i++)
  	 	 	 	{
  	 	 	 	if(class[$i]!="")
  	 	 	 	 	{
  	 	 	 	 	n+=1
  	 	 	 	 	printf "\tC"ab_index[$i] >> "'$savepath'"
  	 	 	 	 	col_set[n]=i
  	 	 	 	 	}
  	 	 	 	}
  	 	 	printf "\n" >> "'$savepath'"
  	 	 	}
  	 	if(FNR>=2)
  	 	 	{
  	 	 	printf $1 >> "'$savepath'"
  	 	 	for(i=1; i<=n; i++)
  	 	 	 	{
  	 	 	 	printf "\t"$col_set[i] >> "'$savepath'"
  	 	 	 	}
  	 	 	printf "\n" >> "'$savepath'"
  	 	 	}
  	 	}
  	}' $data1 $data2 $data3
;;
```

```{r eval = F, echo = T}
###################################
```

```{r eval = F, echo = T}
###################################
compound_idenfication)
echo "Run compound_idenfication."
echo "compound_idenfication "
exit
;;
```

```{r eval = F, echo = T}
###################################
```

```{r eval = F, echo = T}
###################################
double_ion_network)
exit;
;;
```

```{r eval = F, echo = T}
###################################
```

```{r eval = F, echo = T}
###################################
```

```{r eval = F, echo = T}
###################################
```

```{r eval = F, echo = T}
###################################
exit)
echo "The mystery of creation is like the darkness of night--it is great.
Delusions of knowledge are like the fog of the morning."
exit;
;;
```

```{r eval = F, echo = T}
###################################
```

```{r eval = F, echo = T}
###################################
```

```{r eval = F, echo = T}
###################################
```

```{r eval = F, echo = T}
###################################
*)
echo "error"
exit;
;;
esac;
done;#(for)
done;#(select)
```

# File: mcnebula1126.sh

```{r eval = F, echo = T}
##########################
```

```{r eval = F, echo = T}
##########################
echo "We are all in the gutter, 
but some of us are looking at the stars.";
PS3='Please select the workflow to be executed. >>> '
select command in \
   \
  "default" \
  \
  "structure_extract" \
  \
  "classification_extract_sum" \
  \
  "classification_extract_filter" \
  \
  "fragment_tree_network" \
  \
  "fragment_tree_network_delta" \
  \
  "compound_idenfication" \
  \
  "double_ion_network" \
  \
  "exit" 
do
 if [[ $command == "default" ]]
 then
 confirm=0
   until [[ $confirm == "yes" ]] || [[ $confirm == "no" ]]
   do
   read -p "Running all proccesses sequentially? [yes/no] >>> " confirm
   done;
   if [[ $confirm == "no" ]]
   then exit
   fi;
 default="structure_extract classification_extract_sum classification_extract_filter fragment_tree_network fragment_tree_network_delta"
 list=$(echo $default);
 else list=$( echo $command)
 fi;
 for option in $(echo $list)
 do
   case $option in
```

```{r eval = F, echo = T}
###################################
```

```{r eval = F, echo = T}
###################################
```

```{r eval = F, echo = T}
###################################
```

```{r eval = F, echo = T}
###################################
structure_extract)
echo "Run structure_extract."
projectpath=0
 until [ -d $projectpath ] && [ -f $projectpath/canopus_summary.tsv ] && [ -f $projectpath/.format ]
 do
 read -p "Please input the path of the sirius project >>> " projectpath;
 done;
cd $projectpath;
mkdir results;
mkdir temp;
mkdir temp/fintemp;
 if [ -f temp/Mo_filename ]
 then rm temp/Mo_filename
 fi;
data="*_*/fingerid/*.tsv"
awk -F $'\t' '
  BEGIN{
    all_id=0
    \
    max_id=-1
    \
    p_id="null"
    \
    printf "Info: loading the data..."
    }
  {
  if(FNR==1)
    {
    if(NR>FNR)
      {
      close(pfile)
      }
    f=split(FILENAME,a,"[/]");
    n=split(a[1],b,"[_]");
    id=b[n];
    if(id!=p_id)
      {
      all_id+=1
      \
      if(id>max_id)
        {
        max_id=id
        }
      }
    file[id]=a[1]
    split(a[f], g, "[.]")
    formu_type[id]=g[1]
    if(all_id==1)
      {
      for(i=1; i<=NF; i++)
        {
        if(($i~/inchikey2D/))
          {
          col_2D=i
          }
        if($i=="inchi")
          {
          col_inchi=i
          }
        if(($i~/Formula/))
          {
          col_formu=i
          }
        if($i=="score")
          {
          col_score=i
          }
        if($i=="name")
          {
          col_name=i
          }
        if($i=="smiles")
          {
          col_smiles=i
          }
        if($i=="xlogp")
          {
          col_x=i
          }
        if(($i~/imilarity/))
          {
          col_simi=i
          }
        if($i~/links/)
          {
          col_links=i
          }
        }
      }
    pfile=FILENAME
    printf g[1]"\t"formu_type[id]"\n"
    printf "Info: the data of " id " (ID) has input. The filename is " FILENAME ".\n"
    }
  if(FNR>=2)
    {
    row_score=$col_score
    row_simi=$col_simi
    if(max["score",id]=="" || max["score",id]+0<row_score+0)
     {
      max["score",id]=row_score
      name["score",id]=$col_name
      formula["score",id]=$col_formu
      formu_type["score",id]=formu_type[id]
      simi["score",id]=$col_simi
      smiles["score",id]=$col_smiles
      inchi["score",id]=$col_inchi
      in2D["score",id]=$col_2D
      score["score",id]=$col_score
      xlogp["score",id]=$col_x
      links["score",id]=$col_links
      }
    if(max["simi",id]=="" || max["simi",id]+0<row_simi+0)
     {
      max["simi",id]=row_simi
      name["simi",id]=$col_name
      formula["simi",id]=$col_formu
      formu_type["simi",id]=formu_type[id]
      simi["simi",id]=$col_simi
      smiles["simi",id]=$col_smiles
      inchi["simi",id]=$col_inchi
      in2D["simi",id]=$col_2D
      score["simi",id]=$col_score
      xlogp["simi",id]=$col_x
      links["simi",id]=$col_links
      }
    }
  }
  END{
    printf "id\t"  "name\t"  "formula\t"  "similarity\t"  "smiles\t"  "inchi\t"  "inchikey2D\t" \
    "score\t"  "xlogp\t"  "links\n" > "results/fingerid_sum.tsv"
    for(l in file)
      {
      if(max["score",l]!="")
        {
        printf l"\t" \
        \
        name["score",l]"\t"  formula["score",l]"\t"  simi["score",l]"\t" \
        \
        smiles["score",l]"\t"  inchi["score",l]"\t"  in2D["score",l]"\t" \
        \
        score["score",l]"\t"  xlogp["score",l]"\t"  links["score",l]"\n" >> "results/fingerid_sum.tsv"
        printf formula["score",l]"\t"  file[l]"\t"  formu_type["score",l]"\n" > "temp/Mo_filename"
        }
      if(max["simi",l]!="" && max["simi",l]!=max["score",l])
        {
        printf l"\t" \
        \
        name["simi",l]"\t"  formula["simi",l]"\t"  simi["simi",l]"\t" \
        \
        smiles["simi",l]"\t"  inchi["simi",l]"\t"  in2D["simi",l]"\t" \
        \
        score["simi",l]"\t"  xlogp["simi",l]"\t"  links["simi",l]"\n" >> "results/fingerid_sum.tsv"
        }
      }
    }' $data
data_sum="results/fingerid_sum.tsv"
awk -F $'\t' '
  {
  if(NR==1)
    {
    for(i=1; i<=NF; i++)
      {
      if($i~/id/)
        {
        col_id=i
        }
      if($i~/score/)
        {
        col_score=i
        }
      }
    }
  if(NR>=2)
    {
    id=$col_id
    \
    if(max_id+0<id || max_id=="")
      {
      max_id=id
      }
    if(score[id]+0<$col_score+0 || score[id]=="")
      {
      score[id]=$col_score
      \
      data[id]=$0
      }
    }
  }
  END{
    printf "id\t"  "name\t"  "formula\t"  "similarity\t"  "smiles\t"  "inchi\t"  "inchikey2D\t" \
    \
    "score\t"  "xlogp\t"  "links\n" > "results/fingerid_first_score.tsv"
    \
    for(i=1; i<=max_id; i++)
      {
      if(data[i]!="")
        {
        printf data[i] "\n" >> "results/fingerid_first_score.tsv"
        }
      }
    }' $data_sum
echo "structure_extract results have been successfully assembled into <results/fingerid_sum.tsv> and <results/fingerid_first_score.tsv>";
;;
```

```{r eval = F, echo = T}
###################################
```

```{r eval = F, echo = T}
###################################
```

```{r eval = F, echo = T}
###################################
```

```{r eval = F, echo = T}
###################################
classification_extract_sum)
echo "Run classification_extract_sum.";
 if [ -f temp/Mo_filename ] && [ -f canopus.tsv ] && [ -f canopus_neg.tsv ] && [ -f .format ]
 then
 echo "Project path acknowledged."
 else
   until [ -d $projectpath ] && [ -f $projectpath/canopus.tsv ] && [ -f $projectpath/.format ]
   do
   read -p "Please input the path of the sirius project >>> " projectpath;
   done;
   cd $projectpath;
 fi;
data1="temp/Mo_filename"
data2="canopus.tsv"
data3="canopus_neg.tsv"
datas=$(awk -F $'\t' '
  {
  x=$2"/canopus/"$3".fpt"
  if(getline < x == 1)
    {
    printf x" "
    }
  close(x)
  }' $data1)
```

```{r eval = F, echo = T}
##################
awk -F $'\t' '
{
  if(NR==FNR)
    {
      i=split($2,s,"[_]")
      the_id[FNR]=s[i]
      n=FNR
    }
  if(FILENAME ~ /canopus.tsv/)
    {
      if(FNR==1)
        {
          for(i=1; i<=NF; i++)
            {
              if($i ~ /^name/)
                {
                  col_class=i
                }
              if($i ~ /absolute/)
                {
                  col_abindex=i
                }
            }
        }
      if(FNR>=2)
        {
          abindex[1,FNR]=$col_abindex
          indexset[$col_abindex]=$col_class
        }
    }
  if(FILENAME ~ /canopus_neg.tsv/)
    {
      p_filename=FILENAME
      if(FNR==1)
        {
          for(i=1; i<=NF; i++)
            {
              if($i ~ /name/)
                {
                  col_class=i
                }
              if($i ~ /absolute/)
                {
                  col_abindex=i
                }
            }
        }
      if(FNR>=2)
        {
          abindex[2,FNR]=$col_abindex
          indexset[$col_abindex]=$col_class
        }
    }
  if(FILENAME ~ /.fpt/)
    {
      if(FNR==1)
        {
          close(p_filename)
          printf "Info: data_file name of " p_filename " has been input.\n"
          p_filename=FILENAME
          split(FILENAME,a,"[/]");
          m=split(a[1],b,"[_]");
          id=b[m];
          if(FILENAME ~ /\+.fpt/)
            {
              ion=1
            }
          if(FILENAME ~ /\-.fpt/)
            {
              ion=2
            }
        }
      pp[id,abindex[ion,FNR+1]]=sprintf("%.3f",$1)
    }
}
END{
printf "id" > "results/canopus_pp.tsv"
for(i in indexset)
  {
    ord+=1
    orderlist[ord]=i
    printf "\t"indexset[i] >> "results/canopus_pp.tsv"
  }
printf "\n" >> "results/canopus_pp.tsv"
for(i=1; i<=n; i++)
  {
    printf the_id[i] >> "results/canopus_pp.tsv"
    for(j=1; j<=ord; j++)
      {
        if(pp[the_id[i],orderlist[j]]=="")
          {
            pp[the_id[i],orderlist[j]]=0
          }
        printf "\t"pp[the_id[i],orderlist[j]] >> "results/canopus_pp.tsv"
      }
    printf "\n" >> "results/canopus_pp.tsv"
  }
}' $data1 $data2 $data3 $datas
echo "classiication_extract_sum have been successfully written into <results/canopus_pp.tsv>"
;;
```

```{r eval = F, echo = T}
###################################
```

```{r eval = F, echo = T}
###################################
```

```{r eval = F, echo = T}
###################################
classification_extract_filter)
echo "Run classification_extract_filter.";
 if [ -f results/canopus_pp.tsv ]
 then
 echo "Project path acknowledged."
 else
   until [ -d $projectpath ] && [ -f $projectpath/results/canopus_pp.tsv ] && [ -f $projectpath/results/canopus_summary.tsv ]
   do
   read -p "Please input the path of the sirius project >>> " projectpath;
   done;
   cd $projectpath;
 fi; 
check=0
 until [[ "$check" == "yes" ]] || [[ "$check" == "no" ]]
 do
 read -p "Collate the posterior probabilities of the classification of each feature? [yes/no] >>> " check;
 done;
 if [[ $check == "yes" ]]
 then
 definition_limit=0
   until [[ "$definition_limit" > "0.01" ]] && [[ "$definition_limit" < "1" ]]
   do
   read -p "Please enter the classes posterior probabilities limition. 0.5~0.99 may work well. >>> " definition_limit;
   done;
 data1="canopus_summary.tsv"
  data2="canopus.tsv"
  data3="results/canopus_pp.tsv"
 awk -F $'\t' '
   {
   if(NR==FNR)
     {
     if(FNR==1)
       {
       p_file=FILENAME
       \
       for(i=1; i<=NF; i++)
         {
         if($i~/name/)
           {
           col_id=i
           }
         if($i~/specific/)
           {
           col_specific=i
           }
         if($i~/level/)
           {
           col_level=i
           }
         if($i~/subclass/)
           {
           col_subclass=i
           }
         if($i~/^class/)
           {
           col_class=i
           }
         if($i~/superclass/)
           {
           col_superclass=i
           }
         }
       }
     if(FNR>=2)
       {
       n=split($col_id,a,"[_]")
       \
       id=a[n]
       \
       specific[id]=$col_specific
       \
       level[id]=$col_level
       \
       subclass[id]=$col_subclass
       \
       class[id]=$col_class
       \
       superclass[id]=$col_superclass
       }
     }
   if(FILENAME~/canopus.tsv/)
     {
     if(FNR==1)
       {
       close(p_file)
       \
       p_file=FILENAME
       \
       for(i=1; i<=NF; i++)
         {
         if($i~/name/)
           {
           col_name=i
           }
         if($i~/description/)
           {
           col_description=i
           }
         }
       }
     if(FNR>=2)
       {
       description[$col_name]=$col_description
       }
     }
   if(FILENAME~"'$data3'")
     {
     if(FNR==1)
       {
       close(p_file)
       \
       for(i=1; i<=NF; i++)
         {
         if($i~/^id$/)
           {
           col_id=i
           }
         if(i>=2)
           {
           col_class_name[i]=$i
           }
         }
       printf "id\t"  "definition_source\t"  "definition\t"  "definition_pp\t"  "definition_description\t" \
       \
       "specific\t"  "specific_pp\t"  "level_5\t"  "level_5_pp\t" \
       \
       "subclass\t"  "subclass_pp\t"  "class\t"  "class_pp\t"  "superclass\t"  "superclass_pp\n" \
       \
       > "results/stat_classification.tsv"
       }
     if(FNR>=2)
       {
       for(i=2; i<=NF; i++)
         {
         c_pp[col_class_name[i]]=sprintf("%.4f",$i)
         }
       if(level[$col_id] != "" && c_pp[level[$col_id]] >= "'$definition_limit'")
         {
         definition_source="level_5"
         \
         definition=level[$col_id]
         }
       else if(subclass[$col_id] != "" && c_pp[subclass[$col_id]] >= "'$definition_limit'")
         {
         definition_source="subclass"
         \
         definition=subclass[$col_id]
         }
       else if(class[$col_id] != "" && c_pp[class[$col_id]] >= "'$definition_limit'")
         {
         definition_source="class"
         \
         definition=class[$col_id]
         }
       else if(superclass[$col_id] != "" && c_pp[superclass[$col_id]] >= "'$definition_limit'")
         {
         definition_source="superclass"
         \
         definition=superclass[$col_id]
         }
       else
         {
         definition_source="null"
         \
         definition="null"
         \
         c_pp[definition]="null"
         \
         description[definition]="null"
         }
       printf $col_id"\t"  definition_source"\t"  definition"\t"  c_pp[definition]"\t"  description[definition]"\t" \
       \
       specific[$col_id]"\t"  c_pp[specific[$col_id]]"\t"  level[$col_id]"\t"  c_pp[level[$col_id]]"\t" \
       \
       subclass[$col_id]"\t"  c_pp[subclass[$col_id]]"\t"  class[$col_id]"\t"  c_pp[class[$col_id]]"\t" \
       \
       superclass[$col_id]"\t"  c_pp[superclass[$col_id]]"\n" >> "results/stat_classification.tsv"
       }
     }
   }' $data1 $data2 $data3
  echo "classification_extract_filter have been successfully written into <results/stat_classification.tsv>"
  fi;
;;
```

```{r eval = F, echo = T}
###################################
```

```{r eval = F, echo = T}
###################################
```

```{r eval = F, echo = T}
###################################
```

```{r eval = F, echo = T}
###################################
fragment_tree_network)
echo "Run fragment_tree_network.";
 if [ -d temp ] && [ -f ftalign.tsv ] && [ -f .format ]
 then
 echo "Project path acknowledged."
 else
   until [ -d $projectpath ] && [ -f $projectpath/ftalign.tsv ] && [ -f $projectpath/.format ]
   do
   read -p "Please input the path of the sirius project. Make sure you have moved the fragment tree alignment results to the directory where the project is located. >>> " projectpath;
   done;
   cd $projectpath;
 fi;
echo "Please enter the minimum alignment similarity(tlimit) that you want to filter."
tlimit=0
 until [[ "$tlimit" > "0.01" ]] && [[ "$tlimit" < "0.99" ]]
 do
 read -p "0.4-0.7 is recommended >>> " tlimit;
 done;
  if ! [ -d temp/ftaligntemp ]
 then 
 mkdir temp/ftaligntemp
  fi;
data="ftalign.tsv"
savepath="temp/ftaligntemp/tmp"
awk -F $'\t' -v OFS=$'\t' '
  {
  printf "Info: NR = " NR ". FNR = " FNR ".\n"
  if(NR==FNR)
    {
   for(i=1; i<=NF; i++)
     {
     if(NR==1 && i!=1 || NR!=1 && i==1)
       {
       n=split($i,x,"[_]")
       \
       raw[NR,i]=x[n]
       }
     else
       {
       if(NR==i)
         {
         raw_norm[NR,i]=$i
         }
       }
     }
   }
 if(NR>FNR && FNR>=2)
   {
   for(i=2; i<=NF; i++)
     {
     norm1=$i/raw_norm[i,i]
     norm2=$i/raw_norm[FNR,FNR]
     norms=sprintf("%.2f", ((norm1+norm2)/2))
     if((norms+0 > '$tlimit'+0))
       {
       if(raw[FNR,1]+0>=raw[1,i]+0)
         {
         print raw[FNR,1], raw[1,i], norms > "'$savepath'"
         }
       if(raw[FNR,1]+0<raw[1,i]+0)
         {
         print raw[1,i], raw[FNR,1], norms > "'$savepath'"
         }
       }
     }
   }
  }' $data $data
sort -u $savepath > temp/ftaligntemp/tmp2
savepath="temp/ftaligntemp/filter_net_$tlimit"
awk -F $'\t' '
{
  if(NR==FNR)
    {
      if($1!=$2)
        {
          replink[$1]=$1
          replink[$2]=$2
        }
    }
  if(NR!=FNR)
    {
      if($1!=$2)
        {
          printf $0"\n" > "'$savepath'" 
        } 
      if($1==$2)
        {
          if(replink[$1]=="")
            {
              printf $0"\n" > "'$savepath'"
            }
        }
    }
}' temp/ftaligntemp/tmp2 temp/ftaligntemp/tmp2
echo "fragment_tree_network have been successfully written into <temp/ftaligntemp/filter_net_$tlimit>"
;;
```

```{r eval = F, echo = T}
###################################
```

```{r eval = F, echo = T}
###################################
```

```{r eval = F, echo = T}
###################################
```

```{r eval = F, echo = T}
###################################
fragment_tree_network_delta)
 if [ -d temp ] && [ -f ftalign.tsv ] && [ -f .format ]
 then
 echo "Project path acknowledged."
 else
   until [ -d $projectpath ] && [ -f $projectpath/ftalign.tsv ] && [ -f $projectpath/.format ]
   do
   read -p "Please input the path of the sirius project >>> " projectpath;
   done;
 cd $projectpath;
 fi;
echo "The following module attempts to compute the differential fingerprints of connected clusters based on the molecular fingerprint results of sirius 4."
```

```{r eval = F, echo = T}
###################
```

```{r eval = F, echo = T}
###################
```

```{r eval = F, echo = T}
###################
plimit=0
 until [[ "$plimit" > "0.5" ]] && [[ "$plimit" < "0.99" ]]
 do
 read -p "If the minimum alignment similarity is greater than 0.3, this step will automatic calculate the discrepancy fingerprint between alignment features(in beta). Please enter the minimum posterior probability of the molecular fingerprint(plimit_1) to be filtered. 0.9-0.99 is recommended. >>> " plimit;
 done;
plimit2=0
 until [[ "$plimit2" > "0.1" ]] && [[ "$plimit2" < "$plimit" ]]
 do
 read -p "The minimum posterior probability of the molecular fingerprint(plimit_2) to be controled. 0.1-0.5 may work well. >>> " plimit2;
 done;
tlimit=$(ls temp/ftaligntemp/filter_net_* | awk -F _ '{print $NF}')
check_rep=$(awk 'END{print NR}' <(echo "$tlimit"))
 if [[ "$check_rep" > "1" ]]
 then
 tlimit=0
   until [ -f temp/ftaligntemp/filter_net_$tlimit ]
   do
   read -p "Plural and different fragment_tree_network files were found to exist locally. Please select a tlimit parameter you have utilized to run fragment_tree_network_delta. >>> " tlimit;
   done;
 fi;
 if [ -f temp/ftaligntemp/refilter_net_$tlimit ]
 then rm temp/ftaligntemp/refilter_net_$tlimit
 fi;
 if [ -f temp/ftaligntemp/fpsample ]
 then rm temp/ftaligntemp/fpsample
 fi;
echo "Running delta_fingerprint computation..."
echo "Aquiring data from sirius index..."
data1="*_*/compound.info"
data2="temp/ftaligntemp/filter_net_$tlimit"
echo "Run fragment_tree_network_delta."
savepath="temp/ms_data_$tlimit"
echo "step 1: ms data"
  if ! [ -f $savepath ]
  then
 awk -F "[\t]||[:]||[_]" -v OFS=$'\t' '
   BEGIN{  
     printf "..."
     printf "id\t"  "m/z\t"  "rt\n" > "results/mz_and_rt.tsv"
     }
   {
   if(FILENAME~/compound.info/)
     {
     if(FNR==1)
       {
       printf "Info: catch >>> "FILENAME"\n"
       }
     if($1=="name")
       {
       i+=1;
       id[i]=$NF;
       n=split($NF,a,"[_]")
       printf a[n]"\t" >> "results/mz_and_rt.tsv"
       }
     if($1=="ionMass")
       {
       mz[id[i]]=$NF
       printf sprintf("%.4f",$NF)"\t" >> "results/mz_and_rt.tsv"
       }
     if($1=="ionType")
       {
       type[id[i]]=$NF
       }
     if($1=="rt")
       {
       rt[id[i]]=$2;
       printf sprintf("%.2f",$2/60)"\n" >> "results/mz_and_rt.tsv"
       }
     }
   if(FILENAME~/ftaligntemp/)
     {
     #source  target  ftalign  delta_mz  delta_rt  source_iontype  target_iontype;
     if(FNR==1)
       {
       printf "" > "'$savepath'"
       }
     print $1,$2,$3,sprintf("%.3f",mz[$2]-mz[$1]),sprintf("%.2f",rt[$2]-rt[$1]),type[$1],type[$2] \
     \
     >> "'$savepath'"
     }
   }' $data1 $data2
  fi;
```

```{r eval = F, echo = T}
########################
echo "step 2: data path"
source_file="temp/Mo_filename"
data="temp/ms_data_$tlimit"
savepath="temp/datapath_$tlimit"
  if ! [ -f $savepath ]
  then
 awk -F $'\t' -v OFS=$'\t' '
   {
   if(NR==FNR)
     {
     n=split($2, a, "[_]")
     file[a[n]]=$2
     formu_type[a[n]]=$3
     }
   if(NR!=FNR)
     {
     #<path>sourceFormula  <path>targetFormula
     path1=file[$1]"/fingerprints/"formu_type[$1]".fpt"
     path2=file[$2]"/fingerprints/"formu_type[$2]".fpt"
     data[path1]=path1
     data[path2]=path2
     }
   }
   END{
     for(i in data)
       {
       n+=1
       print "Check file:",n
       if(getline<i==-1)
         {
         printf "Escape filename: " i "\n"
         }
       else
         {
         printf i" " > "'$savepath'"
         }
       close(i)
       }
     print "Sum:",n
     }' $source_file $data
   fi;
datapath=$(cat temp/datapath_$tlimit)
echo "step 3: fingerprint"
data_allfp="temp/data_allfp_$tlimit"
  if ! [ -f $data_allfp ]
  then
 awk -F $'\t' '
   BEGIN{
     n=0
     }
   {
   if(FNR==1)
     {
     if(n>1)
       {
       close(file)
       }
     file=FILENAME;
     print "Get fingerprints: ",FILENAME
     n+=1;
     printf FILENAME"\n"$0"\n" > "'$data_allfp'"
     }
   else
     {
     print $0 > "'$data_allfp'"
     }
   }' $datapath
  fi;
```

```{r eval = F, echo = T}
###########################
awk -F $'\t' -v OFS=$'\t' '
  {
  if(NR==1)
    {
    for(i=1; i<=NF; i++)
      {
      if($i~/absolute/)
        {
        col_index=i
        }
      if($i~/description/)
        {
        col_description=i
        }
      }
    }
  if(NR>=2)
    {
    print $col_index,$col_description
    }
  }' csi_fingerid.tsv > temp/ftaligntemp/pos_fingerprint_index;
awk -F $'\t' -v OFS=$'\t' '
  {
  if(NR==1)
    {
    for(i=1; i<=NF; i++)
      {
      if($i~/absolute/)
        {
        col_index=i
        }
      if($i~/description/)
        {
        col_description=i
        }
      }
    }
  if(NR>=2)
    {
    print $col_index,$col_description
    }
  }' csi_fingerid_neg.tsv > temp/ftaligntemp/neg_fingerprint_index;
posindex="temp/ftaligntemp/pos_fingerprint_index"
negindex="temp/ftaligntemp/neg_fingerprint_index"
data="temp/ms_data_$tlimit"
echo "step 4: merge data"
awk -F $'\t' '
  BEGIN{
    file=0
    x=0
    count=0
    f=0
    posnum=0
    negnum=0
    }
  {
  if(FNR==1)
    {
    file+=1
    }
  if(NR==FNR)
    {
    if(($1~/fingerprint/))
      {
      if(x+0>f+0)
        {
        f=x  # calculate the max index.
        }
      count+=1;  # calculate the all fingerprints file number.
      \
      split($1,a,"[/]"); e=split(a[1],b,"[_]"); id=b[e]; #catch the id.
      \
      x=0;
      }
    else
      {
      x+=1;
      \
      fp[id,x]=$1;
      }
    }
  if(file==2)
    {
    pos[FNR]=$1
    posnum+=1
    }
  if(file==3)
    {
    neg[FNR]=$1
    negnum+=1
    }
  if(file==4)
    {
    if("'$tlimit'"+0 >= 0.3)
      {
     if(fp[$1,1]!="" && fp[$2,1]!="")
       {
       n1=split($6, g, "[]]");
       n2=split($7, h, "[]]");
       if(g[n1]=="+" && h[n2]=="+")
         {
         for(x=1; x<=posnum; x++)
           {
           if(fp[$1,x]+0>='$plimit'+0 && fp[$2,x]+0<='$plimit2'+0)
             {
             data_s[FNR,x]=pos[x]
             }
           else if(fp[$2,x]+0>='$plimit'+0 && fp[$1,x]+0<='$plimit2'+0)
             {
             data_t[FNR,x]=pos[x]
             }
           }
         }
       if(g[n1]=="-" && h[n2]=="-")
         {
         for(x=1; x<=negnum; x++)
           {
           if(fp[$1,x]+0>='$plimit'+0 && fp[$2,x]+0<='$plimit2'+0)
             {
             data_s[FNR,x]=neg[x]
             }
           else if(fp[$2,x]+0>='$plimit'+0 && fp[$1,x]+0<='$plimit2'+0)
             {
             data_t[FNR,x]=neg[x]
             }
           }
         }
       if(g[n1]=="-" && h[n2]=="+" || h[n2]=="-" && g[n1]=="+")
         {
         for(i=1; i<=posnum; i++)
           {
           for(j=1; j<=negnum; j++)
             {
             if(pos[i]==neg[j])
               {
               mirror[i]=j  #if pos=i, the identical index of neg is mirror[i]
               }
             }
           }
         }
       if(g[n1]=="-" && h[n2]=="+") 
         {
         for(x=1; x<=f; x++)
           {
           if(fp[$1,mirror[x]]+0>='$plimit'+0 && fp[$2,x]+0<='$plimit2'+0)
             {
             data_s[FNR,x]=neg[mirror[x]]
             }
           else if(fp[$2,x]+0>='$plimit'+0 && fp[$1,mirror[x]]+0<='$plimit2'+0)
             {
             data_t[FNR,x]=neg[mirror[x]]
             }
           }
         }
       if(h[n2]=="-" && g[n1]=="+")
         {
         for(x=1; x<=f; x++)
           {
           if(fp[$1,x]+0>= '$plimit'+0 && fp[$2,mirror[x]]+0<='$plimit2'+0)
             {
             data_s[FNR,x]=neg[mirror[x]]
             }
           else if(fp[$2,mirror[x]]+0>='$plimit'+0 && fp[$1,x]+0<='$plimit2'+0)
             {
             data_t[FNR,x]=neg[mirror[x]]
             }
           }   
         }
       }
     }
    if(FNR==1)
      {
      printf "source\t"  "target\t"  "ftalign_similarity\t"  "delta_m/z\t"  "source_fp_uniq\t"  "target_fp_uniq\n"
      }
    else
      {
      printf $1"\t"  $2"\t"  $3"\t"  $4"\t";
      \
      if('$tlimit'+0 >= 0.3)
        {
       if(fp[$1,1]=="" || fp[$2,1]=="")
         {
         printf "NA@NA\n"
         }
       else
         {
         printf "source:"  #the source fingerprint uniq.
         \
         for(x=1; x<=f; x++)
           {
           if(data_s[FNR,x]!="")
             {
             printf data_s[FNR,x]","
             }
           };
         printf "@target:"  #the target fingerprint uniq.
         \
         for(x=1; x<=f; x++)
           {
           if(data_t[FNR,x]!="")
             {
             printf data_t[FNR,x]","
             }
           }
         printf "\n"
         }
       }
     else
       {
       printf "NA@NA\n"
       }
      }
    }
  }' $data_allfp $posindex $negindex $data | sed -e 's/,@/\t/g; s/,$//g; s/@/\t/g' \
  \
  > results/source_target_tree_$tlimit.tsv;
echo "All instances have written into <results/source_target_tree_$tlimit.tsv>."
```

```{r eval = F, echo = T}
#####################################
echo "step 5: separate child-nebula from parent-nebula."
data="results/stat_classification.tsv"
savepath="temp/filter_0_class.tsv"
awk -F $'\t' '
  {
  if(FNR==1)
    {
    for(i=1; i<=NF; i++)
      {
      if($i~/^definition$/)
        {
        col_class=i
        }
      }
    }
  if(FNR>=2)
    {
    class[$col_class]=$col_class
    }
  }
  END{
   for(i in class)
      {
      printf class[i]"\n" > "'$savepath'"
      }
    }' $data
 ######################################
 data1="temp/filter_0_class.tsv" 
 data2="results/canopus_pp.tsv"
 data3="results/fingerid_first_score.tsv"
 until [[ "$similarity_limit" > 0 ]] && [[ "$similarity_limit" < 1 ]]
 do
 read -p "Please set the Tanimoto similarity threshold contribute to child-nebula. >>> " similarity_limit;
 done;
  until [[ "$definition_limit" > 0.01 ]] && [[ "$definition_limit" < 1 ]]
  do
  read -p "Please enter the classes posterior probabilities limition. 0.5~0.99 may work well. >>> " definition_limit;
  done;
 class_pp_limit=$definition_limit
 savepath="temp/idenfication_filter_$class_pp_limit.tsv"
 awk -F $'\t' '
   {
   if(NR==FNR)
     {
     filter_class[$1]=$1
     }
   if(FILENAME~/canopus/)
     {
     if(FNR==1)
       {
       col_id=1
       for(i=2; i<=NF; i++)
         {
         for(j in filter_class)
           {
           if(j==$i)
             {
             col_class[j]=i
             print i
             }
           }
         }
       }
     if(FNR>=2)
       {
       for(i in col_class)
         {
         if(sprintf("%.3f",$col_class[i])+0>="'$class_pp_limit'"+0)
           {
           class_set[i,$col_id]=i
           print "ID: ",$1,i,$col_class[i]
           }
         }
       }
     }
   if(FILENAME~/fingerid_first_score/)
     {
     if(FNR==1)
       {
       for(i=1; i<=NF; i++)
         {
         if($i~/^id/)
         {
         col_id=i
         }
       if($i~/similarity/)
         {
         col_similarity=i
         }
         }
       printf "class_nebula_facet\t"  $0"\n" > "'$savepath'"
       }
     if(FNR>=2)
       {
       if($col_similarity+0 >= "'$similarity_limit'"+0)
         {
        for(i in class_set)
          {
          if(i~"\034"$col_id"$")
            {
            printf class_set[i]"\t"  $0"\n" > "'$savepath'"
            }
          }
        }
       }
     }
   }' $data1 $data2 $data3
```

```{r eval = F, echo = T}
###################################
 data="temp/idenfication_filter_$class_pp_limit.tsv"
 savepath="temp/idenfication_filter2_${class_pp_limit}.tsv"
  until [[ "$num_limit_1" -gt 0 ]]
  do
    read -p "Please enter the features number threshold contribute to child-nebula (min number). >>> " num_limit_1;
  done;
  until [[ "$num_limit_2" -gt "$num_limit_1" ]]
  do
    read -p "Please enter the features number threshold contribute to child-nebula (max number). >>> " num_limit_2;
  done;
 awk -F $'\t' '
   {
   if(FNR==1)
     {
     printf $0"\n" > "'$savepath'"
     for(i=1; i<=NF; i++)
       {
       if($i~/class_nebula_facet/)
         {
         col_class=i
         }
       }
     }
 if(FNR>=2)
   {
   num[$col_class]+=1
   data[FNR]=$0
     class[FNR]=$col_class
   }
  }
   END{
     for(i in num)
       {
       if(num[i]+0 >= '$num_limit_1'+0 && num[i]+0 <= '$num_limit_2')
         {
         printf "The nodes number of the child-nebula is " num[i] ".\n"
         for(j in class)
           {
           if(class[j]==i)
             {
             printf data[j]"\n" >> "'$savepath'"
             }
           }
         }
       }
     }' $data
 ##################################
 mkdir results/network_facet_$class_pp_limit
 data1="temp/idenfication_filter2_${class_pp_limit}.tsv"
 data2="results/source_target_tree_$tlimit.tsv" # "results/source_target_tree_0.4.tsv"
 save_class="results/filter_child_class.tsv"
 savepath="results/network_facet_$class_pp_limit/"
 awk -F $'\t' '
   {
   if(NR==FNR)
     {
     if(FNR==1)
       {
       for(i=1; i<=NF; i++)
         {
         if($i~/class_nebula_facet/)
           {
           col_class=i
           }
         if($i~/^id$/)
           {
           col_id=i
           }
         }
       }
     if(FNR>=2)
       {
       class[$col_class]=$col_class
       class_id[$col_class,$col_id]=$col_id
       stat_id[$col_class,$col_id]=$col_id
       belong[$col_class,$col_id]=$col_class
       }
     }
   if(NR>FNR)
     {
     if(FNR==1)
       {
       for(i in class)
         {
         printf i"\n" > "'$save_class'"
         printf $0"\t"  "facet\n" > "'$savepath'" i ".tsv"
         }
       }
     if(FNR>=2)
       {
       for(i in class)
         {
         if( class_id[i,$1]==$1 && class_id[i,$2]==$2 )
           {
           printf $0"\t"  i"\n" >> "'$savepath'" i ".tsv"
           delete stat_id[i,$1]
           delete stat_id[i,$2]
           }
         }
       }
     }
   }
   END{
     for(i in stat_id)
       {
       ## source target similarity delta_mz fp fp class
       printf stat_id[i]"\t" stat_id[i]"\t"  "1\t"  "0\t"  "null\t"  "null\t"  belong[i]"\n" \
       \
       >> "'$savepath'" belong[i] ".tsv"
       }
     }' $data1 $data2
 #####################
 data1="canopus.tsv"
 data2="results/filter_child_class.tsv"
 data3="results/canopus_pp.tsv"
 savepath="results/canopus_pp_filter.tsv"
 awk -F $'\t' '
  	{
  	if(FILENAME~/canopus.tsv/)
  	 	{
  	 	if(FNR==1)
  	 	 	{
  	 	 	for(i=1; i<=NF; i++)
  	 	 	 	{
  	 	 	 	if($i~/absolute/)
  	 	 	 	 	{
  	 	 	 	 	col_index=i
  	 	 	 	 	}
  	 	 	 	if($i~/^id/)
  	 	 	 	 	{
  	 	 	 	 	col_chemid=i
  	 	 	 	 	}
  	 	 	 	if($i~/name/)
  	 	 	 	 	{
  	 	 	 	 	col_name=i
  	 	 	 	 	}
  	 	 	 	if($i~/description/)
  	 	 	 	 	{
  	 	 	 	 	col_des=i
  	 	 	 	 	}
  	 	 	 	}
  	 	 	}
  	 	if(FNR>2)
  	 	 	{
  	 	 	ab_index[$col_name]=$col_index
  	 	 	chemid[$col_name]=$col_chemid
  	 	 	des[$col_name]=$col_des
  	 	 	}
  	 	}
  	if(FILENAME~/filter_child_class/)
  	 	{
  	 	class[$1]=$1
  	 	if(FNR==1)
  	 	 	{
  	 	 	printf "index\t"  "chem_id\t"  "name\t"  "description\n" > "results/child_class.tsv"
  	 	 	}
  	 	printf ab_index[$1]"\t"  chemid[$1]"\t"  $1"\t"  des[$1]"\n" >> "results/child_class.tsv"
  	 	}
  	if(FILENAME~/canopus_pp/)
  	 	{
  	 	if(FNR==1)
  	 	 	{
  	 	 	printf $1 > "'$savepath'"
  	 	 	for(i=2; i<=NF; i++)
  	 	 	 	{
  	 	 	 	if(class[$i]!="")
  	 	 	 	 	{
  	 	 	 	 	n+=1
  	 	 	 	 	printf "\tC"ab_index[$i] >> "'$savepath'"
  	 	 	 	 	col_set[n]=i
  	 	 	 	 	}
  	 	 	 	}
  	 	 	printf "\n" >> "'$savepath'"
  	 	 	}
  	 	if(FNR>=2)
  	 	 	{
  	 	 	printf $1 >> "'$savepath'"
  	 	 	for(i=1; i<=n; i++)
  	 	 	 	{
  	 	 	 	printf "\t"$col_set[i] >> "'$savepath'"
  	 	 	 	}
  	 	 	printf "\n" >> "'$savepath'"
  	 	 	}
  	 	}
  	}' $data1 $data2 $data3
;;
```

```{r eval = F, echo = T}
###################################
```

```{r eval = F, echo = T}
###################################
compound_idenfication)
echo "Run compound_idenfication."
echo "compound_idenfication "
exit
;;
```

```{r eval = F, echo = T}
###################################
```

```{r eval = F, echo = T}
###################################
double_ion_network)
exit;
;;
```

```{r eval = F, echo = T}
###################################
```

```{r eval = F, echo = T}
###################################
```

```{r eval = F, echo = T}
###################################
```

```{r eval = F, echo = T}
###################################
exit)
echo "The mystery of creation is like the darkness of night--it is great.
Delusions of knowledge are like the fog of the morning."
exit;
;;
```

```{r eval = F, echo = T}
###################################
```

```{r eval = F, echo = T}
###################################
```

```{r eval = F, echo = T}
###################################
```

```{r eval = F, echo = T}
###################################
*)
echo "error"
exit;
;;
esac;
done;#(for)
done;#(select)
```

# File: mcnebula1127.sh

```{r eval = F, echo = T}
##########################
```

```{r eval = F, echo = T}
##########################
PS3='Please select the workflow to be executed. >>> '
select command in \
  "default" \
  "structure_extract" \
  "classification_extract_sum" \
  "classification_extract_filter" \
  "fragment_tree_network" \
  "fragment_tree_network_delta" \
  "compound_idenfication" \
  "double_ion_network" \
  "exit" 
do
  if [[ $command == "default" ]]
  then
    confirm=0
    until [[ $confirm == "yes" ]] || [[ $confirm == "no" ]]
    do
      read -p "Running all proccesses sequentially? [yes/no] >>> " confirm
    done;
    if [[ $confirm == "no" ]]
    then exit
    fi;
    default="structure_extract classification_extract_sum classification_extract_filter fragment_tree_network fragment_tree_network_delta"
    list=$(echo $default);
  else list=$( echo $command)
  fi;
  for option in $(echo $list)
  do
    case $option in
      ###################################
      ###################################
      ###################################
      ###################################
      structure_extract)
      echo "Run structure_extract."
      projectpath=0
      until [ -d $projectpath ] && [ -f $projectpath/canopus_summary.tsv ] && [ -f $projectpath/.format ]
      do
        read -p "Please input the path of the sirius project >>> " projectpath;
      done;
      cd $projectpath;
      mkdir results;
      mkdir temp;
      mkdir temp/fintemp;
      if [ -f temp/Mo_filename ]
      then rm temp/Mo_filename
      fi;
      data="*_*/fingerid/*.tsv"
      awk -F $'\t' '
      BEGIN{
      all_id=0
      max_id=-1
      p_id="null"
      printf "Info: loading the data..."
    }
  {
    if(FNR==1)
      {
        if(NR>FNR)
          {
            close(pfile)
          }
        f=split(FILENAME,a,"[/]");
        n=split(a[1],b,"[_]");
        id=b[n];
        if(id!=p_id)
          {
            all_id+=1
            if(id>max_id)
              {
                max_id=id
              }
          }
        file[id]=a[1]
        split(a[f], g, "[.]")
        formu_type[id]=g[1]
        if(all_id==1)
          {
            for(i=1; i<=NF; i++)
              {
                if(($i~/inchikey2D/))
                  {
                    col_2D=i
                  }
                if($i=="inchi")
                  {
                    col_inchi=i
                  }
                if(($i~/Formula/))
                  {
                    col_formu=i
                  }
                if($i=="score")
                  {
                    col_score=i
                  }
                if($i=="name")
                  {
                    col_name=i
                  }
                if($i=="smiles")
                  {
                    col_smiles=i
                  }
                if($i=="xlogp")
                  {
                    col_x=i
                  }
                if(($i~/imilarity/))
                  {
                    col_simi=i
                  }
                if($i~/links/)
                  {
                    col_links=i
                  }
              }
          }
        pfile=FILENAME
        printf g[1]"\t"formu_type[id]"\n"
        printf "Info: the data of " id " (ID) has input. The filename is " FILENAME ".\n"
      }
    if(FNR>=2)
      {
        row_score=$col_score
        row_simi=$col_simi
        if(max["score",id]=="" || max["score",id]+0<row_score+0)
          {
            max["score",id]=row_score
            name["score",id]=$col_name
            formula["score",id]=$col_formu
            formu_type["score",id]=formu_type[id]
            simi["score",id]=$col_simi
            smiles["score",id]=$col_smiles
            inchi["score",id]=$col_inchi
            in2D["score",id]=$col_2D
            score["score",id]=$col_score
            xlogp["score",id]=$col_x
            links["score",id]=$col_links
          }
        if(max["simi",id]=="" || max["simi",id]+0<row_simi+0)
          {
            max["simi",id]=row_simi
            name["simi",id]=$col_name
            formula["simi",id]=$col_formu
            formu_type["simi",id]=formu_type[id]
            simi["simi",id]=$col_simi
            smiles["simi",id]=$col_smiles
            inchi["simi",id]=$col_inchi
            in2D["simi",id]=$col_2D
            score["simi",id]=$col_score
            xlogp["simi",id]=$col_x
            links["simi",id]=$col_links
          }
      }
  }
END{
printf "id\t"  "name\t"  "formula\t"  "similarity\t"  "smiles\t"  "inchi\t"  "inchikey2D\t" \
  "score\t"  "xlogp\t"  "links\n" > "results/fingerid_sum.tsv"
  for(l in file)
    {
      if(max["score",l]!="")
        {
          printf l"\t" \
            name["score",l]"\t"  formula["score",l]"\t"  simi["score",l]"\t" \
            smiles["score",l]"\t"  inchi["score",l]"\t"  in2D["score",l]"\t" \
            score["score",l]"\t"  xlogp["score",l]"\t"  links["score",l]"\n" >> "results/fingerid_sum.tsv"
                      printf formula["score",l]"\t"  file[l]"\t"  formu_type["score",l]"\n" > "temp/Mo_filename"
                    }
                  if(max["simi",l]!="" && max["simi",l]!=max["score",l])
                    {
                      printf l"\t" \
                        name["simi",l]"\t"  formula["simi",l]"\t"  simi["simi",l]"\t" \
                        smiles["simi",l]"\t"  inchi["simi",l]"\t"  in2D["simi",l]"\t" \
                        score["simi",l]"\t"  xlogp["simi",l]"\t"  links["simi",l]"\n" >> "results/fingerid_sum.tsv"
                      }
                  }
              }' $data
            data_sum="results/fingerid_sum.tsv"
            awk -F $'\t' '
            {
              if(NR==1)
                {
                  for(i=1; i<=NF; i++)
                    {
                      if($i~/id/)
                        {
                          col_id=i
                        }
                      if($i~/score/)
                        {
                          col_score=i
                        }
                    }
                }
              if(NR>=2)
                {
                  id=$col_id
                  if(max_id+0<id || max_id=="")
                    {
                      max_id=id
                    }
                  if(score[id]+0<$col_score+0 || score[id]=="")
                    {
                      score[id]=$col_score
                      data[id]=$0
                    }
                }
            }
          END{
          printf "id\t"  "name\t"  "formula\t"  "similarity\t"  "smiles\t"  "inchi\t"  "inchikey2D\t" \
            "score\t"  "xlogp\t"  "links\n" > "results/fingerid_first_score.tsv"
                      for(i=1; i<=max_id; i++)
                        {
                          if(data[i]!="")
                            {
                              printf data[i] "\n" >> "results/fingerid_first_score.tsv"
                            }
                        }
                    }' $data_sum
                  echo "structure_extract results have been successfully assembled into <results/fingerid_sum.tsv> and <results/fingerid_first_score.tsv>";
                  ;;
                  ###################################
                  ###################################
                  ###################################
                  ###################################
                  classification_extract_sum)
                  echo "Run classification_extract_sum.";
                  if [ -f temp/Mo_filename ] && [ -f canopus.tsv ] && [ -f canopus_neg.tsv ] && [ -f .format ]
                  then
                    echo "Project path acknowledged."
                  else
                    until [ -d $projectpath ] && [ -f $projectpath/canopus.tsv ] && [ -f $projectpath/.format ]
                    do
                      read -p "Please input the path of the sirius project >>> " projectpath;
                    done;
                    cd $projectpath;
                  fi;
                  data1="temp/Mo_filename"
                  data2="canopus.tsv"
                  data3="canopus_neg.tsv"
                  datas=$(awk -F $'\t' '
                  {
                    x=$2"/canopus/"$3".fpt"
                    if(getline < x == 1)
                      {
                        printf x" "
                      }
                    close(x)
                  }' $data1)
                ##################
                awk -F $'\t' '
                {
                  if(NR==FNR)
                    {
                      i=split($2,s,"[_]")
                      the_id[FNR]=s[i]
                      n=FNR
                    }
                  if(FILENAME ~ /canopus.tsv/)
                    {
                      if(FNR==1)
                        {
                          for(i=1; i<=NF; i++)
                            {
                              if($i ~ /^name/)
                                {
                                  col_class=i
                                }
                              if($i ~ /absolute/)
                                {
                                  col_abindex=i
                                }
                            }
                        }
                      if(FNR>=2)
                        {
                          abindex[1,FNR]=$col_abindex
                          indexset[$col_abindex]=$col_class
                        }
                    }
                  if(FILENAME ~ /canopus_neg.tsv/)
                    {
                      p_filename=FILENAME
                      if(FNR==1)
                        {
                          for(i=1; i<=NF; i++)
                            {
                              if($i ~ /name/)
                                {
                                  col_class=i
                                }
                              if($i ~ /absolute/)
                                {
                                  col_abindex=i
                                }
                            }
                        }
                      if(FNR>=2)
                        {
                          abindex[2,FNR]=$col_abindex
                          indexset[$col_abindex]=$col_class
                        }
                    }
                  if(FILENAME ~ /.fpt/)
                    {
                      if(FNR==1)
                        {
                          close(p_filename)
                          printf "Info: data_file name of " p_filename " has been input.\n"
                          p_filename=FILENAME
                          split(FILENAME,a,"[/]");
                          m=split(a[1],b,"[_]");
                          id=b[m];
                          if(FILENAME ~ /\+.fpt/)
                            {
                              ion=1
                            }
                          if(FILENAME ~ /\-.fpt/)
                            {
                              ion=2
                            }
                        }
                      pp[id,abindex[ion,FNR+1]]=sprintf("%.3f",$1)
                    }
                }
              END{
              printf "id" > "results/canopus_pp.tsv"
              for(i in indexset)
                {
                  ord+=1
                  orderlist[ord]=i
                  printf "\t"indexset[i] >> "results/canopus_pp.tsv"
                }
              printf "\n" >> "results/canopus_pp.tsv"
              for(i=1; i<=n; i++)
                {
                  printf the_id[i] >> "results/canopus_pp.tsv"
                  for(j=1; j<=ord; j++)
                    {
                      if(pp[the_id[i],orderlist[j]]=="")
                        {
                          pp[the_id[i],orderlist[j]]=0
                        }
                      printf "\t"pp[the_id[i],orderlist[j]] >> "results/canopus_pp.tsv"
                    }
                  printf "\n" >> "results/canopus_pp.tsv"
                }
            }' $data1 $data2 $data3 $datas
          echo "classiication_extract_sum have been successfully written into <results/canopus_pp.tsv>"
          ;;
          ###################################
          ###################################
          ###################################
          classification_extract_filter)
          echo "Run classification_extract_filter.";
          if [ -f results/canopus_pp.tsv ]
          then
            echo "Project path acknowledged."
          else
            until [ -d $projectpath ] && [ -f $projectpath/results/canopus_pp.tsv ] && [ -f $projectpath/results/canopus_summary.tsv ]
            do
              read -p "Please input the path of the sirius project >>> " projectpath;
            done;
            cd $projectpath;
          fi; 
          check=0
          until [[ "$check" == "yes" ]] || [[ "$check" == "no" ]]
          do
            read -p "Collate the posterior probabilities of the classification of each feature? [yes/no] >>> " check;
          done;
          if [[ $check == "yes" ]]
          then
            definition_limit=0
            until [[ "$definition_limit" > "0.01" ]] && [[ "$definition_limit" < "1" ]]
            do
              read -p "Please enter the classes posterior probabilities limition. 0.5~0.99 may work well. >>> " definition_limit;
            done;
            data1="canopus_summary.tsv"
            data2="canopus.tsv"
            data3="results/canopus_pp.tsv"
            awk -F $'\t' '
            {
              if(NR==FNR)
                {
                  if(FNR==1)
                    {
                      p_file=FILENAME
                      for(i=1; i<=NF; i++)
                        {
                          if($i~/name/)
                            {
                              col_id=i
                            }
                          if($i~/specific/)
                            {
                              col_specific=i
                            }
                          if($i~/level/)
                            {
                              col_level=i
                            }
                          if($i~/subclass/)
                            {
                              col_subclass=i
                            }
                          if($i~/^class/)
                            {
                              col_class=i
                            }
                          if($i~/superclass/)
                            {
                              col_superclass=i
                            }
                        }
                    }
                  if(FNR>=2)
                    {
                      n=split($col_id,a,"[_]")
                      id=a[n]
                      specific[id]=$col_specific
                      level[id]=$col_level
                      subclass[id]=$col_subclass
                      class[id]=$col_class
                      superclass[id]=$col_superclass
                    }
                }
              if(FILENAME~/canopus.tsv/)
                {
                  if(FNR==1)
                    {
                      close(p_file)
                      p_file=FILENAME
                      for(i=1; i<=NF; i++)
                        {
                          if($i~/name/)
                            {
                              col_name=i
                            }
                          if($i~/description/)
                            {
                              col_description=i
                            }
                        }
                    }
                  if(FNR>=2)
                    {
                      description[$col_name]=$col_description
                    }
                }
              if(FILENAME~"'$data3'")
                {
                  if(FNR==1)
                    {
                      close(p_file)
                      for(i=1; i<=NF; i++)
                        {
                          if($i~/^id$/)
                            {
                              col_id=i
                            }
                          if(i>=2)
                            {
                              col_class_name[i]=$i
                            }
                        }
                      printf "id\t"  "definition_source\t"  "definition\t"  "definition_pp\t"  "definition_description\t" \
                        "specific\t"  "specific_pp\t"  "level_5\t"  "level_5_pp\t" \
                        "subclass\t"  "subclass_pp\t"  "class\t"  "class_pp\t"  "superclass\t"  "superclass_pp\n" \
                        > "results/stat_classification.tsv"
                      }
                    if(FNR>=2)
                      {
                        for(i=2; i<=NF; i++)
                          {
                            c_pp[col_class_name[i]]=sprintf("%.4f",$i)
                          }
                        if(level[$col_id] != "" && c_pp[level[$col_id]] >= "'$definition_limit'")
                          {
                            definition_source="level_5"
                            definition=level[$col_id]
                          }
                      else if(subclass[$col_id] != "" && c_pp[subclass[$col_id]] >= "'$definition_limit'")
                        {
                          definition_source="subclass"
                          definition=subclass[$col_id]
                        }
                    else if(class[$col_id] != "" && c_pp[class[$col_id]] >= "'$definition_limit'")
                      {
                        definition_source="class"
                        definition=class[$col_id]
                      }
                  else if(superclass[$col_id] != "" && c_pp[superclass[$col_id]] >= "'$definition_limit'")
                    {
                      definition_source="superclass"
                      definition=superclass[$col_id]
                    }
                else
                  {
                    definition_source="null"
                    definition="null"
                    c_pp[definition]="null"
                    description[definition]="null"
                  }
                printf $col_id"\t"  definition_source"\t"  definition"\t"  c_pp[definition]"\t"  description[definition]"\t" \
                  specific[$col_id]"\t"  c_pp[specific[$col_id]]"\t"  level[$col_id]"\t"  c_pp[level[$col_id]]"\t" \
                  subclass[$col_id]"\t"  c_pp[subclass[$col_id]]"\t"  class[$col_id]"\t"  c_pp[class[$col_id]]"\t" \
                  superclass[$col_id]"\t"  c_pp[superclass[$col_id]]"\n" >> "results/stat_classification.tsv"
                }
            }
        }' $data1 $data2 $data3
      echo "classification_extract_filter have been successfully written into <results/stat_classification.tsv>"
                  fi;
                  ;;
                  ###################################
                  ###################################
                  ###################################
                  ###################################
                  fragment_tree_network)
                  echo "Run fragment_tree_network.";
                  if [ -d temp ] && [ -f ftalign.tsv ] && [ -f .format ]
                  then
                    echo "Project path acknowledged."
                  else
                    until [ -d $projectpath ] && [ -f $projectpath/ftalign.tsv ] && [ -f $projectpath/.format ]
                    do
                      read -p "Please input the path of the sirius project. Make sure you have moved the fragment tree alignment results to the directory where the project is located. >>> " projectpath;
                    done;
                    cd $projectpath;
                  fi;
                  echo "Please enter the minimum alignment similarity(tlimit) that you want to filter."
                  tlimit=0
                  until [[ "$tlimit" > "0.01" ]] && [[ "$tlimit" < "0.99" ]]
                  do
                    read -p "0.4-0.7 is recommended >>> " tlimit;
                  done;
                  if ! [ -d temp/ftaligntemp ]
                  then 
                    mkdir temp/ftaligntemp
                  fi;
                  data="ftalign.tsv"
                  savepath="temp/ftaligntemp/tmp"
                  awk -F $'\t' -v OFS=$'\t' '
                  {
                    printf "Info: NR = " NR ". FNR = " FNR ".\n"
                    if(NR==FNR)
                      {
                        for(i=1; i<=NF; i++)
                          {
                            if(NR==1 && i!=1 || NR!=1 && i==1)
                              {
                                n=split($i,x,"[_]")
                                raw[NR,i]=x[n]
                              }
                          else
                            {
                              if(NR==i)
                                {
                                  raw_norm[NR,i]=$i
                                }
                            }
                        }
                    }
                  if(NR>FNR && FNR>=2)
                    {
                      for(i=2; i<=NF; i++)
                        {
                          norm1=$i/raw_norm[i,i]
                          norm2=$i/raw_norm[FNR,FNR]
                          norms=sprintf("%.2f", ((norm1+norm2)/2))
                          if((norms+0 > '$tlimit'+0))
                            {
                              if(raw[FNR,1]+0>=raw[1,i]+0)
                                {
                                  print raw[FNR,1], raw[1,i], norms > "'$savepath'"
                                }
                              if(raw[FNR,1]+0<raw[1,i]+0)
                                {
                                  print raw[1,i], raw[FNR,1], norms > "'$savepath'"
                                }
                            }
                        }
                    }
                }' $data $data
              sort -u $savepath > temp/ftaligntemp/tmp2
              savepath="temp/ftaligntemp/filter_net_$tlimit"
              awk -F $'\t' '
              {
                if(NR==FNR)
                  {
                    if($1!=$2)
                      {
                        replink[$1]=$1
                        replink[$2]=$2
                      }
                  }
                if(NR!=FNR)
                  {
                    if($1!=$2)
                      {
                        printf $0"\n" > "'$savepath'" 
                      } 
                    if($1==$2)
                      {
                        if(replink[$1]=="")
                          {
                            printf $0"\n" > "'$savepath'"
                          }
                      }
                  }
              }' temp/ftaligntemp/tmp2 temp/ftaligntemp/tmp2
            echo "fragment_tree_network have been successfully written into <temp/ftaligntemp/filter_net_$tlimit>"
            ;;
            ###################################
            ###################################
            ###################################
            ###################################
            fragment_tree_network_delta)
            if [ -d temp ] && [ -f ftalign.tsv ] && [ -f .format ]
            then
              echo "Project path acknowledged."
            else
              until [ -d $projectpath ] && [ -f $projectpath/ftalign.tsv ] && [ -f $projectpath/.format ]
              do
                read -p "Please input the path of the sirius project >>> " projectpath;
              done;
              cd $projectpath;
                        fi;
                        echo "The following module attempts to compute the differential fingerprints of connected clusters based on the molecular fingerprint results of sirius 4."
                        ###################
                        ###################
                        ###################
                        plimit=0
                        until [[ "$plimit" > "0.5" ]] && [[ "$plimit" < "0.99" ]]
                        do
                          read -p "If the minimum alignment similarity is greater than 0.3, this step will automatic calculate the discrepancy fingerprint between alignment features(in beta). Please enter the minimum posterior probability of the molecular fingerprint(plimit_1) to be filtered. 0.9-0.99 is recommended. >>> " plimit;
                        done;
                        plimit2=0
                        until [[ "$plimit2" > "0.1" ]] && [[ "$plimit2" < "$plimit" ]]
                        do
                          read -p "The minimum posterior probability of the molecular fingerprint(plimit_2) to be controled. 0.1-0.5 may work well. >>> " plimit2;
                        done;
                        tlimit=$(ls temp/ftaligntemp/filter_net_* | awk -F _ '{print $NF}')
                        check_rep=$(awk 'END{print NR}' <(echo "$tlimit"))
                        if [[ "$check_rep" > "1" ]]
                        then
                          tlimit=0
                          until [ -f temp/ftaligntemp/filter_net_$tlimit ]
                          do
                            read -p "Plural and different fragment_tree_network files were found to exist locally. Please select a tlimit parameter you have utilized to run fragment_tree_network_delta. >>> " tlimit;
                          done;
                        fi;
                        if [ -f temp/ftaligntemp/refilter_net_$tlimit ]
                        then rm temp/ftaligntemp/refilter_net_$tlimit
                        fi;
                        if [ -f temp/ftaligntemp/fpsample ]
                        then rm temp/ftaligntemp/fpsample
                        fi;
                        echo "Running delta_fingerprint computation..."
                        echo "Aquiring data from sirius index..."
                        data1="*_*/compound.info"
                        data2="temp/ftaligntemp/filter_net_$tlimit"
                        echo "Run fragment_tree_network_delta."
                        savepath="temp/ms_data_$tlimit"
                        echo "step 1: ms data"
                        if ! [ -f $savepath ]
                        then
                          awk -F "[\t]||[:]||[_]" -v OFS=$'\t' '
                          BEGIN{  
                          printf "..."
                          printf "id\t"  "m/z\t"  "rt\n" > "results/mz_and_rt.tsv"
                        }
                      {
                        if(FILENAME~/compound.info/)
                          {
                            if(FNR==1)
                              {
                                printf "Info: catch >>> "FILENAME"\n"
                              }
                            if($1=="name")
                              {
                                i+=1;
                                id[i]=$NF;
                                n=split($NF,a,"[_]")
                                printf a[n]"\t" >> "results/mz_and_rt.tsv"
                              }
                            if($1=="ionMass")
                              {
                                mz[id[i]]=$NF
                                printf sprintf("%.4f",$NF)"\t" >> "results/mz_and_rt.tsv"
                              }
                            if($1=="ionType")
                              {
                                type[id[i]]=$NF
                              }
                            if($1=="rt")
                              {
                                rt[id[i]]=$2;
                                printf sprintf("%.2f",$2/60)"\n" >> "results/mz_and_rt.tsv"
                              }
                          }
                        if(FILENAME~/ftaligntemp/)
                          {
                            #source  target  ftalign  delta_mz  delta_rt  source_iontype  target_iontype;
                            if(FNR==1)
                              {
                                printf "" > "'$savepath'"
                              }
                            print $1,$2,$3,sprintf("%.3f",mz[$2]-mz[$1]),sprintf("%.2f",rt[$2]-rt[$1]),type[$1],type[$2] \
                              >> "'$savepath'"
                            }
                        }' $data1 $data2
                            fi;
                            ########################
                            echo "step 2: data path"
                            source_file="temp/Mo_filename"
                            data="temp/ms_data_$tlimit"
                            savepath="temp/datapath_$tlimit"
                            if ! [ -f $savepath ]
                            then
                              awk -F $'\t' -v OFS=$'\t' '
                              {
                                if(NR==FNR)
                                  {
                                    n=split($2, a, "[_]")
                                    file[a[n]]=$2
                                    formu_type[a[n]]=$3
                                  }
                                if(NR!=FNR)
                                  {
                                    #<path>sourceFormula  <path>targetFormula
                                    path1=file[$1]"/fingerprints/"formu_type[$1]".fpt"
                                    path2=file[$2]"/fingerprints/"formu_type[$2]".fpt"
                                    data[path1]=path1
                                    data[path2]=path2
                                  }
                              }
                            END{
                            for(i in data)
                              {
                                n+=1
                                print "Check file:",n
                                if(getline<i==-1)
                                  {
                                    printf "Escape filename: " i "\n"
                                  }
                              else
                                {
                                  printf i" " > "'$savepath'"
                                }
                              close(i)
                            }
                          print "Sum:",n
                        }' $source_file $data
                                fi;
                                datapath=$(cat temp/datapath_$tlimit)
                                echo "step 3: fingerprint"
                                data_allfp="temp/data_allfp_$tlimit"
                                if ! [ -f $data_allfp ]
                                then
                                  awk -F $'\t' '
                                  BEGIN{
                                  n=0
                                }
                              {
                                if(FNR==1)
                                  {
                                    if(n>1)
                                      {
                                        close(file)
                                      }
                                    file=FILENAME;
                                    print "Get fingerprints: ",FILENAME
                                    n+=1;
                                    printf FILENAME"\n"$0"\n" > "'$data_allfp'"
                                  }
                              else
                                {
                                  print $0 > "'$data_allfp'"
                                }
                            }' $datapath
                                    fi;
                                    ###########################
                                    awk -F $'\t' -v OFS=$'\t' '
                                    {
                                      if(NR==1)
                                        {
                                          for(i=1; i<=NF; i++)
                                            {
                                              if($i~/absolute/)
                                                {
                                                  col_index=i
                                                }
                                              if($i~/description/)
                                                {
                                                  col_description=i
                                                }
                                            }
                                        }
                                      if(NR>=2)
                                        {
                                          print $col_index,$col_description
                                        }
                                    }' csi_fingerid.tsv > temp/ftaligntemp/pos_fingerprint_index;
                                  awk -F $'\t' -v OFS=$'\t' '
                                  {
                                    if(NR==1)
                                      {
                                        for(i=1; i<=NF; i++)
                                          {
                                            if($i~/absolute/)
                                              {
                                                col_index=i
                                              }
                                            if($i~/description/)
                                              {
                                                col_description=i
                                              }
                                          }
                                      }
                                    if(NR>=2)
                                      {
                                        print $col_index,$col_description
                                      }
                                  }' csi_fingerid_neg.tsv > temp/ftaligntemp/neg_fingerprint_index;
                                posindex="temp/ftaligntemp/pos_fingerprint_index"
                                negindex="temp/ftaligntemp/neg_fingerprint_index"
                                data="temp/ms_data_$tlimit"
                                echo "step 4: merge data"
                                awk -F $'\t' '
                                BEGIN{
                                file=0
                                x=0
                                count=0
                                f=0
                                posnum=0
                                negnum=0
                              }
                            {
                              if(FNR==1)
                                {
                                  file+=1
                                }
                              if(NR==FNR)
                                {
                                  if(($1~/fingerprint/))
                                    {
                                      if(x+0>f+0)
                                        {
                                          f=x  # calculate the max index.
                                        }
                                      count+=1;  # calculate the all fingerprints file number.
                                      split($1,a,"[/]"); e=split(a[1],b,"[_]"); id=b[e]; #catch the id.
                                      x=0;
                                    }
                                else
                                  {
                                    x+=1;
                                    fp[id,x]=$1;
                                  }
                              }
                            if(file==2)
                              {
                                pos[FNR]=$1
                                posnum+=1
                              }
                            if(file==3)
                              {
                                neg[FNR]=$1
                                negnum+=1
                              }
                            if(file==4)
                              {
                                if("'$tlimit'"+0 >= 0.3)
                                  {
                                    if(fp[$1,1]!="" && fp[$2,1]!="")
                                      {
                                        n1=split($6, g, "[]]");
                                        n2=split($7, h, "[]]");
                                        if(g[n1]=="+" && h[n2]=="+")
                                          {
                                            for(x=1; x<=posnum; x++)
                                              {
                                                if(fp[$1,x]+0>='$plimit'+0 && fp[$2,x]+0<='$plimit2'+0)
                                                  {
                                                    data_s[FNR,x]=pos[x]
                                                  }
                                              else if(fp[$2,x]+0>='$plimit'+0 && fp[$1,x]+0<='$plimit2'+0)
                                                {
                                                  data_t[FNR,x]=pos[x]
                                                }
                                            }
                                        }
                                      if(g[n1]=="-" && h[n2]=="-")
                                        {
                                          for(x=1; x<=negnum; x++)
                                            {
                                              if(fp[$1,x]+0>='$plimit'+0 && fp[$2,x]+0<='$plimit2'+0)
                                                {
                                                  data_s[FNR,x]=neg[x]
                                                }
                                            else if(fp[$2,x]+0>='$plimit'+0 && fp[$1,x]+0<='$plimit2'+0)
                                              {
                                                data_t[FNR,x]=neg[x]
                                              }
                                          }
                                      }
                                    if(g[n1]=="-" && h[n2]=="+" || h[n2]=="-" && g[n1]=="+")
                                      {
                                        for(i=1; i<=posnum; i++)
                                          {
                                            for(j=1; j<=negnum; j++)
                                              {
                                                if(pos[i]==neg[j])
                                                  {
                                                    mirror[i]=j  #if pos=i, the identical index of neg is mirror[i]
                                                  }
                                              }
                                          }
                                      }
                                    if(g[n1]=="-" && h[n2]=="+") 
                                      {
                                        for(x=1; x<=f; x++)
                                          {
                                            if(fp[$1,mirror[x]]+0>='$plimit'+0 && fp[$2,x]+0<='$plimit2'+0)
                                              {
                                                data_s[FNR,x]=neg[mirror[x]]
                                              }
                                          else if(fp[$2,x]+0>='$plimit'+0 && fp[$1,mirror[x]]+0<='$plimit2'+0)
                                            {
                                              data_t[FNR,x]=neg[mirror[x]]
                                            }
                                        }
                                    }
                                  if(h[n2]=="-" && g[n1]=="+")
                                    {
                                      for(x=1; x<=f; x++)
                                        {
                                          if(fp[$1,x]+0>= '$plimit'+0 && fp[$2,mirror[x]]+0<='$plimit2'+0)
                                            {
                                              data_s[FNR,x]=neg[mirror[x]]
                                            }
                                        else if(fp[$2,mirror[x]]+0>='$plimit'+0 && fp[$1,x]+0<='$plimit2'+0)
                                          {
                                            data_t[FNR,x]=neg[mirror[x]]
                                          }
                                      }   
                                  }
                              }
                          }
                        if(FNR==1)
                          {
                            printf "source\t"  "target\t"  "ftalign_similarity\t"  "delta_m/z\t"  "source_fp_uniq\t"  "target_fp_uniq\n"
                          }
                      else
                        {
                          printf $1"\t"  $2"\t"  $3"\t"  $4"\t";
                          if('$tlimit'+0 >= 0.3)
                            {
                              if(fp[$1,1]=="" || fp[$2,1]=="")
                                {
                                  printf "NA@NA\n"
                                }
                            else
                              {
                                printf "source:"  #the source fingerprint uniq.
                                for(x=1; x<=f; x++)
                                  {
                                    if(data_s[FNR,x]!="")
                                      {
                                        printf data_s[FNR,x]","
                                      }
                                  };
                                printf "@target:"  #the target fingerprint uniq.
                                for(x=1; x<=f; x++)
                                  {
                                    if(data_t[FNR,x]!="")
                                      {
                                        printf data_t[FNR,x]","
                                      }
                                  }
                                printf "\n"
                              }
                          }
                      else
                        {
                          printf "NA@NA\n"
                        }
                    }
                }
            }' $data_allfp $posindex $negindex $data | sed -e 's/,@/\t/g; s/,$//g; s/@/\t/g' \
              > results/source_target_tree_$tlimit.tsv;
                          echo "All instances have written into <results/source_target_tree_$tlimit.tsv>."
                          #####################################
                          echo "step 5: separate child-nebula from parent-nebula."
                          data="results/stat_classification.tsv"
                          savepath="temp/filter_0_class.tsv"
                          awk -F $'\t' '
                          {
                            if(FNR==1)
                              {
                                for(i=1; i<=NF; i++)
                                  {
                                    if($i~/^definition$/)
                                      {
                                        col_class=i
                                      }
                                  }
                              }
                            if(FNR>=2)
                              {
                                class[$col_class]=$col_class
                              }
                          }
                        END{
                        for(i in class)
                          {
                            printf class[i]"\n" > "'$savepath'"
                          }
                      }' $data
                    ######################################
                    data1="temp/filter_0_class.tsv" 
                    data2="results/canopus_pp.tsv"
                    data3="results/fingerid_first_score.tsv"
                    until [[ "$similarity_limit" > 0 ]] && [[ "$similarity_limit" < 1 ]]
                    do
                      read -p "Please set the Tanimoto similarity threshold contribute to child-nebula. >>> " similarity_limit;
                    done;
                    until [[ "$definition_limit" > 0.01 ]] && [[ "$definition_limit" < 1 ]]
                    do
                      read -p "Please enter the classes posterior probabilities limition. 0.5~0.99 may work well. >>> " definition_limit;
                    done;
                    class_pp_limit=$definition_limit
                    savepath="temp/idenfication_filter_$class_pp_limit.tsv"
                    awk -F $'\t' '
                    {
                      if(NR==FNR)
                        {
                          filter_class[$1]=$1
                        }
                      if(FILENAME~/canopus/)
                        {
                          if(FNR==1)
                            {
                              col_id=1
                              for(i=2; i<=NF; i++)
                                {
                                  for(j in filter_class)
                                    {
                                      if(j==$i)
                                        {
                                          col_class[j]=i
                                          print i
                                        }
                                    }
                                }
                            }
                          if(FNR>=2)
                            {
                              for(i in col_class)
                                {
                                  if(sprintf("%.3f",$col_class[i])+0>="'$class_pp_limit'"+0)
                                    {
                                      class_set[i,$col_id]=i
                                      print "ID: ",$1,i,$col_class[i]
                                    }
                                }
                            }
                        }
                      if(FILENAME~/fingerid_first_score/)
                        {
                          if(FNR==1)
                            {
                              for(i=1; i<=NF; i++)
                                {
                                  if($i~/^id/)
                                    {
                                      col_id=i
                                    }
                                  if($i~/similarity/)
                                    {
                                      col_similarity=i
                                    }
                                }
                              printf "class_nebula_facet\t"  $0"\n" > "'$savepath'"
                            }
                          if(FNR>=2)
                            {
                              if($col_similarity+0 >= "'$similarity_limit'"+0)
                                {
                                  for(i in class_set)
                                    {
                                      if(i~"\034"$col_id"$")
                                        {
                                          printf class_set[i]"\t"  $0"\n" > "'$savepath'"
                                        }
                                    }
                                }
                            }
                        }
                    }' $data1 $data2 $data3
                  ###################################
                  data="temp/idenfication_filter_$class_pp_limit.tsv"
                  savepath="temp/idenfication_filter2_${class_pp_limit}.tsv"
                  until [[ "$num_limit_1" -gt 0 ]]
                  do
                    read -p "Please enter the features number threshold contribute to child-nebula (min number). >>> " num_limit_1;
                  done;
                  until [[ "$num_limit_2" -gt "$num_limit_1" ]]
                  do
                    read -p "Please enter the features number threshold contribute to child-nebula (max number). >>> " num_limit_2;
                  done;
                  awk -F $'\t' '
                  {
                    if(FNR==1)
                      {
                        printf $0"\n" > "'$savepath'"
                        for(i=1; i<=NF; i++)
                          {
                            if($i~/class_nebula_facet/)
                              {
                                col_class=i
                              }
                          }
                      }
                    if(FNR>=2)
                      {
                        num[$col_class]+=1
                        data[FNR]=$0
                        class[FNR]=$col_class
                      }
                  }
                END{
                for(i in num)
                  {
                    if(num[i]+0 >= '$num_limit_1'+0 && num[i]+0 <= '$num_limit_2')
                      {
                        printf "The nodes number of the child-nebula is " num[i] ".\n"
                        for(j in class)
                          {
                            if(class[j]==i)
                              {
                                printf data[j]"\n" >> "'$savepath'"
                              }
                          }
                      }
                  }
              }' $data
            ##################################
            mkdir results/network_facet_$class_pp_limit
            data1="temp/idenfication_filter2_${class_pp_limit}.tsv"
            data2="results/source_target_tree_$tlimit.tsv" # "results/source_target_tree_0.4.tsv"
            save_class="results/filter_child_class.tsv"
            savepath="results/network_facet_$class_pp_limit/"
            awk -F $'\t' '
            {
              if(NR==FNR)
                {
                  if(FNR==1)
                    {
                      for(i=1; i<=NF; i++)
                        {
                          if($i~/class_nebula_facet/)
                            {
                              col_class=i
                            }
                          if($i~/^id$/)
                            {
                              col_id=i
                            }
                        }
                    }
                  if(FNR>=2)
                    {
                      class[$col_class]=$col_class
                      class_id[$col_class,$col_id]=$col_id
                      stat_id[$col_class,$col_id]=$col_id
                      belong[$col_class,$col_id]=$col_class
                    }
                }
              if(NR>FNR)
                {
                  if(FNR==1)
                    {
                      for(i in class)
                        {
                          printf i"\n" > "'$save_class'"
                          printf $0"\t"  "facet\n" > "'$savepath'" i ".tsv"
                        }
                    }
                  if(FNR>=2)
                    {
                      for(i in class)
                        {
                          if( class_id[i,$1]==$1 && class_id[i,$2]==$2 )
                            {
                              printf $0"\t"  i"\n" >> "'$savepath'" i ".tsv"
                              delete stat_id[i,$1]
                              delete stat_id[i,$2]
                            }
                        }
                    }
                }
            }
          END{
          for(i in stat_id)
            {
              ## source target similarity delta_mz fp fp class
              printf stat_id[i]"\t" stat_id[i]"\t"  "1\t"  "0\t"  "null\t"  "null\t"  belong[i]"\n" \
                >> "'$savepath'" belong[i] ".tsv"
              }
          }' $data1 $data2
        #####################
        data1="canopus.tsv"
        data2="results/filter_child_class.tsv"
        data3="results/canopus_pp.tsv"
        savepath="results/canopus_pp_filter.tsv"
        awk -F $'\t' '
        {
          if(FILENAME~/canopus.tsv/)
            {
              if(FNR==1)
                {
                  for(i=1; i<=NF; i++)
                    {
                      if($i~/absolute/)
                        {
                          col_index=i
                        }
                      if($i~/^id/)
                        {
                          col_chemid=i
                        }
                      if($i~/name/)
                        {
                          col_name=i
                        }
                      if($i~/description/)
                        {
                          col_des=i
                        }
                    }
                }
              if(FNR>2)
                {
                  ab_index[$col_name]=$col_index
                  chemid[$col_name]=$col_chemid
                  des[$col_name]=$col_des
                }
            }
          if(FILENAME~/filter_child_class/)
            {
              class[$1]=$1
              if(FNR==1)
                {
                  printf "index\t"  "chem_id\t"  "name\t"  "description\n" > "results/child_class.tsv"
                }
              printf ab_index[$1]"\t"  chemid[$1]"\t"  $1"\t"  des[$1]"\n" >> "results/child_class.tsv"
            }
          if(FILENAME~/canopus_pp/)
            {
              if(FNR==1)
                {
                  printf $1 > "'$savepath'"
                  for(i=2; i<=NF; i++)
                    {
                      if(class[$i]!="")
                        {
                          n+=1
                          printf "\tC"ab_index[$i] >> "'$savepath'"
                          col_set[n]=i
                        }
                    }
                  printf "\n" >> "'$savepath'"
                }
              if(FNR>=2)
                {
                  printf $1 >> "'$savepath'"
                  for(i=1; i<=n; i++)
                    {
                      printf "\t"$col_set[i] >> "'$savepath'"
                    }
                  printf "\n" >> "'$savepath'"
                }
            }
        }' $data1 $data2 $data3
      ;;
      ###################################
      ###################################
      compound_idenfication)
      echo "Run compound_idenfication."
      echo "compound_idenfication "
      exit
      ;;
      ###################################
      ###################################
      double_ion_network)
      exit;
      ;;
      ###################################
      ###################################
      ###################################
      ###################################
      exit)
      exit;
      ;;
      ###################################
      ###################################
      ###################################
      ###################################
      *)
      echo "error"
      exit;
      ;;
  esac;
done;#(for)
done;#(select)
```

# File: mcnebula1230.sh

```{r eval = F, echo = T}
## bin/bash

echo "We are all in the gutter, 
but some of us are looking at the stars.";
PS3='Please select the workflow to be executed. >>> '
select command in \
  "MCnebula_workflow" \
  "structure_extract" \
  "classification_extract_sum" \
  "classification_extract_filter" \
  "fragment_tree_network" \
  "fragment_tree_network_delta" \
  "structure_candidate_top" \
  "(beta)" \
  "exit" 
do
  if [[ $command == "MCnebula_workflow" ]]
  then
    confirm=0
    until [[ $confirm == "yes" ]] || [[ $confirm == "no" ]]
    do
      read -p "Running all proccesses sequentially? [yes/no] >>> " confirm
    done;
    if [[ $confirm == "no" ]]
    then exit
    fi;
    default="structure_extract classification_extract_sum classification_extract_filter fragment_tree_network fragment_tree_network_delta"
    list=$(echo $default);
  else list=$( echo $command)
  fi;
  for option in $(echo $list)
  do
    case $option in
      ###################################
      ###################################
      ###################################
      ###################################
      structure_extract)
      echo "Run structure_extract."
      projectpath=0
      until [ -d $projectpath ] && [ -f $projectpath/canopus_summary.tsv ] && [ -f $projectpath/.format ]
      do
        read -p "Please input the path of the sirius project >>> " projectpath;
      done;
      cd $projectpath;
      mkdir results;
      mkdir temp;
      mkdir temp/fintemp;
      if [ -f temp/Mo_filename ]
      then rm temp/Mo_filename
      fi;
      data="*_*/fingerid/*.tsv"
      awk -F $'\t' '
      BEGIN{
      all_id=0
      max_id=-1
      p_id="null"
      printf "Info: loading the data..."
    }
  {
    if(FNR==1)
      {
        if(NR>FNR)
          {
            close(pfile)
          }
        f=split(FILENAME,a,"[/]");
        n=split(a[1],b,"[_]");
        id=b[n];
        if(id!=p_id)
          {
            all_id+=1
            if(id>max_id)
              {
                max_id=id
              }
          }
        file[id]=a[1]
        split(a[f], g, "[.]")
        formu_type[id]=g[1]
        if(all_id==1)
          {
            for(i=1; i<=NF; i++)
              {
                if(($i~/inchikey2D/))
                  {
                    col_2D=i
                  }
                if($i=="inchi")
                  {
                    col_inchi=i
                  }
                if(($i~/Formula/))
                  {
                    col_formu=i
                  }
                if($i=="score")
                  {
                    col_score=i
                  }
                if($i=="name")
                  {
                    col_name=i
                  }
                if($i=="smiles")
                  {
                    col_smiles=i
                  }
                if($i=="xlogp")
                  {
                    col_x=i
                  }
                if(($i~/imilarity/))
                  {
                    col_simi=i
                  }
                if($i~/links/)
                  {
                    col_links=i
                  }
              }
          }
        pfile=FILENAME
        printf g[1]"\t"formu_type[id]"\n"
        printf "Info: the data of " id " (ID) has input. The filename is " FILENAME ".\n"
      }
    if(FNR>=2)
      {
        row_score=$col_score
        row_simi=$col_simi
        if(max["score",id]=="" || max["score",id]+0<row_score+0)
          {
            max["score",id]=row_score
            name["score",id]=$col_name
            formula["score",id]=$col_formu
            formu_type["score",id]=formu_type[id]
            simi["score",id]=$col_simi
            smiles["score",id]=$col_smiles
            inchi["score",id]=$col_inchi
            in2D["score",id]=$col_2D
            score["score",id]=$col_score
            xlogp["score",id]=$col_x
            links["score",id]=$col_links
          }
        if(max["simi",id]=="" || max["simi",id]+0<row_simi+0)
          {
            max["simi",id]=row_simi
            name["simi",id]=$col_name
            formula["simi",id]=$col_formu
            formu_type["simi",id]=formu_type[id]
            simi["simi",id]=$col_simi
            smiles["simi",id]=$col_smiles
            inchi["simi",id]=$col_inchi
            in2D["simi",id]=$col_2D
            score["simi",id]=$col_score
            xlogp["simi",id]=$col_x
            links["simi",id]=$col_links
          }
      }
  }
END{
printf "id\t"  "name\t"  "formula\t"  "similarity\t"  "smiles\t"  "inchi\t"  "inchikey2D\t"  "score\t"  "xlogp\t"  "links\n" > "results/fingerid_sum.tsv"
for(l in file)
  {
    if(max["score",l]!="")
      {
        printf l"\t"  name["score",l]"\t"  formula["score",l]"\t"  simi["score",l]"\t"  smiles["score",l]"\t"  inchi["score",l]"\t"  in2D["score",l]"\t"  score["score",l]"\t"  xlogp["score",l]"\t"  links["score",l]"\n" >> "results/fingerid_sum.tsv"
        printf formula["score",l]"\t"  file[l]"\t"  formu_type["score",l]"\n" > "temp/Mo_filename"
      }
    if(max["simi",l]!="" && max["simi",l]!=max["score",l])
      {
        printf l"\t"  name["simi",l]"\t"  formula["simi",l]"\t"  simi["simi",l]"\t"  smiles["simi",l]"\t"  inchi["simi",l]"\t"  in2D["simi",l]"\t"  score["simi",l]"\t"  xlogp["simi",l]"\t"  links["simi",l]"\n" >> "results/fingerid_sum.tsv"
      }
  }
}' $data
data_sum="results/fingerid_sum.tsv"
awk -F $'\t' '
{
  if(NR==1)
    {
      for(i=1; i<=NF; i++)
        {
          if($i~/id/)
            {
              col_id=i
            }
          if($i~/score/)
            {
              col_score=i
            }
        }
    }
  if(NR>=2)
    {
      id=$col_id
      if(max_id+0<id || max_id=="")
        {
          max_id=id
        }
      if(score[id]+0<$col_score+0 || score[id]=="")
        {
          score[id]=$col_score
          data[id]=$0
        }
    }
}
END{
printf "id\t"  "name\t"  "formula\t"  "similarity\t"  "smiles\t"  "inchi\t"  "inchikey2D\t"  "score\t"  "xlogp\t"  "links\n" > "results/fingerid_first_score.tsv"
for(i=1; i<=max_id; i++)
  {
    if(data[i]!="")
      {
        printf data[i] "\n" >> "results/fingerid_first_score.tsv"
      }
  }
}' $data_sum
echo "structure_extract results have been successfully assembled into <results/fingerid_sum.tsv> and <results/fingerid_first_score.tsv>";
;;
```

```{r eval = F, echo = T}
###################################
```

```{r eval = F, echo = T}
###################################
```

```{r eval = F, echo = T}
###################################
```

```{r eval = F, echo = T}
###################################
classification_extract_sum)
echo "Run classification_extract_sum.";
if [ -f temp/Mo_filename ] && [ -f canopus.tsv ] && [ -f canopus_neg.tsv ] && [ -f .format ]
then
  echo "Project path acknowledged."
else
  until [ -d $projectpath ] && [ -f $projectpath/canopus.tsv ] && [ -f $projectpath/.format ]
  do
    read -p "Please input the path of the sirius project >>> " projectpath;
  done;
  cd $projectpath;
fi;
data1="temp/Mo_filename"
data2="canopus.tsv"
data3="canopus_neg.tsv"
datas=$(awk -F $'\t' '
{
  x=$2"/canopus/"$3".fpt"
  if(getline < x == 1)
    {
      printf x" "
    }
  close(x)
}' $data1)
```

```{r eval = F, echo = T}
##################
awk -F $'\t' '
{
  if(NR==FNR)
    {
      i=split($2,s,"[_]")
      the_id[FNR]=s[i]
      n=FNR
    }
  if(FILENAME ~ /canopus.tsv/)
    {
      if(FNR==1)
        {
          for(i=1; i<=NF; i++)
            {
              if($i ~ /^name/)
                {
                  col_class=i
                }
              if($i ~ /absolute/)
                {
                  col_abindex=i
                }
            }
        }
      if(FNR>=2)
        {
          abindex[1,FNR]=$col_abindex
          indexset[$col_abindex]=$col_class
        }
    }
  if(FILENAME ~ /canopus_neg.tsv/)
    {
      p_filename=FILENAME
      if(FNR==1)
        {
          for(i=1; i<=NF; i++)
            {
              if($i ~ /name/)
                {
                  col_class=i
                }
              if($i ~ /absolute/)
                {
                  col_abindex=i
                }
            }
        }
      if(FNR>=2)
        {
          abindex[2,FNR]=$col_abindex
          indexset[$col_abindex]=$col_class
        }
    }
  if(FILENAME ~ /.fpt/)
    {
      if(FNR==1)
        {
          close(p_filename)
          printf "Info: data_file name of " p_filename " has been input.\n"
          p_filename=FILENAME
          split(FILENAME,a,"[/]");
          m=split(a[1],b,"[_]");
          id=b[m];
          if(FILENAME ~ /\+.fpt/)
            {
              ion=1
            }
          if(FILENAME ~ /\-.fpt/)
            {
              ion=2
            }
        }
      pp[id,abindex[ion,FNR+1]]=sprintf("%.3f",$1)
    }
}
END{
printf "id" > "results/canopus_pp.tsv"
for(i in indexset)
  {
    ord+=1
    orderlist[ord]=i
    printf "\t"indexset[i] >> "results/canopus_pp.tsv"
  }
printf "\n" >> "results/canopus_pp.tsv"
for(i=1; i<=n; i++)
  {
    printf the_id[i] >> "results/canopus_pp.tsv"
    for(j=1; j<=ord; j++)
      {
        if(pp[the_id[i],orderlist[j]]=="")
          {
            pp[the_id[i],orderlist[j]]=0
          }
        printf "\t"pp[the_id[i],orderlist[j]] >> "results/canopus_pp.tsv"
      }
    printf "\n" >> "results/canopus_pp.tsv"
  }
}' $data1 $data2 $data3 $datas
echo "classiication_extract_sum have been successfully written into <results/canopus_pp.tsv>"
;;
```

```{r eval = F, echo = T}
###################################
```

```{r eval = F, echo = T}
###################################
```

```{r eval = F, echo = T}
###################################
classification_extract_filter)
echo "Run classification_extract_filter.";
if [ -f results/canopus_pp.tsv ]
then
  echo "Project path acknowledged."
else
  until [ -d $projectpath ] && [ -f $projectpath/results/canopus_pp.tsv ] && [ -f $projectpath/results/canopus_summary.tsv ]
  do
    read -p "Please input the path of the sirius project >>> " projectpath;
  done;
  cd $projectpath;
fi; 
check=0
until [[ "$check" == "yes" ]] || [[ "$check" == "no" ]]
do
  read -p "Collate the posterior probabilities of the classification of each feature? [yes/no] >>> " check;
done;
if [[ $check == "yes" ]]
then
  definition_limit=0
  until [[ "$definition_limit" > "0.01" ]] && [[ "$definition_limit" < "1" ]]
  do
    read -p "Please enter the classes posterior probabilities limition. 0.5~0.99 may work well. >>> " definition_limit;
  done;
  data1="canopus_summary.tsv"
  data2="canopus.tsv"
  data3="results/canopus_pp.tsv"
  awk -F $'\t' '
  {
    if(NR==FNR)
      {
        if(FNR==1)
          {
            p_file=FILENAME
            for(i=1; i<=NF; i++)
              {
                if($i~/name/)
                  {
                    col_id=i
                  }
                if($i~/specific/)
                  {
                    col_specific=i
                  }
                if($i~/level/)
                  {
                    col_level=i
                  }
                if($i~/subclass/)
                  {
                    col_subclass=i
                  }
                if($i~/^class/)
                  {
                    col_class=i
                  }
                if($i~/superclass/)
                  {
                    col_superclass=i
                  }
              }
          }
        if(FNR>=2)
          {
            n=split($col_id,a,"[_]")
            id=a[n]
            specific[id]=$col_specific
            level[id]=$col_level
            subclass[id]=$col_subclass
            class[id]=$col_class
            superclass[id]=$col_superclass
          }
      }
    if(FILENAME~/canopus.tsv/)
      {
        if(FNR==1)
          {
            close(p_file)
            p_file=FILENAME
            for(i=1; i<=NF; i++)
              {
                if($i~/name/)
                  {
                    col_name=i
                  }
                if($i~/description/)
                  {
                    col_description=i
                  }
              }
          }
        if(FNR>=2)
          {
            description[$col_name]=$col_description
          }
      }
    if(FILENAME~"'$data3'")
      {
        if(FNR==1)
          {
            close(p_file)
            for(i=1; i<=NF; i++)
              {
                if($i~/^id$/)
                  {
                    col_id=i
                  }
                if(i>=2)
                  {
                    col_class_name[i]=$i
                  }
              }
            printf "id\t"  "definition_source\t"  "definition\t"  "definition_pp\t"  "definition_description\t"  "specific\t"  "specific_pp\t"  "level_5\t"  "level_5_pp\t"  "subclass\t"  "subclass_pp\t"  "class\t"  "class_pp\t"  "superclass\t"  "superclass_pp\n"  > "results/stat_classification.tsv"
          }
        if(FNR>=2)
          {
            for(i=2; i<=NF; i++)
              {
                c_pp[col_class_name[i]]=sprintf("%.4f",$i)
              }
            if(level[$col_id] != "" && c_pp[level[$col_id]] >= "'$definition_limit'")
              {
                definition_source="level_5"
                definition=level[$col_id]
              }
          else if(subclass[$col_id] != "" && c_pp[subclass[$col_id]] >= "'$definition_limit'")
            {
              definition_source="subclass"
              definition=subclass[$col_id]
            }
        else if(class[$col_id] != "" && c_pp[class[$col_id]] >= "'$definition_limit'")
          {
            definition_source="class"
            definition=class[$col_id]
          }
      else if(superclass[$col_id] != "" && c_pp[superclass[$col_id]] >= "'$definition_limit'")
        {
          definition_source="superclass"
          definition=superclass[$col_id]
        }
    else
      {
        definition_source="null"
        definition="null"
        c_pp[definition]="null"
        description[definition]="null"
      }
    printf $col_id"\t"  definition_source"\t"  definition"\t"  c_pp[definition]"\t"  description[definition]"\t"  specific[$col_id]"\t"  c_pp[specific[$col_id]]"\t"  level[$col_id]"\t"  c_pp[level[$col_id]]"\t"  subclass[$col_id]"\t"  c_pp[subclass[$col_id]]"\t"  class[$col_id]"\t"  c_pp[class[$col_id]]"\t"  superclass[$col_id]"\t"  c_pp[superclass[$col_id]]"\n" >> "results/stat_classification.tsv"
  }
}
}' $data1 $data2 $data3
echo "classification_extract_filter have been successfully written into <results/stat_classification.tsv>"
fi;
;;
```

```{r eval = F, echo = T}
###################################
```

```{r eval = F, echo = T}
###################################
```

```{r eval = F, echo = T}
###################################
```

```{r eval = F, echo = T}
###################################
fragment_tree_network)
echo "Run fragment_tree_network.";
if [ -d temp ] && [ -f ftalign.tsv ] && [ -f .format ]
then
  echo "Project path acknowledged."
else
  until [ -d $projectpath ] && [ -f $projectpath/ftalign.tsv ] && [ -f $projectpath/.format ]
  do
    read -p "Please input the path of the sirius project. Make sure you have moved the fragment tree alignment results to the directory where the project is located. >>> " projectpath;
  done;
  cd $projectpath;
fi;
echo "Please enter the minimum alignment similarity(tlimit) that you want to filter."
tlimit=0
until [[ "$tlimit" > "0.01" ]] && [[ "$tlimit" < "0.99" ]]
do
  read -p "0.4-0.7 is recommended >>> " tlimit;
done;
if ! [ -d temp/ftaligntemp ]
then 
  mkdir temp/ftaligntemp
fi;
data="ftalign.tsv"
savepath="temp/ftaligntemp/tmp"
awk -F $'\t' -v OFS=$'\t' '
{
  printf "Info: NR = " NR ". FNR = " FNR ".\n"
  if(NR==FNR)
    {
      for(i=1; i<=NF; i++)
        {
          if(NR==1 && i!=1 || NR!=1 && i==1)
            {
              n=split($i,x,"[_]")
              raw[NR,i]=x[n]
            }
        else
          {
            if(NR==i)
              {
                raw_norm[NR,i]=$i
              }
          }
      }
  }
if(NR>FNR && FNR>=2)
  {
    for(i=2; i<=NF; i++)
      {
        norm1=$i/raw_norm[i,i]
        norm2=$i/raw_norm[FNR,FNR]
        norms=sprintf("%.2f", ((norm1+norm2)/2))
        if((norms+0 > '$tlimit'+0))
          {
            if(raw[FNR,1]+0>=raw[1,i]+0)
              {
                print raw[FNR,1], raw[1,i], norms > "'$savepath'"
              }
            if(raw[FNR,1]+0<raw[1,i]+0)
              {
                print raw[1,i], raw[FNR,1], norms > "'$savepath'"
              }
          }
      }
  }
}' $data $data
sort -u $savepath > temp/ftaligntemp/tmp2
savepath="temp/ftaligntemp/filter_net_$tlimit"
awk -F $'\t' '
{
  if(NR==FNR)
    {
      if($1!=$2)
        {
          replink[$1]=$1
          replink[$2]=$2
        }
    }
  if(NR!=FNR)
    {
      if($1!=$2)
        {
          printf $0"\n" > "'$savepath'" 
        } 
      if($1==$2)
        {
          if(replink[$1]=="")
            {
              printf $0"\n" > "'$savepath'"
            }
        }
    }
}' temp/ftaligntemp/tmp2 temp/ftaligntemp/tmp2
echo "fragment_tree_network have been successfully written into <temp/ftaligntemp/filter_net_$tlimit>"
;;
```

```{r eval = F, echo = T}
###################################
```

```{r eval = F, echo = T}
###################################
```

```{r eval = F, echo = T}
###################################
```

```{r eval = F, echo = T}
###################################
fragment_tree_network_delta)
if [ -d temp ] && [ -f ftalign.tsv ] && [ -f .format ]
then
  echo "Project path acknowledged."
else
  until [ -d $projectpath ] && [ -f $projectpath/ftalign.tsv ] && [ -f $projectpath/.format ]
  do
    read -p "Please input the path of the sirius project >>> " projectpath;
  done;
  cd $projectpath;
fi;
echo "The following module attempts to compute the differential fingerprints of connected clusters based on the molecular fingerprint results of sirius 4."
```

```{r eval = F, echo = T}
###################
```

```{r eval = F, echo = T}
###################
```

```{r eval = F, echo = T}
###################
plimit=0
until [[ "$plimit" > "0.5" ]] && [[ "$plimit" < "0.99" ]]
do
  read -p "If the minimum alignment similarity is greater than 0.3, this step will automatic calculate the discrepancy fingerprint between alignment features(in beta). Please enter the minimum posterior probability of the molecular fingerprint(plimit_1) to be filtered. 0.9-0.99 is recommended. >>> " plimit;
done;
plimit2=0
until [[ "$plimit2" > "0.1" ]] && [[ "$plimit2" < "$plimit" ]]
do
  read -p "The minimum posterior probability of the molecular fingerprint(plimit_2) to be controled. 0.1-0.5 may work well. >>> " plimit2;
done;
tlimit=$(ls temp/ftaligntemp/filter_net_* | awk -F _ '{print $NF}')
check_rep=$(awk 'END{print NR}' <(echo "$tlimit"))
if [[ "$check_rep" > "1" ]]
then
  tlimit=0
  until [ -f temp/ftaligntemp/filter_net_$tlimit ]
  do
    read -p "Plural and different fragment_tree_network files were found to exist locally. Please select a tlimit parameter you have utilized to run fragment_tree_network_delta. >>> " tlimit;
  done;
fi;
if [ -f temp/ftaligntemp/refilter_net_$tlimit ]
then rm temp/ftaligntemp/refilter_net_$tlimit
fi;
if [ -f temp/ftaligntemp/fpsample ]
then rm temp/ftaligntemp/fpsample
fi;
echo "Running delta_fingerprint computation..."
echo "Aquiring data from sirius index..."
data1="*_*/compound.info"
data2="temp/ftaligntemp/filter_net_$tlimit"
echo "Run fragment_tree_network_delta."
savepath="temp/ms_data_$tlimit"
echo "step 1: ms data"
if ! [ -f $savepath ]
then
  awk -F "[\t]||[:]||[_]" -v OFS=$'\t' '
  BEGIN{  
  printf "..."
  printf "id\t"  "m/z\t"  "rt\n" > "results/mz_and_rt.tsv"
}
{
  if(FILENAME~/compound.info/)
    {
      if(FNR==1)
        {
          printf "Info: catch >>> "FILENAME"\n"
        }
      if($1=="name")
        {
          i+=1;
          id[i]=$NF;
          n=split($NF,a,"[_]")
          printf a[n]"\t" >> "results/mz_and_rt.tsv"
        }
      if($1=="ionMass")
        {
          mz[id[i]]=$NF
          printf sprintf("%.4f",$NF)"\t" >> "results/mz_and_rt.tsv"
        }
      if($1=="ionType")
        {
          type[id[i]]=$NF
        }
      if($1=="rt")
        {
          rt[id[i]]=$2;
          printf sprintf("%.2f",$2/60)"\n" >> "results/mz_and_rt.tsv"
        }
    }
  if(FILENAME~/ftaligntemp/)
    {
      #source  target  ftalign  delta_mz  delta_rt  source_iontype  target_iontype;
      if(FNR==1)
        {
          printf "" > "'$savepath'"
        }
      print $1,$2,$3,sprintf("%.3f",mz[$2]-mz[$1]),sprintf("%.2f",rt[$2]-rt[$1]),type[$1],type[$2]  >> "'$savepath'"
    }
}' $data1 $data2
fi;
```

```{r eval = F, echo = T}
########################
echo "step 2: data path"
source_file="temp/Mo_filename"
data="temp/ms_data_$tlimit"
savepath="temp/datapath_$tlimit"
if ! [ -f $savepath ]
then
  awk -F $'\t' -v OFS=$'\t' '
  {
    if(NR==FNR)
      {
        n=split($2, a, "[_]")
        file[a[n]]=$2
        formu_type[a[n]]=$3
      }
    if(NR!=FNR)
      {
        #<path>sourceFormula  <path>targetFormula
        path1=file[$1]"/fingerprints/"formu_type[$1]".fpt"
        path2=file[$2]"/fingerprints/"formu_type[$2]".fpt"
        data[path1]=path1
        data[path2]=path2
      }
  }
END{
for(i in data)
  {
    n+=1
    print "Check file:",n
    if(getline<i==-1)
      {
        printf "Escape filename: " i "\n"
      }
  else
    {
      printf i" " > "'$savepath'"
    }
  close(i)
}
print "Sum:",n
}' $source_file $data
fi;
datapath=$(cat temp/datapath_$tlimit)
echo "step 3: fingerprint"
data_allfp="temp/data_allfp_$tlimit"
if ! [ -f $data_allfp ]
then
  awk -F $'\t' '
  BEGIN{
  n=0
}
{
  if(FNR==1)
    {
      if(n>1)
        {
          close(file)
        }
      file=FILENAME;
      print "Get fingerprints: ",FILENAME
      n+=1;
      printf FILENAME"\n"$0"\n" > "'$data_allfp'"
    }
else
  {
    print $0 > "'$data_allfp'"
  }
}' $datapath
fi;
```

```{r eval = F, echo = T}
###########################
awk -F $'\t' -v OFS=$'\t' '
{
  if(NR==1)
    {
      for(i=1; i<=NF; i++)
        {
          if($i~/absolute/)
            {
              col_index=i
            }
          if($i~/description/)
            {
              col_description=i
            }
        }
    }
  if(NR>=2)
    {
      print $col_index,$col_description
    }
}' csi_fingerid.tsv > temp/ftaligntemp/pos_fingerprint_index;
awk -F $'\t' -v OFS=$'\t' '
{
  if(NR==1)
    {
      for(i=1; i<=NF; i++)
        {
          if($i~/absolute/)
            {
              col_index=i
            }
          if($i~/description/)
            {
              col_description=i
            }
        }
    }
  if(NR>=2)
    {
      print $col_index,$col_description
    }
}' csi_fingerid_neg.tsv > temp/ftaligntemp/neg_fingerprint_index;
posindex="temp/ftaligntemp/pos_fingerprint_index"
negindex="temp/ftaligntemp/neg_fingerprint_index"
data="temp/ms_data_$tlimit"
echo "step 4: merge data"
awk -F $'\t' '
BEGIN{
file=0
x=0
count=0
f=0
posnum=0
negnum=0
}
{
  if(FNR==1)
    {
      file+=1
    }
  if(NR==FNR)
    {
      if(($1~/fingerprint/))
        {
          if(x+0>f+0)
            {
              f=x  # calculate the max index.
            }
          count+=1;  # calculate the all fingerprints file number.
          split($1,a,"[/]"); e=split(a[1],b,"[_]"); id=b[e]; #catch the id.
          x=0;
        }
    else
      {
        x+=1;
        fp[id,x]=$1;
      }
  }
if(file==2)
  {
    pos[FNR]=$1
    posnum+=1
  }
if(file==3)
  {
    neg[FNR]=$1
    negnum+=1
  }
if(file==4)
  {
    if("'$tlimit'"+0 >= 0.3)
      {
        if(fp[$1,1]!="" && fp[$2,1]!="")
          {
            n1=split($6, g, "[]]");
            n2=split($7, h, "[]]");
            if(g[n1]=="+" && h[n2]=="+")
              {
                for(x=1; x<=posnum; x++)
                  {
                    if(fp[$1,x]+0>='$plimit'+0 && fp[$2,x]+0<='$plimit2'+0)
                      {
                        data_s[FNR,x]=pos[x]
                      }
                  else if(fp[$2,x]+0>='$plimit'+0 && fp[$1,x]+0<='$plimit2'+0)
                    {
                      data_t[FNR,x]=pos[x]
                    }
                }
            }
          if(g[n1]=="-" && h[n2]=="-")
            {
              for(x=1; x<=negnum; x++)
                {
                  if(fp[$1,x]+0>='$plimit'+0 && fp[$2,x]+0<='$plimit2'+0)
                    {
                      data_s[FNR,x]=neg[x]
                    }
                else if(fp[$2,x]+0>='$plimit'+0 && fp[$1,x]+0<='$plimit2'+0)
                  {
                    data_t[FNR,x]=neg[x]
                  }
              }
          }
        if(g[n1]=="-" && h[n2]=="+" || h[n2]=="-" && g[n1]=="+")
          {
            for(i=1; i<=posnum; i++)
              {
                for(j=1; j<=negnum; j++)
                  {
                    if(pos[i]==neg[j])
                      {
                        mirror[i]=j  #if pos=i, the identical index of neg is mirror[i]
                      }
                  }
              }
          }
        if(g[n1]=="-" && h[n2]=="+") 
          {
            for(x=1; x<=f; x++)
              {
                if(fp[$1,mirror[x]]+0>='$plimit'+0 && fp[$2,x]+0<='$plimit2'+0)
                  {
                    data_s[FNR,x]=neg[mirror[x]]
                  }
              else if(fp[$2,x]+0>='$plimit'+0 && fp[$1,mirror[x]]+0<='$plimit2'+0)
                {
                  data_t[FNR,x]=neg[mirror[x]]
                }
            }
        }
      if(h[n2]=="-" && g[n1]=="+")
        {
          for(x=1; x<=f; x++)
            {
              if(fp[$1,x]+0>= '$plimit'+0 && fp[$2,mirror[x]]+0<='$plimit2'+0)
                {
                  data_s[FNR,x]=neg[mirror[x]]
                }
            else if(fp[$2,mirror[x]]+0>='$plimit'+0 && fp[$1,x]+0<='$plimit2'+0)
              {
                data_t[FNR,x]=neg[mirror[x]]
              }
          }   
      }
  }
}
if(FNR==1)
  {
    printf "source\t"  "target\t"  "ftalign_similarity\t"  "delta_m/z\t"  "source_fp_uniq\t"  "target_fp_uniq\n"
  }
else
  {
    printf $1"\t"  $2"\t"  $3"\t"  $4"\t";
    if('$tlimit'+0 >= 0.3)
      {
        if(fp[$1,1]=="" || fp[$2,1]=="")
          {
            printf "NA@NA\n"
          }
      else
        {
          printf "source:"  #the source fingerprint uniq.
          for(x=1; x<=f; x++)
            {
              if(data_s[FNR,x]!="")
                {
                  printf data_s[FNR,x]","
                }
            };
          printf "@target:"  #the target fingerprint uniq.
          for(x=1; x<=f; x++)
            {
              if(data_t[FNR,x]!="")
                {
                  printf data_t[FNR,x]","
                }
            }
          printf "\n"
        }
    }
else
  {
    printf "NA@NA\n"
  }
}
}
}' $data_allfp $posindex $negindex $data | sed -e 's/,@/\t/g; s/,$//g; s/@/\t/g'  > results/source_target_tree_$tlimit.tsv;
echo "All instances have written into <results/source_target_tree_$tlimit.tsv>."
```

```{r eval = F, echo = T}
#####################################
echo "step 5: separate child-nebula from parent-nebula."
data="results/stat_classification.tsv"
savepath="temp/filter_0_class.tsv"
awk -F $'\t' '
{
  if(FNR==1)
    {
      for(i=1; i<=NF; i++)
        {
          if($i~/^definition$/)
            {
              col_class=i
            }
        }
    }
  if(FNR>=2)
    {
      class[$col_class]=$col_class
    }
}
END{
for(i in class)
  {
    printf class[i]"\n" > "'$savepath'"
  }
}' $data
```

```{r eval = F, echo = T}
######################################
data1="temp/filter_0_class.tsv" 
data2="results/canopus_pp.tsv"
data3="results/fingerid_first_score.tsv"
until [[ "$similarity_limit" > 0 ]] && [[ "$similarity_limit" < 1 ]]
do
  read -p "Please set the Tanimoto similarity threshold contribute to child-nebula. >>> " similarity_limit;
done;
until [[ "$definition_limit" > 0.01 ]] && [[ "$definition_limit" < 1 ]]
do
  read -p "Please enter the classes posterior probabilities limition. 0.5~0.99 may work well. >>> " definition_limit;
done;
class_pp_limit=$definition_limit
savepath="temp/idenfication_filter_$class_pp_limit.tsv"
awk -F $'\t' '
{
  if(NR==FNR)
    {
      filter_class[$1]=$1
    }
  if(FILENAME~/canopus/)
    {
      if(FNR==1)
        {
          col_id=1
          for(i=2; i<=NF; i++)
            {
              for(j in filter_class)
                {
                  if(j==$i)
                    {
                      col_class[j]=i
                      print i
                    }
                }
            }
        }
      if(FNR>=2)
        {
          for(i in col_class)
            {
              if(sprintf("%.3f",$col_class[i])+0>="'$class_pp_limit'"+0)
                {
                  class_set[i,$col_id]=i
                  print "ID: ",$1,i,$col_class[i]
                }
            }
        }
    }
  if(FILENAME~/fingerid_first_score/)
    {
      if(FNR==1)
        {
          for(i=1; i<=NF; i++)
            {
              if($i~/^id/)
                {
                  col_id=i
                }
              if($i~/similarity/)
                {
                  col_similarity=i
                }
            }
          printf "class_nebula_facet\t"  $0"\n" > "'$savepath'"
        }
      if(FNR>=2)
        {
          if($col_similarity+0 >= "'$similarity_limit'"+0)
            {
              for(i in class_set)
                {
                  if(i~"\034"$col_id"$")
                    {
                      printf class_set[i]"\t"  $0"\n" > "'$savepath'"
                    }
                }
            }
        }
    }
}' $data1 $data2 $data3
```

```{r eval = F, echo = T}
###################################
data="temp/idenfication_filter_$class_pp_limit.tsv"
savepath="temp/idenfication_filter2_${class_pp_limit}.tsv"
until [[ "$num_limit_1" -gt 0 ]]
do
  read -p "Please enter the features number threshold contribute to child-nebula (min number). >>> " num_limit_1;
done;
until [[ "$num_limit_2" -gt "$num_limit_1" ]]
do
  read -p "Please enter the features number threshold contribute to child-nebula (max number). >>> " num_limit_2;
done;
awk -F $'\t' '
{
  if(FNR==1)
    {
      printf $0"\n" > "'$savepath'"
      for(i=1; i<=NF; i++)
        {
          if($i~/class_nebula_facet/)
            {
              col_class=i
            }
        }
    }
  if(FNR>=2)
    {
      num[$col_class]+=1
      data[FNR]=$0
      class[FNR]=$col_class
    }
}
END{
for(i in num)
  {
    if(num[i]+0 >= '$num_limit_1'+0 && num[i]+0 <= '$num_limit_2')
      {
        printf "The nodes number of the child-nebula is " num[i] ".\n"
        for(j in class)
          {
            if(class[j]==i)
              {
                printf data[j]"\n" >> "'$savepath'"
              }
          }
      }
  }
}' $data
```

```{r eval = F, echo = T}
##################################
mkdir results/network_facet_$class_pp_limit
data1="temp/idenfication_filter2_${class_pp_limit}.tsv"
data2="results/source_target_tree_$tlimit.tsv" # "results/source_target_tree_0.4.tsv"
save_class="results/filter_child_class.tsv"
savepath="results/network_facet_$class_pp_limit/"
awk -F $'\t' '
{
  if(NR==FNR)
    {
      if(FNR==1)
        {
          for(i=1; i<=NF; i++)
            {
              if($i~/class_nebula_facet/)
                {
                  col_class=i
                }
              if($i~/^id$/)
                {
                  col_id=i
                }
            }
        }
      if(FNR>=2)
        {
          class[$col_class]=$col_class
          class_id[$col_class,$col_id]=$col_id
          stat_id[$col_class,$col_id]=$col_id
          belong[$col_class,$col_id]=$col_class
        }
    }
  if(NR>FNR)
    {
      if(FNR==1)
        {
          for(i in class)
            {
              printf i"\n" > "'$save_class'"
              printf $0"\t"  "facet\n" > "'$savepath'" i ".tsv"
            }
        }
      if(FNR>=2)
        {
          for(i in class)
            {
              if( class_id[i,$1]==$1 && class_id[i,$2]==$2 )
                {
                  printf $0"\t"  i"\n" >> "'$savepath'" i ".tsv"
                  delete stat_id[i,$1]
                  delete stat_id[i,$2]
                }
            }
        }
    }
}
END{
for(i in stat_id)
  {
    ## source target similarity delta_mz fp fp class
    printf stat_id[i]"\t" stat_id[i]"\t"  "1\t"  "0\t"  "null\t"  "null\t"  belong[i]"\n"  >> "'$savepath'" belong[i] ".tsv"
  }
}' $data1 $data2
```

```{r eval = F, echo = T}
#####################
data1="canopus.tsv"
data2="results/filter_child_class.tsv"
data3="results/canopus_pp.tsv"
savepath="results/canopus_pp_filter.tsv"
awk -F $'\t' '
{
  if(FILENAME~/canopus.tsv/)
    {
      if(FNR==1)
        {
          for(i=1; i<=NF; i++)
            {
              if($i~/absolute/)
                {
                  col_index=i
                }
              if($i~/^id/)
                {
                  col_chemid=i
                }
              if($i~/name/)
                {
                  col_name=i
                }
              if($i~/description/)
                {
                  col_des=i
                }
            }
        }
      if(FNR>2)
        {
          ab_index[$col_name]=$col_index
          chemid[$col_name]=$col_chemid
          des[$col_name]=$col_des
        }
    }
  if(FILENAME~/filter_child_class/)
    {
      class[$1]=$1
      if(FNR==1)
        {
          printf "index\t"  "chem_id\t"  "name\t"  "description\n" > "results/child_class.tsv"
        }
      printf ab_index[$1]"\t"  chemid[$1]"\t"  $1"\t"  des[$1]"\n" >> "results/child_class.tsv"
    }
  if(FILENAME~/canopus_pp/)
    {
      if(FNR==1)
        {
          printf $1 > "'$savepath'"
          for(i=2; i<=NF; i++)
            {
              if(class[$i]!="")
                {
                  n+=1
                  printf "\tC"ab_index[$i] >> "'$savepath'"
                  col_set[n]=i
                }
            }
          printf "\n" >> "'$savepath'"
        }
      if(FNR>=2)
        {
          printf $1 >> "'$savepath'"
          for(i=1; i<=n; i++)
            {
              printf "\t"$col_set[i] >> "'$savepath'"
            }
          printf "\n" >> "'$savepath'"
        }
    }
}' $data1 $data2 $data3
;;
```

```{r eval = F, echo = T}
###################################
```

```{r eval = F, echo = T}
###################################
structure_candidate_top)
echo "structure_candidate_top (awk version ≥ 3.1)."
projectpath=0
until [ -d $projectpath ] && [ -f $projectpath/.format ]
do
  read -p "Please input the path of the sirius project >>> " projectpath;
done;
cd $projectpath;
if [ -d results ]
then echo "Expand into target dir <results>"
else mkdir results
  mkdir temp
  mkdir temp/fintemp;
fi;
## gather all structure candidate
data="*_*/fingerid/*.tsv"
awk -F $'\t' '
BEGIN{
all_id=0
max_id=-1
p_id="null"
printf "Info: loading the data..."
}
{
  if(FNR==1)
    {
      if(NR>FNR)
        {
          close(pfile)
        }
      f=split(FILENAME,a,"[/]");
      n=split(a[1],b,"[_]");
      id=b[n];
      if(id!=p_id)
        {
          all_id+=1
          if(id>max_id)
            {
              max_id=id
            }
        }
      file[id]=a[1]
      split(a[f], g, "[.]")
      formu_type[id]=g[1]
      if(all_id==1)
        {
          printf "id\t"  "name\t"  "formula\t"  "similarity\t"  "smiles\t"  "inchi\t"  "inchikey2D\t"  "score\t"  "xlogp\t"  "links\n" > "results/fingerid_candidate_all.tsv"
          targetfile="results/fingerid_candidate_all.tsv"
          for(i=1; i<=NF; i++)
            {
              if(($i~/inchikey2D/))
                {
                  col_2D=i
                }
              if($i=="inchi")
                {
                  col_inchi=i
                }
              if(($i~/Formula/))
                {
                  col_formu=i
                }
              if($i=="score")
                {
                  col_score=i
                }
              if($i=="name")
                {
                  col_name=i
                }
              if($i=="smiles")
                {
                  col_smiles=i
                }
              if($i=="xlogp")
                {
                  col_x=i
                }
              if(($i~/imilarity/))
                {
                  col_simi=i
                }
              if($i~/links/)
                {
                  col_links=i
                }
            }
        }
      pfile=FILENAME
      printf g[1]"\t"formu_type[id]"\n"
      printf "Info: the data of " id " (ID) has input. The filename is " FILENAME ".\n"
    }
  if(FNR>=2)
    {
    ##  "id\t"  "name\t"  "formula\t"  "similarity\t"  "smiles\t"  "inchi\t"  "inchikey2D\t"  "score\t"  "xlogp\t"  "links\n" > targetfile
    printf id"\t" $col_name"\t" $col_formu"\t" $col_simi"\t" $col_smiles"\t" $col_inchi"\t" $col_2D"\t" $col_score"\t" $col_x"\t" $col_links"\n" > targetfile
    }
} ' $data
## sort the candidates to get top 20 
version=0
version=$(awk 'BEGIN{a[1]=1; asort(a, b); print b[1]}')
if [ $version != 1 ]
then
  echo "Awk version ≤ 3.1. Function <asort> not available."
fi
top_n=20
data="results/fingerid_candidate_all.tsv"
awk -F $'\t' '
{
  if(FNR==1)
    {
      printf "id\t"  "name\t"  "formula\t"  "similarity\t"  "smiles\t"  "inchi\t"  "inchikey2D\t"  "score\t"  "xlogp\t"  "links\n" > "results/fingerid_candidate_top.tsv"
      targetfile="results/fingerid_candidate_top.tsv"
      for(i=1; i<=NF; i++)
        {
          if($i~/^id$/)
            {
              col_id=i
            }
          if($i~/^score/)
            {
              col_score=i
            }
        }
    }
  if(FNR>=2)
    {
      if(id!=$col_id)
        {
          ## output data top10
          if(id!="")
            {
              j=asort(score, a)
              for(i=j; i>=(j-'$top_n'); i--)
                {
                  if(i==0)
                    {
                      break
                    }
                  if(data[a[i]]=="")
                    {
                      print "yes"
                    }
                  printf data[a[i]]"\n" > targetfile
                }
              delete data
              delete score
            }
          ## gather first row of the id
          n=1
          score[n]=$col_score
          if(data[$col_score]!="")
            {
              $col_score+=0.00000001
            }
          data[$col_score]=$0
        }
    else
        {
          n+=1
          score[n]=$col_score
          if(data[$col_score]!="")
            {
              $col_score+=0.00000001
            }
          data[$col_score]=$0
        }
      id=$col_id
    }
}
END{
{
  j=asort(score, a)
  for(i=j; i>=j-'$top_n'; i--)
    {
      if(i==0)
        {
          break
        }
      printf data[a[i]]"\n" > targetfile
    }
}
}' $data
exit
;;
```

```{r eval = F, echo = T}
###################################
```

```{r eval = F, echo = T}
###################################
"(beta)")
exit;
;;
```

```{r eval = F, echo = T}
###################################
```

```{r eval = F, echo = T}
###################################
```

```{r eval = F, echo = T}
###################################
```

```{r eval = F, echo = T}
###################################
exit)
echo "The mystery of creation is like the darkness of night--it is great.
Delusions of knowledge are like the fog of the morning."
exit;
;;
```

```{r eval = F, echo = T}
###################################
```

```{r eval = F, echo = T}
###################################
```

```{r eval = F, echo = T}
###################################
```

```{r eval = F, echo = T}
###################################
*)
echo "error"
exit;
;;
esac;
done;#(for)
done;#(select)
```

# File: mdmn0717.sh

```{r eval = F, echo = T}
##########################
```

```{r eval = F, echo = T}
##########################
echo "We are all in the gutter, 
but some of us are looking at the stars.";

PS3='Please select the workflow to be executed. >>> '

select command in \
  	\
 	"default" \
 	\
 	"structure_extract" \
 	\
 	"classification_extract_sum" \
 	\
 	"classification_extract_filter" \
 	\
 	"fragment_tree_network" \
 	\
 	"fragment_tree_network_delta" \
 	\
 	"compound_idenfication" \
 	\
 	"double_ion_network" \
 	\
 	"exit" 
do
	
	if [[ $command == "default" ]]
	then
	
	confirm=0
	
	 	until [[ $confirm == "yes" ]] || [[ $confirm == "no" ]]
	 	do
	 	read -p "Running all proccesses sequentially? [yes/no] >>> " confirm
	 	done;
	 	if [[ $confirm == "no" ]]
	 	then exit
	 	fi;
	 	
	default="structure_extract classification_extract_sum classification_extract_filter fragment_tree_network fragment_tree_network_delta"
	
	list=$(echo $default);
	
	else list=$( echo $command)
	fi;
	
	for option in $(echo $list)
	do
	 	case $option in
```

```{r eval = F, echo = T}
###################################
```

```{r eval = F, echo = T}
###################################
```

```{r eval = F, echo = T}
###################################
```

```{r eval = F, echo = T}
###################################
structure_extract)
echo "Run structure_extract."
projectpath=0
	until [ -d $projectpath ] && [ -f $projectpath/canopus_summary.tsv ] && [ -f $projectpath/.format ]
	do
	read -p "Please input the path of the sirius project >>> " projectpath;
	done;
	
cd $projectpath;
mkdir results;
mkdir temp;
mkdir temp/fintemp;

	if [ -f temp/Mo_filename ]
	then rm temp/Mo_filename
	fi;

data="*_*/fingerid/*.tsv"

awk -F $'\t' '
 	BEGIN{
 	 	all_id=0
 	 	\
 	 	max_id=-1
 	 	\
 	 	p_id="null"
 	 	\
 	 	printf "Info: loading the data..."
 	 	}
 	{
 	if(FNR==1)
 	 	{
 	 	if(NR>FNR)
 	 	 	{
 	 	 	close(pfile)
 	 	 	}
 	 	split(FILENAME,a,"[/]");
 	
 	 	n=split(a[1],b,"[_]");
 	
 	 	id=b[n];
 	
 	 	if(id!=p_id)
 	 	 	{
 	 	 	all_id+=1
 	 	 	\
 	 	 	if(id>max_id)
 	 	 	 	{
 	 	 	 	max_id=id
 	 	 	 	}
 	 	 	}
 	 	file[id]=a[1]
 	 	
 	 	if(all_id==1)
 	 	 	{
 	 	 	for(i=1; i<=NF; i++)
 	 	 	 	{
 	 	 	 	if(($i~/inchikey2D/))
 	 	 	 	 	{
 	 	 	 	 	col_2D=i
 	 	 	 	 	}
 	 	 	 	if($i=="inchi")
 	 	 	 	 	{
 	 	 	 	 	col_inchi=i
 	 	 	 	 	}
 	 	 	 	if(($i~/Formula/))
 	 	 	 	 	{
 	 	 	 	 	col_formu=i
 	 	 	 	 	}
 	 	 	 	if($i=="score")
 	 	 	 	 	{
 	 	 	 	 	col_score=i
 	 	 	 	 	}
 	 	 	 	if($i=="name")
 	 	 	 	 	{
 	 	 	 	 	col_name=i
 	 	 	 	 	}
 	 	 	 	if($i=="smiles")
 	 	 	 	 	{
 	 	 	 	 	col_smiles=i
 	 	 	 	 	}
 	 	 	 	if($i=="xlogp")
 	 	 	 	 	{
 	 	 	 	 	col_x=i
 	 	 	 	 	}
 	 	 	 	if(($i~/imilarity/))
 	 	 	 	 	{
 	 	 	 	 	col_simi=i
 	 	 	 	 	}
 	 	 	 	if($i~/links/)
 	 	 	 	 	{
 	 	 	 	 	col_links=i
 	 	 	 	 	}
 	 	 	 	}
 	 	 	}
 	 	pfile=FILENAME
 	 	
 	 	printf "Info: the data of " id " (ID) has input. The filename is " FILENAME ".\n"
 	 	}
 	if(FNR>=2)
 	 	{
 	 	row_score=$col_score
 	 	
 	 	row_simi=$col_simi
 	 	
 	 	if(max["score",id]=="" || max["score",id]<row_score)
	 	 	{
 	 	 	max["score",id]=row_score
 	 	 	
 	 	 	name["score",id]=$col_name
 	 	
 	 	 	formula["score",id]=$col_formu
 	 	 	
 	 	 	simi["score",id]=$col_simi
 	 	
 	 	 	smiles["score",id]=$col_smiles
 	 	
 	 	 	inchi["score",id]=$col_inchi
 	 	
 	 	 	in2D["score",id]=$col_2D
 	 	 	
 	 	 	score["score",id]=$col_score
 	 	
 	 	 	xlogp["score",id]=$col_x
 	 	 	
 	 	 	links["score",id]=$col_links
 	 	 	}
 	 	if(max["simi",id]=="" || max["simi",id]<row_simi)
	 	 	{
 	 	 	max["simi",id]=row_simi
 	 	 	
 	 	 	name["simi",id]=$col_name
 	 	
 	 	 	formula["simi",id]=$col_formu
 	 	 	
 	 	 	simi["simi",id]=$col_simi
 	 	
 	 	 	smiles["simi",id]=$col_smiles
 	 	
 	 	 	inchi["simi",id]=$col_inchi

 	 	 	in2D["simi",id]=$col_2D
 	 	 	
 	 	 	score["simi",id]=$col_score
 	 	 
 	 	 	xlogp["simi",id]=$col_x
 	 	 	
 	 	 	links["simi",id]=$col_links
 	 	 	}
 	 	}
 	}
 	END{
 	 	printf "id\t"  "name\t"  "formula\t"  "similarity\t"  "smiles\t"  "inchi\t"  "inchikey2D\t" \
 	 	\
 	 	"score\t"  "xlogp\t"  "links\n" > "results/fingerid_sum.tsv"
 	 	\
 	 	for(l=1; l<=max_id; l++)
 	 	 	{
 	 	 	if(max["score",l]!="")
 	 	 	 	{
 	 	 	 	printf l"\t" \
 	 	 	 	\
 	 	 	 	name["score",l]"\t"  formula["score",l]"\t"  simi["score",l]"\t" \
 	 	 	 	\
 	 	 	 	smiles["score",l]"\t"  inchi["score",l]"\t"  in2D["score",l]"\t" \
 	 	 	 	\
 	 	 	 	score["score",l]"\t"  xlogp["score",l]"\t"  links["score",l]"\n" >> "results/fingerid_sum.tsv"
 	 	 	 	
 	 	 	 	printf formula["score",l]"\t"  file[l]"\n" >> "temp/Mo_filename"
 	 	 	 	}
 	 	 	if(max["simi",l]!="" && max["simi",l]!=max["score",l])
 	 	 	 	{
 	 	 	 	printf l"\t" \
 	 	 	 	\
 	 	 	 	name["simi",l]"\t"  formula["simi",l]"\t"  simi["simi",l]"\t" \
 	 	 	 	\
 	 	 	 	smiles["simi",l]"\t"  inchi["simi",l]"\t"  in2D["simi",l]"\t" \
 	 	 	 	\
 	 	 	 	score["simi",l]"\t"  xlogp["simi",l]"\t"  links["simi",l]"\n" >> "results/fingerid_sum.tsv"
 	 	 	 	}
 	 	 	}
 	 	}' $data

data_sum="results/fingerid_sum.tsv"

awk -F $'\t' '
 	{
 	if(NR==1)
 	 	{
 	 	for(i=1; i<=NF; i++)
 	 	 	{
 	 	 	if($i~/id/)
 	 	 	 	{
 	 	 	 	col_id=i
 	 	 	 	}
 	 	 	if($i~/score/)
 	 	 	 	{
 	 	 	 	col_score=i
 	 	 	 	}
 	 	 	}
 	 	}
 	if(NR>=2)
 	 	{
 	 	id=$col_id
 	 	\
 	 	if(max_id<id || max_id=="")
 	 	 	{
 	 	 	max_id=id
 	 	 	}
 	 	if(score[id]<$col_score || score[id]=="")
 	 	 	{
 	 	 	score[id]=$col_score
 	 	 	\
 	 	 	data[id]=$0
 	 	 	}
 	 	}
 	}
 	END{
 	 	printf "id\t"  "name\t"  "formula\t"  "similarity\t"  "smiles\t"  "inchi\t"  "inchikey2D\t" \
 	 	\
 	 	"score\t"  "xlogp\t"  "links\n" > "results/fingerid_first_score.tsv"
 	 	\
 	 	for(i=1; i<=max_id; i++)
 	 	 	{
 	 	 	if(data[i]!="")
 	 	 	 	{
 	 	 	 	printf data[i] "\n" >> "results/fingerid_first_score.tsv"
 	 	 	 	}
 	 	 	}
 	 	}' $data_sum

echo "structure_extract results have been successfully assembled into <results/fingerid_sum.tsv> and <results/fingerid_first_score.tsv>";
;;
```

```{r eval = F, echo = T}
###################################
```

```{r eval = F, echo = T}
###################################
```

```{r eval = F, echo = T}
###################################
```

```{r eval = F, echo = T}
###################################
classification_extract_sum)

echo "Run classification_extract_sum.";
	if [ -f temp/Mo_filename ] && [ -f canopus.tsv ] && [ -f canopus_neg.tsv ] && [ -f .format ]
	then
	echo "Project path acknowledged."
	else
	 	until [ -d $projectpath ] && [ -f $projectpath/canopus.tsv ] && [ -f $projectpath/.format ]
	 	do
	 	read -p "Please input the path of the sirius project >>> " projectpath;
	 	done;
	 	cd $projectpath;
	fi;
	
data1="temp/Mo_filename"

data2="canopus.tsv"

data3="canopus_neg.tsv"

datas=$(awk -F $'\t' '
 	{
 	if(system("test -f " $2 "/canopus/" $1 "*.fpt"))
 	 	{
 	 	printf ""
 	 	}
 	else
 	 	{
 	 	printf $2 "/canopus/" $1 "*.fpt "
 	 	}
 	}' $data1)
	
awk -F $'\t' '
 	{
 	if(NR==FNR)
 	 	{
 	 	file[FNR]=$2
 	 	
 	 	mo[$2]=$1
 	 	
 	 	i=split($2,s,"[_]")
 	 	
 	 	the_id[FNR]=s[i]
 	 	
 	 	n=FNR
 	 	}
 	if((FILENAME ~ /'$data2'/))
 	 	{
 	 	if(FNR==1)
 	 	 	{
 	 	 	close("'$data1'")
 	 	 	
 	 	 	printf "Info: data_file name of '$data1' has been input.\n"
 	 	 	
 	 	 	for(i=1; i<=NF; i++)
 	 	 	 	{
 	 	 	 	if(($i ~ /name/))
 	 	 	 	 	{
 	 	 	 	 	col_class=i
 	 	 	 	 	}
 	 	 	 	if(($i ~ /absolute/))
 	 	 	 	 	{
 	 	 	 	 	col_abindex=i
 	 	 	 	 	}
 	 	 	 	}
 	 	 	}
 	 	if(FNR>=2)
 	 	 	{
 	 	 	abindex[1,FNR]=$col_abindex
 	 	 	
 	 	 	class[1,$col_abindex]=$col_class
 	 	 	
 	 	 	rows_data2=FNR
 	 	 	}
 	 	}
 	if((FILENAME ~ /'$data3'/))
 	 	{
 	 	if(FNR==1)
 	 	 	{
 	 	 	close("'$data2'")
 	 	 	
 	 	 	printf "Info: data_file name of '$data2' has been input.\n"
 	 	 	
 	 	 	for(i=1; i<=NF; i++)
 	 	 	 	{
 	 	 	 	if(($i ~ /name/))
 	 	 	 	 	{
 	 	 	 	 	col_class=i
 	 	 	 	 	}
 	 	 	 	if(($i ~ /absolute/))
 	 	 	 	 	{
 	 	 	 	 	col_abindex=i
 	 	 	 	 	}
 	 	 	 	}
 	 	 	}
 	 	if(FNR>=2)
 	 	 	{
 	 	 	abindex[2,FNR]=$col_abindex
 	 	 	
 	 	 	class[2,$col_abindex]=$col_class
 	 	 	
 	 	 	rows_data3=FNR
 	 	 	}
 	 	}
 	if((FILENAME ~ /fpt/))
 	 	{
 	 	if(FNR==1)
 	 	 	{
 	 	 	if(p_filename=="")
 	 	 	 	{
 	 	 	 	close("'$data3'")
 	 	 	 	}
 	 	 	else if(FILENAME!=p_filename)
 	 	 	 	{
 	 	 	 	close(p_filename)
 	 	 	 	
 	 	 	 	printf "Info: data_file name of " p_filename " has been input.\n"
 	 	 	 	}
 	 	 	p_filename=FILENAME
 	 	 	\
 	 	 	for(i=1; i<=n; i++)
 	 	 	 	{
 	 	 	 	if((FILENAME ~ file[i]) && (FILENAME ~ mo[file[i]]))
 	 	 	 	 	{
 	 	 	 	 	break
 	 	 	 	 	}
 	 	 	 	else
 	 	 	 	 	{
 	 	 	 	 	x=i+1
 	 	 	 	 	}
 	 	 	 	}
 	 	 	if(x==n+1)
 	 	 	 	{
 	 	 	 	nextfile
 	 	 	 	}
 	 	 	split(FILENAME,a,"[/]");

 	 	 	m=split(a[1],b,"[_]");

 	 	 	id=b[m];

 	 	 	if((FILENAME ~ /\+.fpt/))
 	 	 	 	{
 	 	 	 	ion=1
 	 	 	 	}
 	 	 	else
 	 	 	 	{
 	 	 	 	ion=2
 	 	 	 	}
 	 	 	pp[id,abindex[ion,2]]=$1
 	 	 	}
 	 	if(FNR>=2)
 	 	 	{
 	 	 	pp[id,abindex[ion,FNR+1]]=$1
 	 	 	}
 	 	}
 	}
 	END{
 	 	if(abindex[1,rows_data2] > abindex[2,rows_data3])
 	 	 	{
 	 	 	maxindex=abindex[1,rows_data2]
 	 	 	}
 	 	else
 	 	 	{
 	 	 	maxindex=abindex[2,rows_data3]
 	 	 	}
 	 	printf "id\t" > "results/canopus_pp.tsv"
 	 	\
 	 	for(i=0; i<=maxindex; i++)
 	 	 	{
 	 	 	if(class[1,i]!="" && i!=maxindex)
 	 	 	 	{
 	 	 	 	printf class[1,i]"\t" >> "results/canopus_pp.tsv"
 	 	 	 	}
 	 	 	else if(class[2,i]!="" && i!=maxindex)
 	 	 	 	{
 	 	 	 	printf class[2,i]"\t" >> "results/canopus_pp.tsv"
 	 	 	 	}
 	 	 	else if(i==maxindex && class[1,i]!="")
 	 	 	 	{
 	 	 	 	printf class[1,i]"\n" >> "results/canopus_pp.tsv"
 	 	 	 	}
 	 	 	else if(i==maxindex && class[2,i]!="")
 	 	 	 	{
 	 	 	 	printf class[2,i]"\n" >> "results/canopus_pp.tsv"
 	 	 	 	}
 	 	 	}
 	 	for(i=1; i<=n; i++)
 	 	 	{
 	 	 	printf the_id[i]"\t" >> "results/canopus_pp.tsv"
 	 	 	
 	 	 	for(j=0; j<=maxindex; j++)
 	 	 	 	{
 	 	 	 	if(class[1,j]!="" && j!=maxindex || class[2,j]!="" && j!=maxindex)
 	 	 	 	 	{
 	 	 	 	 	if(pp[the_id[i],j]=="")
 	 	 	 	 	 	{
 	 	 	 	 	 	printf 0"\t" >> "results/canopus_pp.tsv"
 	 	 	 	 	 	}
 	 	 	 	 	else
 	 	 	 	 	 	{
 	 	 	 	 	 	printf pp[the_id[i],j]"\t" >> "results/canopus_pp.tsv"
 	 	 	 	 	 	}
 	 	 	 	 	}
 	 	 	 	else if(class[1,j]!="" && j==maxindex || class[2,j]!="" && j==maxindex)
 	 	 	 	 	{
 	 	 	 	 	if(pp[the_id[i],j]=="")
 	 	 	 	 	 	{
 	 	 	 	 	 	printf 0"\n" >> "results/canopus_pp.tsv"
 	 	 	 	 	 	}
 	 	 	 	 	else
 	 	 	 	 	 	{
 	 	 	 	 	 	printf pp[the_id[i],j]"\n" >> "results/canopus_pp.tsv"
 	 	 	 	 	 	}
 	 	 	 	 	}
 	 	 	 	}
 	 	 	}
 	 	}' $data1 $data2 $data3 $datas

echo "classification_extract_sum have been successfully written into <results/canopus_pp.tsv>"
;;
```

```{r eval = F, echo = T}
###################################
```

```{r eval = F, echo = T}
###################################
```

```{r eval = F, echo = T}
###################################

classification_extract_filter)
echo "Run classification_extract_filter.";
	if [ -f results/canopus_pp.tsv ]
	then
	echo "Project path acknowledged."
	else
	 	until [ -d $projectpath ] && [ -f $projectpath/results/canopus_pp.tsv ] && [ -f $projectpath/results/canopus_summary.tsv ]
	 	do
	 	read -p "Please input the path of the sirius project >>> " projectpath;
	 	done;
	 	cd $projectpath;
	fi;	
	
check=0
	until [[ "$check" == "yes" ]] || [[ "$check" == "no" ]]
	do
	read -p "Collate the posterior probabilities of the classification of each feature? [yes/no] >>> " check;
	done;
	
	if [[ $check == "yes" ]]
	then
	definition_limit=0
	
	 	until [[ "$definition_limit" > "0.01" ]] && [[ "$definition_limit" < "1" ]]
	 	do
	 	read -p "Please enter the posterior probabilities limition. 0.5~0.99 may work well. >>> " definition_limit;
	 	done;
	
	data1="canopus_summary.tsv"
 
 	data2="canopus.tsv"
 
 	data3="results/canopus_pp.tsv"
	
	awk -F $'\t' '
	 	{
	 	if(NR==FNR)
	 	 	{
	 	 	if(FNR==1)
	 	 	 	{
	 	 	 	p_file=FILENAME
	 	 	 	\
	 	 	 	for(i=1; i<=NF; i++)
	 	 	 	 	{
		 	 	 	if($i~/name/)
		 	 	 	 	{
		 	 	 	 	col_id=i
		 	 	 	 	}
		 	 	 	if($i~/specific/)
		 	 	 	 	{
		 	 	 	 	col_specific=i
		 	 	 	 	}
		 	 	 	if($i~/level/)
		 	 	 	 	{
		 	 	 	 	col_level=i
		 	 	 	 	}
		 	 	 	if($i~/subclass/)
		 	 	 	 	{
		 	 	 	 	col_subclass=i
		 	 	 	 	}
		 	 	 	if($i~/^class/)
		 	 	 	 	{
		 	 	 	 	col_class=i
		 	 	 	 	}
		 	 	 	if($i~/superclass/)
		 	 	 	 	{
		 	 	 	 	col_superclass=i
		 	 	 	 	}
	 	 	 	 	}
	 	 	 	}
	 	 	if(FNR>=2)
	 	 	 	{
	 	 	 	n=split($col_id,a,"[_]")
	 	 	 	\
	 	 	 	id=a[n]
	 	 	 	\
	 	 	 	specific[id]=$col_specific
	 	 	 	\
	 	 	 	level[id]=$col_level
	 	 	 	\
	 	 	 	subclass[id]=$col_subclass
	 	 	 	\
	 	 	 	class[id]=$col_class
	 	 	 	\
	 	 	 	superclass[id]=$col_superclass
	 	 	 	}
	 	 	}
	 	if(FILENAME~/canopus.tsv/)
	 	 	{
	 	 	if(FNR==1)
	 	 	 	{
	 	 	 	close(p_file)
	 	 	 	\
	 	 	 	p_file=FILENAME
	 	 	 	\
	 	 	 	for(i=1; i<=NF; i++)
	 	 	 	 	{
		 	 	 	if($i~/name/)
		 	 	 	 	{
		 	 	 	 	col_name=i
		 	 	 	 	}
		 	 	 	if($i~/description/)
		 	 	 	 	{
		 	 	 	 	col_description=i
		 	 	 	 	}
	 	 	 	 	}
	 	 	 	}
	 	 	if(FNR>=2)
	 	 	 	{
	 	 	 	description[$col_name]=$col_description
	 	 	 	}
	 	 	}
	 	if(FILENAME~"'$data3'")
	 	 	{
	 	 	if(FNR==1)
	 	 	 	{
	 	 	 	close(p_file)
	 	 	 	\
	 	 	 	for(i=1; i<=NF; i++)
	 	 	 	 	{
	 	 	 	 	if($i~/^id$/)
	 	 	 	 	 	{
	 	 	 	 	 	col_id=i
	 	 	 	 	 	}
	 	 	 	 	if(i>=2)
	 	 	 	 	 	{
	 	 	 	 	 	col_class_name[i]=$i
	 	 	 	 	 	}
	 	 	 	 	}
	 	 	 	printf "id\t"  "definition_source\t"  "definition\t"  "definition_pp\t"  "definition_description\t" \
	 	 	 	\
	 	 	 	"specific\t"  "specific_pp\t"  "level_5\t"  "level_5_pp\t" \
	 	 	 	\
	 	 	 	"subclass\t"  "subclass_pp\t"  "class\t"  "class_pp\t"  "superclass\t"  "superclass_pp\n" \
	 	 	 	\
	 	 	 	> "results/stat_classification.tsv"
	 	 	 	}
	 	 	if(FNR>=2)
	 	 	 	{
	 	 	 	for(i=2; i<=NF; i++)
	 	 	 	 	{
	 	 	 	 	c_pp[col_class_name[i]]=sprintf("%.4f",$i)
	 	 	 	 	}
	 	 	 	if(level[$col_id] != "" && c_pp[level[$col_id]] >= "'$definition_limit'")
	 	 	 	 	{
	 	 	 	 	definition_source="level_5"
	 	 	 	 	\
	 	 	 	 	definition=level[$col_id]
	 	 	 	 	}
	 	 	 	else if(subclass[$col_id] != "" && c_pp[subclass[$col_id]] >= "'$definition_limit'")
	 	 	 	 	{
	 	 	 	 	definition_source="subclass"
	 	 	 	 	\
	 	 	 	 	definition=subclass[$col_id]
	 	 	 	 	}
	 	 	 	else if(class[$col_id] != "" && c_pp[class[$col_id]] >= "'$definition_limit'")
	 	 	 	 	{
	 	 	 	 	definition_source="class"
	 	 	 	 	\
	 	 	 	 	definition=class[$col_id]
	 	 	 	 	}
	 	 	 	else if(superclass[$col_id] != "" && c_pp[superclass[$col_id]] >= "'$definition_limit'")
	 	 	 	 	{
	 	 	 	 	definition_source="superclass"
	 	 	 	 	\
	 	 	 	 	definition=superclass[$col_id]
	 	 	 	 	}
	 	 	 	else
	 	 	 	 	{
	 	 	 	 	definition_source="null"
	 	 	 	 	\
	 	 	 	 	definition="null"
	 	 	 	 	\
	 	 	 	 	c_pp[definition]="null"
	 	 	 	 	\
	 	 	 	 	description[definition]="null"
	 	 	 	 	}
	 	 	 	printf $col_id"\t"  definition_source"\t"  definition"\t"  c_pp[definition]"\t"  description[definition]"\t" \
	 	 	 	\
	 	 	 	specific[$col_id]"\t"  c_pp[specific[$col_id]]"\t"  level[$col_id]"\t"  c_pp[level[$col_id]]"\t" \
	 	 	 	\
	 	 	 	subclass[$col_id]"\t"  c_pp[subclass[$col_id]]"\t"  class[$col_id]"\t"  c_pp[class[$col_id]]"\t" \
	 	 	 	\
	 	 	 	superclass[$col_id]"\t"  c_pp[superclass[$col_id]]"\n" >> "results/stat_classification.tsv"
	 	 	 	}
	 	 	}
	 	}' $data1 $data2 $data3
 	
 	echo "classification_extract_filter have been successfully written into <results/stat_classification.tsv>"
 	
 	fi;
;;
```

```{r eval = F, echo = T}
###################################
```

```{r eval = F, echo = T}
###################################
```

```{r eval = F, echo = T}
###################################
```

```{r eval = F, echo = T}
###################################
fragment_tree_network)

echo "Run fragment_tree_network.";

	if [ -d temp ] && [ -f ftalign.tsv ] && [ -f .format ]
	then
	echo "Project path acknowledged."
	
	else
	 	until [ -d $projectpath ] && [ -f $projectpath/ftalign.tsv ] && [ -f $projectpath/.format ]
	 	do
	 	read -p "Please input the path of the sirius project. Make sure you have moved the fragment tree alignment results to the directory where the project is located. >>> " projectpath;
	 	done;
	 	cd $projectpath;
	fi;

echo "Please enter the minimum alignment similarity that you want to filter."

tlimit=0
	until [[ "$tlimit" > "0.1" ]] && [[ "$tlimit" < "0.9" ]]
	do
	read -p "0.4-0.7 is recommended >>> " tlimit;
	done;

mkdir temp/ftaligntemp

data=ftalign.tsv

ftalign=$(awk -F $'\t' -v OFS=$'\t' '
 	{
 	for(i=1; i<=NF; i++)
 	 	{
 	 	if(NR==1 && i!=1 || NR!=1 && i==1)
 	 	 	{
 	 	 	n=split($i,x,"[_]")
 	 	 	\
 	 	 	raw[NR,i]=x[n]
 	 	 	}
 	 	else
 	 	 	{
 	 	 	raw[NR,i]=$i
 	 	 	}
 	 	}
 	}
	END{
 	 	for(a=2; a<=NR; a++)
 	 	 	{
	 	 	for(b=2; b<=NF; b++)
	 	 	 	{
	 	 	 	norm1[a,b]=raw[a,b]/raw[a,a];
	 	 	 	\
	 	 	 	norm2[a,b]=raw[a,b]/raw[b,b];
	 	 	 	\
	 	 	 	norms[a,b]=(norm1[a,b]+norm2[a,b])/2;
	 	 	 	\
	 	 	 	if(norms[a,b]>='$tlimit' && norms[a,b]<=0.999)
	 	 	 	 	{
	 	 	 	 	if(raw[a,1]>=raw[1,b])
	 	 	 	 	 	{
	 	 	 	 	 	print raw[a,1],raw[1,b],norms[a,b]
	 	 	 	 	 	}
	 	 	 	 	else
	 	 	 	 	 	{
	 	 	 	 	 	print raw[1,b],raw[a,1],norms[a,b]
	 	 	 	 	 	}
	 	 	 	 	}
	 	  	 	}
	  	 	}
 	 	}' $data)
 	
sort <(echo "$ftalign") | uniq > temp/ftaligntemp/filter_net_$tlimit

echo "fragment_tree_network have been successfully written into <temp/ftaligntemp/filter_net_$tlimit>"
;;

```

```{r eval = F, echo = T}
###################################
```

```{r eval = F, echo = T}
###################################
```

```{r eval = F, echo = T}
###################################
```

```{r eval = F, echo = T}
###################################

fragment_tree_network_delta)

	if [ -d temp ] && [ -f ftalign.tsv ] && [ -f .format ]
	then
	echo "Project path acknowledged."
	else
	 	until [ -d $projectpath ] && [ -f $projectpath/ftalign.tsv ] && [ -f $projectpath/.format ]
	 	do
	 	read -p "Please input the path of the sirius project >>> " projectpath;
	 	done;
	cd $projectpath;
	fi;
echo "The following module attempts to compute the differential fingerprints of connected clusters based on the molecular fingerprint results of sirius 4."

```

```{r eval = F, echo = T}
###################
```

```{r eval = F, echo = T}
###################
```

```{r eval = F, echo = T}
###################

plimit=0
	until [[ "$plimit" > "0.5" ]] && [[ "$plimit" < "0.99" ]]
	do
	read -p "Please enter the minimum posterior probability of the molecular fingerprint to be filtered. 0.9-0.99 is recommended. >>> " plimit;
	done;

plimit2=0
	until [[ "$plimit2" > "0.1" ]] && [[ "$plimit2" < "$plimit" ]]
	do
	read -p "The minimum posterior probability of the molecular fingerprint to be controled. 0.1-0.5 may work well. >>> " plimit2;
	done;
	
tlimit=$(ls temp/ftaligntemp/filter_net_* | awk -F _ '{print $NF}')

check_rep=$(awk 'END{print NR}' <(echo "$tlimit"))

	if [[ "$check_rep" > "1" ]]
	then
	 	until [ -f temp/ftaligntemp/filter_net_$tlimit ]
	 	do
	 	read -p "Plural and different fragment_tree_network files were found to exist locally. Please select a tlimit parameter you have utilized to run fragment_tree_network_delta. >>> " tlimit;
	 	done;
	fi;
	
	
	if [ -f temp/ftaligntemp/refilter_net_$tlimit ]
	then rm temp/ftaligntemp/refilter_net_$tlimit
	fi;
	
	if [ -f temp/ftaligntemp/fpsample ]
	then rm temp/ftaligntemp/fpsample
	fi;

echo "Running delta_fingerprint computation..."

echo "Aquiring data from sirius index..."

data1="*_*/compound.info"

data2="temp/ftaligntemp/filter_net_$tlimit"

echo "Run fragment_tree_network_delta."

data=$(awk -F ["\t":_"\]"] -v OFS=$'\t' '
 	BEGIN{
 	 	printf "id\t"  "m/z\t"  "rt\n" > "results/mz_and_rt.tsv"
 	 	}
 	{
 	if(FILENAME~/compound.info/)
 	 	{
 	 	if($1=="name")
 	 	 	{
 	 	 	i+=1;
 	 	 	
 	 	 	id[i]=$NF;
 	 	 	
 	 	 	n=split($NF,a,"[_]")
 	 	 	
 	 	 	printf a[n]"\t" >> "results/mz_and_rt.tsv"
 	 	 	}
 	 	if($1=="ionMass")
 	 	 	{
 	 	 	mz[id[i]]=$NF
 	 	 	
 	 	 	printf sprintf("%.4f",$NF)"\t" >> "results/mz_and_rt.tsv"
 	 	 	}
 	 	if($1=="ionType")
 	 	 	{
 	 	 	type[id[i]]=$NF
 	 	 	}
 	 	if($1=="rt")
 	 	 	{
 	 	 	rt[id[i]]=$2;
 	 	 	
 	 	 	printf sprintf("%.2f",$NF)"\n" >> "results/mz_and_rt.tsv"
 	 	 	}
 	 	}
 	if(FILENAME~/ftaligntemp/)
 	 	{
 	 	#source  target  ftalign  delta_mz  delta_rt  source_iontype  target_iontype;
 	 	
 	 	print $1,$2,$3,sprintf("%.3f",mz[$2]-mz[$1]),sprintf("%.2f",rt[$2]-rt[$1]),type[$1],type[$2]
 	 	}
 	}' $data1 $data2)
 	
data_path=$(awk -F ["\t"_] -v OFS=$'\t' '
 	{
 	if(NR==FNR)
 	 	{
 	 	mo[$NF]=$1
 	 	}
 	if(NR!=FNR)
 	 	{
 	 	if(mo[$1]!="" && mo[$2]!="")
 	 	 	{
 	 	 	\
 	 	 	#<path>sourceFormula  <path>targetFormula
 	 	 	\
 	 	 	printf "*_" $1 "/fingerprints/" mo[$1] "*\n"   "*_" $2 "/fingerprints/" mo[$2] "*\n"
 	 	 	}
 	 	}
 	}' temp/Mo_filename <(echo "$data") | sort -u | awk '
 	{
 	if(system("test -f " $1))
 	 	{
 	 	printf ""
 	 	}
 	else
 	 	{
 	 	print $1
 	 	}
 	}' | paste -d " " -s)
 	
data_allfp=$(awk -F $'\t' -v OFS=$'\t' '
 	BEGIN{
 	 	n=0
 	 	}
 	{
 	if(FNR==1)
 	 	{
 	 	if(n>=1)
 	 	 	{
 	 	 	close(file)
 	 	 	}
 	 	file=FILENAME;
 	 	\
 	 	n+=1;
 	 	\
 	 	printf FILENAME"\n"$0"\n"
 	 	}
 	else
 	 	{
 	 	print $0
 	 	}
 	}' $data_path)
 	
awk -F $'\t' -v OFS=$'\t' '{if(NR>=2){print $2,$3}}' csi_fingerid.tsv > temp/ftaligntemp/pos_fingerprint_index;

awk -F $'\t' -v OFS=$'\t' '{if(NR>=2){print $2,$3}}' csi_fingerid_neg.tsv > temp/ftaligntemp/neg_fingerprint_index;

posindex=$(awk -F $'\t' '{print $1}' temp/ftaligntemp/pos_fingerprint_index)

negindex=$(awk -F $'\t' '{print $1}' temp/ftaligntemp/neg_fingerprint_index)

awk -F $'\t' '
 	BEGIN{
 	 	file=0
 	 	x=0
 	 	count=0
 	 	f=0
 	 	posnum=0
 	 	negnum=0
 	 	}
 	{
 	if(FNR==1)
 	 	{
 	 	file+=1
 	 	}
 	if(NR==FNR)
 	 	{
 	 	if(($1~/fingerprint/))
 	 	 	{
 	 	 	if(x>f)
 	 	 	 	{
 	 	 	 	f=x  # calculate the max index.
 	 	 	 	}
 	 	 	count+=1;  # calculate the all fingerprints file number.
 	 	 	\
 	 	 	split($1,a,"[/]"); e=split(a[1],b,"[_]"); id=b[e]; #catch the id.
 	 	 	\
 	 	 	x=0;
 	 	 	}
 	 	else
 	 	 	{
 	 	 	x+=1;
 	 	 	\
 	 	 	fp[id,x]=$1;
 	 	 	}
 	 	}
 	if(file==2)
 	 	{
 	 	pos[FNR]=$1
 	 	posnum+=1
 	 	}
 	if(file==3)
 	 	{
 	 	neg[FNR]=$1
 	 	negnum+=1
 	 	}
 	if(file==4)
 	 	{
 	 	if(fp[$1,1]!="" && fp[$2,1]!="")
 	 	 	{
 	 	 	if($6=="+" && $7=="+")
 	 	 	 	{
 	 	 	 	for(x=1; x<=posnum; x++)
 	 	 	 	 	{
 	 	 	 	 	if(fp[$1,x]>='$plimit' && fp[$2,x]<='$plimit2')
	 	 	 	 	 	{
	 	 	 	 	 	data_s[FNR,x]=pos[x]
	 	 	 	 	 	}
	 	 	 	 	else if(fp[$2,x]>='$plimit' && fp[$1,x]<='$plimit2')
	 	 	 	 	 	{
	 	 	 	 	 	data_t[FNR,x]=pos[x]
	 	 	 	 	 	}
 	 	 	 	 	}
 	 	 	 	}
 	 	 	if($6=="-" && $7=="-")
 	 	 	 	{
 	 	 	 	for(x=1; x<=negnum; x++)
 	 	 	 	 	{
 	 	 	 	 	if(fp[$1,x]>='$plimit' && fp[$2,x]<='$plimit2')
	 	 	 	 	 	{
	 	 	 	 	 	data_s[FNR,x]=neg[x]
	 	 	 	 	 	}
	 	 	 	 	else if(fp[$2,x]>='$plimit' && fp[$1,x]<='$plimit2')
	 	 	 	 	 	{
	 	 	 	 	 	data_t[FNR,x]=neg[x]
	 	 	 	 	 	}
 	 	 	 	 	}
 	 	 	 	}
 	 	 	if($6=="-" && $7=="+" || $7=="-" && $6=="+")
 	 	 	 	{
 	 	 	 	for(i=1; i<=posnum; i++)
 	 	 	 	 	{
 	 	 	 	 	for(j=1; j<=negnum; j++)
 	 	 	 	 	 	{
 	 	 	 	 	 	if(pos[i]==neg[j])
 	 	 	 	 	 	 	{
 	 	 	 	 	 	 	mirror[i]=j 	#if pos=i, the identical index of neg is mirror[i]
 	 	 	 	 	 	 	}
 	 	 	 	 	 	}
 	 	 	 	 	}
 	 	 	 	}
 	 	 	if($6=="-" && $7=="+")	
 	 	 	 	{
 	 	 	 	for(x=1; x<=f; x++)
 	 	 	 	 	{
 	 	 	 	 	if(fp[$1,mirror[x]]>='$plimit' && fp[$2,x]<='$plimit2')
 	 	 	 	 	 	{
 	 	 	 	 	 	data_s[FNR,x]=neg[mirror[x]]
 	 	 	 	 	 	}
 	 	 	 	 	else if(fp[$2,x]>='$plimit' && fp[$1,mirror[x]]<='$plimit2')
 	 	 	 	 	 	{
 	 	 	 	 	 	data_t[FNR,x]=neg[mirror[x]]
 	 	 	 	 	 	}
 	 	 	 	 	}
 	 	 	 	}
 	 	 	if($7=="-" && $6=="+")
 	 	 	 	{
 	 	 	 	for(x=1; x<=f; x++)
 	 	 	 	 	{
 	 	 	 	 	if(fp[$1,x] >= '$plimit' && fp[$2,mirror[x]]<='$plimit2')
 	 	 	 	 	 	{
 	 	 	 	 	 	data_s[FNR,x]=neg[mirror[x]]
 	 	 	 	 	 	}
 	 	 	 	 	else if(fp[$2,mirror[x]]>='$plimit' && fp[$1,x]<='$plimit2')
 	 	 	 	 	 	{
 	 	 	 	 	 	data_t[FNR,x]=neg[mirror[x]]
 	 	 	 	 	 	}
 	 	 	 	 	}	 	
 	 	 	 	}
 	 	 	}
 	 	if(FNR==1)
 	 	 	{
 	 	 	printf "source\t"  "target\t"  "ftalign_similarity\t"  "delta_m/z\t"  "source_fp_uniq\t"  "target_fp_uniq\n"
 	 	 	}
 	 	else
 	 	 	{
 	 	 	printf $1"\t"  $2"\t"  $3"\t"  $4"\t";
 	 	 	\
 	 	 	if(fp[$1,1]=="" || fp[$2,1]=="")
 	 	 	 	{
 	 	 	 	printf "NA@NA\n"
 	 	 	 	}
 	 	 	else
 	 	 	 	{
 	 	 	 	printf "source:"  #the source fingerprint uniq.
 	 	 	 	\
 	 	 	 	for(x=1; x<=f; x++)
 	 	 	 	 	{
 	 	 	 	 	if(data_s[FNR,x]!="")
 	 	 	 	 	 	{
 	 	 	 	 	 	printf data_s[FNR,x]","
 	 	 	 	 	 	}
 	 	 	 	 	};
 	 	 	 	printf "@target:"  #the target fingerprint uniq.
 	 	 	 	\
 	 	 	 	for(x=1; x<=f; x++)
 	 	 	 	 	{
 	 	 	 	 	if(data_t[FNR,x]!="")
 	 	 	 	 	 	{
 	 	 	 	 	 	printf data_t[FNR,x]","
 	 	 	 	 	 	}
 	 	 	 	 	}
 	 	 	 	printf "\n"
 	 	 	 	}
 	 	 	}
 	 	}
 	}' <(echo "$data_allfp") <(echo "$posindex") <(echo "$negindex") <(echo "$data") | sed -e 's/,@/\t/g; s/,$//g; s/@/\t/g' \
 	\
 	> results/source_target_tree_$tlimit.tsv;
 	 
	echo "All instances have written into <results/source_target_tree_$tlimit.tsv>."
;;
```

```{r eval = F, echo = T}
###################################
```

```{r eval = F, echo = T}
###################################
compound_idenfication)

echo "Run compound_idenfication."















echo "compound_idenfication "

exit

;;
```

```{r eval = F, echo = T}
###################################
```

```{r eval = F, echo = T}
###################################
double_ion_network)

echo "Run double_ion_network."

echo "Double_ion_network attempts to establish a link between features in different ionic modes based on retention times and molecular fingerprints. Please make sure that you have completed both ion modes using SIRIUS calculations and that you have completed steps such as fragment_tree_network above."

pos_projectpath=0

	until [ -d $pos_projectpath ] && [ -f $pos_projectpath/canopus_summary.tsv ]
	do
	read -p "Please input the path of the pos_ion project. >>> " pos_projectpath;
	done;
	
echo "pos_projectpath has successfully entered."

neg_projectpath=0

	until [ -d $neg_projectpath ] && [ -f $neg_projectpath/canopus_summary.tsv ] 
	do
	read -p "Please input the path of the neg_ion project. >>> " neg_projectpath;
	done;
	
echo "neg_projectpath has successfully entered."

save_path=0
	until [ -d $save_path ] 
	do
	read -p "Please input the storage path. >>> " save_path;
	done;
	
mkdir $save_path/double_ion_network

cd $save_path/double_ion_network;
mkdir temp
mkdir results

plimit="0"
	until [[ "$plimit" > "0.5" ]] && [[ "$plimit" < "0.99" ]]
	do
	read -p "Please enter the minimum posterior probability of the molecular fingerprint to be filtered. 0.9-0.99 is recommended. >>> "
	done;
flimit="0"
	until [[ "$flimit" > "0" ]] && [[ "$flimit" < "1000" ]]
	do
	read -p "Please enter the minimum identical fingerprints to be filtered. >>> " flimit;
	done;
dtime="0"
	until [[ "$dtime" > "0.01" ]] && [[ "$dtime" < "0.30" ]]
	do
	read -p "Please enter the rententiontime tolerance. 0.1-0.15 is recommended (C18). >>> " dtime;
	done;
dmass="0"
	until [[ "$dmass" > "0" ]] && [[ "$dmass" < "100" ]]
	do
	read -p "Please enter the Max delta_ionMass. 5-50 may work well. >>> " flimit;
	done;
	
pos_source=$(cat $pos_projectpath/temp/Mo_filename)

a=$(awk 'END{print NR}' <(echo "$pos_source"))

neg_target=$(cat $neg_projectpath/temp/Mo_filename)

b=$(awk 'END{print NR}' <(echo "$neg_source"))

awk -F $'\t' -v OFS=$'\t' '{if(NR>=2){print $2,$3}}' $pos_projectpath/csi_fingerid.tsv > temp/pos_fingerprint_index;

awk -F $'\t' -v OFS=$'\t' '{if(NR>=2){print $2,$3}}' $neg_projectpath/csi_fingerid_neg.tsv > temp/neg_fingerprint_index;

	if [ -f temp/doubleion_net_$plimit_$flimit ]
	then rm temp/doubleion_net_$plimit_$flimit
	fi;
	for (( i=1; i <= a; i++))
	do
	sumname=$(awk '{if(NR==$i){print}}' <(echo "$pos_source"))
	moname=$(echo "$sumname" | awk -F $'\t' '{print $1}');
	filename=$(echo "$sumname" | awk -F $'\t' '{print $2}');
	x=$(echo $pos_projectpath/$filename/fingerprints/$moname* )
	 	if [[ x != "$pos_projectpath/$filename/fingerprints/$moname*" ]]
	 	then
	id=$(echo "$filename" | awk -F _ '{print $NF}');
	source_mass=$(awk '/ionMass/{if(NR==FNR){print $2}}' $pos_projectpath/$filename/compound.info);
	source_rt=$(awk -F ['\t':] '/^rt/{if(NR==FNR){print $2/60}}' $pos_projectpath/$filename/compound.info)
	sourcefp=$(paste temp/pos_fingerprint_index $pos_projectpath/$filename/fingerprints/$moname* | awk -F $'\t' -v OFS=$'\t' '$3>='$plimit'{print $1}')
	##############
	#(parallel jobs)
	parallel_lists=$(seq 1 $b | paste -d " " - - - - - -)
	p=$(awk 'END{print NR}' <(echo "$parallel_lists"))
	 	for ((e=1; e <= p; e++))
	 	do
	 	f=$(awk '{if(NR=='$e'){print}}' <(echo "$parallel_lists"))
	 	 	for i in $(echo "$f")
	 	 	do
	 	 	{ t_sumname=$(awk '{if(NR==$i){print}}' <(echo "$neg_source"))
	 	 	t_filename=$(echo "$t_sumname" | awk -F $'\t' '{print $2}');
	 	 	t_moname=$(echo "$t_sumname" | awk -F $'\t' '{print $1}');
	 	 	y=$(echo $neg_projectpath/$t_filename/fingerprints/$t_moname*)
	 	 	 	if [[ $y != "$neg_projectpath/$t_filename/fingerprints/$t_moname*" ]]
	 	 	 	then
	 	 	 	target_mass=$(awk '/ionMass/{if(NR==FNR){print $2}}' $neg_projectpath/$t_filename/compound.info);
	 	 	 	target_rt=$(awk -F ['\t':] '/^rt/{if(NR==FNR){print $2/60}}' $neg_projectpath/$t_filename/compound.info);
	 	 	 	deltart=$(echo | awk '{print "'$source_rt'"-"'$target_rt'"}')
	 	 	 	deltamass=$(echo | awk '{print "'$source_mass'"-"'$target_mass'"}')
	 	 	 	 	if [[ "$deltart" < "$dtime" ]] && [[ "$deltart" > "0" ]] || [[ "$deltart" > "-$dtime" ]] && [[ "$deltart" < "0" ]]
	 	 	 	 	then
	 	 	 	 	 	if [[ "$deltamass" < "dmass" ]] && [[ "$deltamass" > "0" ]] || [[ "$deltamass" > "-$dmass" ]] && [[ "$deltamass" < "0" ]]
	 	 	 	 	 	then
	 	 	 	 	 	targetfp=$(paste temp/neg_fingerprint_index $neg_projectpath/$t_filename/fingerprints/$t_moname* | awk -F $'\t' -v OFS=$'\t' '$3>='$plimit'{print $1}')
	 	 	 	 	 	assemble=$(sort <(sort -m <(echo "$sourcefp") <(echo "$targetfp")) | uniq -d)
	 	 	 	 	 	fpnum=$(awk 'END{print NR}' <(echo "$assemble"))
	 	 	 	 	 	 	if [[ "$fpnum" > "$flimit" ]]
	 	 	 	 	 	 	then
	 	 	 	 	 	 	t_id=$(echo "$t_filename" | awk -F _ '{print $NF}');
	 	 	 	 	 	 	identicalfp=$(paste -s -d $'\t' <(echo "$assemble") | awk -F $'\t' -v OFS=, '{print $0}') 
	 	 	 	 	 	 	awk -F $'\t' -v OFS=$'\t' '{print $0,"'$t_id'","null","'$deltamass'","null","null","'$identicalfp'"}' <(echo "$id") > temp/single_doubleion_net_${id}_${t_id}_$plimit_$flimit;
	 	 	 	 	 	 	fi;
	 	 	 	 	 	fi;
	 	 	 	 	fi;
	 	 	 	fi;
	 	 	}&
	 	 	done;
	 	 	wait;
	 	done;
	 	fi;
	echo "Parallel jobs have finished $i($a)."
	done;
cat temp/single_doubleion_net_*_$plimit_$flimit > temp/doubleion_net_$plimit_$flimit
cat <(echo source$'\t'target$'\t'tfalign$'\t'delta_mass$'\t'fp_source_uniq$'\t'fp_target_uniq$'\t'identicalfp) temp/doubleion_net_$plimit_$flimit > results/doubleion_net_$plimit_$flimit.tsv;

echo "All instances have written into <results/doubleion_net_$plimit_$flimit.tsv>."

;;

```

```{r eval = F, echo = T}
###################################
```

```{r eval = F, echo = T}
###################################
```

```{r eval = F, echo = T}
###################################
```

```{r eval = F, echo = T}
###################################
exit)
echo "The mystery of creation is like the darkness of night--it is great.
Delusions of knowledge are like the fog of the morning."
exit;
;;
```

```{r eval = F, echo = T}
###################################
```

```{r eval = F, echo = T}
###################################
```

```{r eval = F, echo = T}
###################################
```

```{r eval = F, echo = T}
###################################
*)
echo "error"
exit;
;;
esac;
done;#(for)
done;#(select)

```

# File: mdmn1010.sh

```{r eval = F, echo = T}
##########################
```

```{r eval = F, echo = T}
##########################
echo "We are all in the gutter, 
but some of us are looking at the stars.";

PS3='Please select the workflow to be executed. >>> '

select command in \
  	\
 	"default" \
 	\
 	"structure_extract" \
 	\
 	"classification_extract_sum" \
 	\
 	"classification_extract_filter" \
 	\
 	"fragment_tree_network" \
 	\
 	"fragment_tree_network_delta" \
 	\
 	"compound_idenfication" \
 	\
 	"double_ion_network" \
 	\
 	"exit" 
do
	
	if [[ $command == "default" ]]
	then
	
	confirm=0
	
	 	until [[ $confirm == "yes" ]] || [[ $confirm == "no" ]]
	 	do
	 	read -p "Running all proccesses sequentially? [yes/no] >>> " confirm
	 	done;
	 	if [[ $confirm == "no" ]]
	 	then exit
	 	fi;
	 	
	default="structure_extract classification_extract_sum classification_extract_filter fragment_tree_network fragment_tree_network_delta"
	
	list=$(echo $default);
	
	else list=$( echo $command)
	fi;
	
	for option in $(echo $list)
	do
	 	case $option in
```

```{r eval = F, echo = T}
###################################
```

```{r eval = F, echo = T}
###################################
```

```{r eval = F, echo = T}
###################################
```

```{r eval = F, echo = T}
###################################
structure_extract)
echo "Run structure_extract."
projectpath=0
	until [ -d $projectpath ] && [ -f $projectpath/canopus_summary.tsv ] && [ -f $projectpath/.format ]
	do
	read -p "Please input the path of the sirius project >>> " projectpath;
	done;
	
cd $projectpath;
mkdir results;
mkdir temp;
mkdir temp/fintemp;

	if [ -f temp/Mo_filename ]
	then rm temp/Mo_filename
	fi;

data="*_*/fingerid/*.tsv"

awk -F $'\t' '
 	BEGIN{
 	 	all_id=0
 	 	\
 	 	max_id=-1
 	 	\
 	 	p_id="null"
 	 	\
 	 	printf "Info: loading the data..."
 	 	}
 	{
 	if(FNR==1)
 	 	{
 	 	if(NR>FNR)
 	 	 	{
 	 	 	close(pfile)
 	 	 	}
 	 	f=split(FILENAME,a,"[/]");
 	
 	 	n=split(a[1],b,"[_]");
 	
 	 	id=b[n];
 	
 	 	if(id!=p_id)
 	 	 	{
 	 	 	all_id+=1
 	 	 	\
 	 	 	if(id>max_id)
 	 	 	 	{
 	 	 	 	max_id=id
 	 	 	 	}
 	 	 	}
 	 	file[id]=a[1]
 	 	
 	 	split(a[f], g, "[.]")
 	 	
 	 	formu_type[id]=g[1]
 	 	
 	 	if(all_id==1)
 	 	 	{
 	 	 	for(i=1; i<=NF; i++)
 	 	 	 	{
 	 	 	 	if(($i~/inchikey2D/))
 	 	 	 	 	{
 	 	 	 	 	col_2D=i
 	 	 	 	 	}
 	 	 	 	if($i=="inchi")
 	 	 	 	 	{
 	 	 	 	 	col_inchi=i
 	 	 	 	 	}
 	 	 	 	if(($i~/Formula/))
 	 	 	 	 	{
 	 	 	 	 	col_formu=i
 	 	 	 	 	}
 	 	 	 	if($i=="score")
 	 	 	 	 	{
 	 	 	 	 	col_score=i
 	 	 	 	 	}
 	 	 	 	if($i=="name")
 	 	 	 	 	{
 	 	 	 	 	col_name=i
 	 	 	 	 	}
 	 	 	 	if($i=="smiles")
 	 	 	 	 	{
 	 	 	 	 	col_smiles=i
 	 	 	 	 	}
 	 	 	 	if($i=="xlogp")
 	 	 	 	 	{
 	 	 	 	 	col_x=i
 	 	 	 	 	}
 	 	 	 	if(($i~/imilarity/))
 	 	 	 	 	{
 	 	 	 	 	col_simi=i
 	 	 	 	 	}
 	 	 	 	if($i~/links/)
 	 	 	 	 	{
 	 	 	 	 	col_links=i
 	 	 	 	 	}
 	 	 	 	}
 	 	 	}
 	 	pfile=FILENAME
 	 	
 	 	printf g[1]"\t"formu_type[id]"\n"
 	 	
 	 	printf "Info: the data of " id " (ID) has input. The filename is " FILENAME ".\n"
 	 	}
 	if(FNR>=2)
 	 	{
 	 	row_score=$col_score
 	 	
 	 	row_simi=$col_simi
 	 	
 	 	if(max["score",id]=="" || max["score",id]<row_score)
	 	 	{
 	 	 	max["score",id]=row_score
 	 	 	
 	 	 	name["score",id]=$col_name
 	 	
 	 	 	formula["score",id]=$col_formu
 	 	 	
 	 	 	simi["score",id]=$col_simi
 	 	
 	 	 	smiles["score",id]=$col_smiles
 	 	
 	 	 	inchi["score",id]=$col_inchi
 	 	
 	 	 	in2D["score",id]=$col_2D
 	 	 	
 	 	 	score["score",id]=$col_score
 	 	
 	 	 	xlogp["score",id]=$col_x
 	 	 	
 	 	 	links["score",id]=$col_links
 	 	 	}
 	 	if(max["simi",id]=="" || max["simi",id]<row_simi)
	 	 	{
 	 	 	max["simi",id]=row_simi
 	 	 	
 	 	 	name["simi",id]=$col_name
 	 	
 	 	 	formula["simi",id]=$col_formu
 	 	 	
 	 	 	simi["simi",id]=$col_simi
 	 	
 	 	 	smiles["simi",id]=$col_smiles
 	 	
 	 	 	inchi["simi",id]=$col_inchi

 	 	 	in2D["simi",id]=$col_2D
 	 	 	
 	 	 	score["simi",id]=$col_score
 	 	 
 	 	 	xlogp["simi",id]=$col_x
 	 	 	
 	 	 	links["simi",id]=$col_links
 	 	 	}
 	 	}
 	}
 	END{
 	 	printf "id\t"  "name\t"  "formula\t"  "similarity\t"  "smiles\t"  "inchi\t"  "inchikey2D\t" \
 	 	\
 	 	"score\t"  "xlogp\t"  "links\n" > "results/fingerid_sum.tsv"
 	 	\
 	 	printf "" > "temp/Mo_filename"
 	 	
 	 	for(l in file)
 	 	 	{
 	 	 	if(max["score",l]!="")
 	 	 	 	{
 	 	 	 	printf l"\t" \
 	 	 	 	\
 	 	 	 	name["score",l]"\t"  formula["score",l]"\t"  simi["score",l]"\t" \
 	 	 	 	\
 	 	 	 	smiles["score",l]"\t"  inchi["score",l]"\t"  in2D["score",l]"\t" \
 	 	 	 	\
 	 	 	 	score["score",l]"\t"  xlogp["score",l]"\t"  links["score",l]"\n" >> "results/fingerid_sum.tsv"
 	 	 	 	
 	 	 	 	printf formula["score",l]"\t"  file[l]"\t"  formu_type[l]"\n" >> "temp/Mo_filename"
 	 	 	 	}
 	 	 	if(max["simi",l]!="" && max["simi",l]!=max["score",l])
 	 	 	 	{
 	 	 	 	printf l"\t" \
 	 	 	 	\
 	 	 	 	name["simi",l]"\t"  formula["simi",l]"\t"  simi["simi",l]"\t" \
 	 	 	 	\
 	 	 	 	smiles["simi",l]"\t"  inchi["simi",l]"\t"  in2D["simi",l]"\t" \
 	 	 	 	\
 	 	 	 	score["simi",l]"\t"  xlogp["simi",l]"\t"  links["simi",l]"\n" >> "results/fingerid_sum.tsv"
 	 	 	 	}
 	 	 	}
 	 	}' $data

data_sum="results/fingerid_sum.tsv"

awk -F $'\t' '
 	{
 	if(NR==1)
 	 	{
 	 	for(i=1; i<=NF; i++)
 	 	 	{
 	 	 	if($i~/id/)
 	 	 	 	{
 	 	 	 	col_id=i
 	 	 	 	}
 	 	 	if($i~/score/)
 	 	 	 	{
 	 	 	 	col_score=i
 	 	 	 	}
 	 	 	}
 	 	}
 	if(NR>=2)
 	 	{
 	 	id=$col_id
 	 	\
 	 	if(max_id<id || max_id=="")
 	 	 	{
 	 	 	max_id=id
 	 	 	}
 	 	if(score[id]<$col_score || score[id]=="")
 	 	 	{
 	 	 	score[id]=$col_score
 	 	 	\
 	 	 	data[id]=$0
 	 	 	}
 	 	}
 	}
 	END{
 	 	printf "id\t"  "name\t"  "formula\t"  "similarity\t"  "smiles\t"  "inchi\t"  "inchikey2D\t" \
 	 	\
 	 	"score\t"  "xlogp\t"  "links\n" > "results/fingerid_first_score.tsv"
 	 	\
 	 	for(i=1; i<=max_id; i++)
 	 	 	{
 	 	 	if(data[i]!="")
 	 	 	 	{
 	 	 	 	printf data[i] "\n" >> "results/fingerid_first_score.tsv"
 	 	 	 	}
 	 	 	}
 	 	}' $data_sum

echo "structure_extract results have been successfully assembled into <results/fingerid_sum.tsv> and <results/fingerid_first_score.tsv>";
;;
```

```{r eval = F, echo = T}
###################################
```

```{r eval = F, echo = T}
###################################
```

```{r eval = F, echo = T}
###################################
```

```{r eval = F, echo = T}
###################################
classification_extract_sum)

echo "Run classification_extract_sum.";
	if [ -f temp/Mo_filename ] && [ -f canopus.tsv ] && [ -f canopus_neg.tsv ] && [ -f .format ]
	then
	echo "Project path acknowledged."
	else
	 	until [ -d $projectpath ] && [ -f $projectpath/canopus.tsv ] && [ -f $projectpath/.format ]
	 	do
	 	read -p "Please input the path of the sirius project >>> " projectpath;
	 	done;
	 	cd $projectpath;
	fi;
	
data1="temp/Mo_filename"

data2="canopus.tsv"

data3="canopus_neg.tsv"

datas=$(awk -F $'\t' '
 	{
 	if(getline < $2"/canopus/"$3".fpt"==-1)
 	 	{
 	 	printf ""
 	 	}
 	else
 	 	{
 	 	printf $2"/canopus/"$3".fpt "
 	 	}
 	close($2"/canopus/"$3".fpt")
 	}' $data1)
	
awk -F $'\t' '
 	{
 	if(NR==FNR)
 	 	{
 	 	file[FNR]=$2
 	 	
 	 	mo[$2]=$1
 	 	
 	 	i=split($2,s,"[_]")
 	 	
 	 	the_id[FNR]=s[i]
 	 	
 	 	n=FNR
 	 	}
 	if((FILENAME ~ /'$data2'/))
 	 	{
 	 	if(FNR==1)
 	 	 	{
 	 	 	close("'$data1'")
 	 	 	
 	 	 	printf "Info: data_file name of '$data1' has been input.\n"
 	 	 	
 	 	 	for(i=1; i<=NF; i++)
 	 	 	 	{
 	 	 	 	if(($i ~ /name/))
 	 	 	 	 	{
 	 	 	 	 	col_class=i
 	 	 	 	 	}
 	 	 	 	if(($i ~ /absolute/))
 	 	 	 	 	{
 	 	 	 	 	col_abindex=i
 	 	 	 	 	}
 	 	 	 	}
 	 	 	}
 	 	if(FNR>=2)
 	 	 	{
 	 	 	abindex[1,FNR]=$col_abindex
 	 	 	
 	 	 	class[1,$col_abindex]=$col_class
 	 	 	
 	 	 	rows_data2=FNR
 	 	 	}
 	 	}
 	if((FILENAME ~ /'$data3'/))
 	 	{
 	 	if(FNR==1)
 	 	 	{
 	 	 	close("'$data2'")
 	 	 	
 	 	 	printf "Info: data_file name of '$data2' has been input.\n"
 	 	 	
 	 	 	for(i=1; i<=NF; i++)
 	 	 	 	{
 	 	 	 	if(($i ~ /name/))
 	 	 	 	 	{
 	 	 	 	 	col_class=i
 	 	 	 	 	}
 	 	 	 	if(($i ~ /absolute/))
 	 	 	 	 	{
 	 	 	 	 	col_abindex=i
 	 	 	 	 	}
 	 	 	 	}
 	 	 	}
 	 	if(FNR>=2)
 	 	 	{
 	 	 	abindex[2,FNR]=$col_abindex
 	 	 	
 	 	 	class[2,$col_abindex]=$col_class
 	 	 	
 	 	 	rows_data3=FNR
 	 	 	}
 	 	}
 	if((FILENAME ~ /fpt/))
 	 	{
 	 	if(FNR==1)
 	 	 	{
 	 	 	if(p_filename=="")
 	 	 	 	{
 	 	 	 	close("'$data3'")
 	 	 	 	}
 	 	 	else if(FILENAME!=p_filename)
 	 	 	 	{
 	 	 	 	close(p_filename)
 	 	 	 	
 	 	 	 	printf "Info: data_file name of " p_filename " has been input.\n"
 	 	 	 	}
 	 	 	p_filename=FILENAME
 	 	 	\
 	 	 	for(i=1; i<=n; i++)
 	 	 	 	{
 	 	 	 	if((FILENAME ~ file[i]) && (FILENAME ~ mo[file[i]]))
 	 	 	 	 	{
 	 	 	 	 	break
 	 	 	 	 	}
 	 	 	 	else
 	 	 	 	 	{
 	 	 	 	 	x=i+1
 	 	 	 	 	}
 	 	 	 	}
 	 	 	if(x==n+1)
 	 	 	 	{
 	 	 	 	nextfile
 	 	 	 	}
 	 	 	split(FILENAME,a,"[/]");

 	 	 	m=split(a[1],b,"[_]");

 	 	 	id=b[m];

 	 	 	if((FILENAME ~ /\+.fpt/))
 	 	 	 	{
 	 	 	 	ion=1
 	 	 	 	}
 	 	 	else
 	 	 	 	{
 	 	 	 	ion=2
 	 	 	 	}
 	 	 	pp[id,abindex[ion,2]]=$1
 	 	 	}
 	 	if(FNR>=2)
 	 	 	{
 	 	 	pp[id,abindex[ion,FNR+1]]=$1
 	 	 	}
 	 	}
 	}
 	END{
 	 	if(abindex[1,rows_data2] > abindex[2,rows_data3])
 	 	 	{
 	 	 	maxindex=abindex[1,rows_data2]
 	 	 	}
 	 	else
 	 	 	{
 	 	 	maxindex=abindex[2,rows_data3]
 	 	 	}
 	 	printf "id\t" > "results/canopus_pp.tsv"
 	 	\
 	 	for(i=0; i<=maxindex; i++)
 	 	 	{
 	 	 	if(class[1,i]!="" && i!=maxindex)
 	 	 	 	{
 	 	 	 	printf class[1,i]"\t" >> "results/canopus_pp.tsv"
 	 	 	 	}
 	 	 	else if(class[2,i]!="" && i!=maxindex)
 	 	 	 	{
 	 	 	 	printf class[2,i]"\t" >> "results/canopus_pp.tsv"
 	 	 	 	}
 	 	 	else if(i==maxindex && class[1,i]!="")
 	 	 	 	{
 	 	 	 	printf class[1,i]"\n" >> "results/canopus_pp.tsv"
 	 	 	 	}
 	 	 	else if(i==maxindex && class[2,i]!="")
 	 	 	 	{
 	 	 	 	printf class[2,i]"\n" >> "results/canopus_pp.tsv"
 	 	 	 	}
 	 	 	}
 	 	for(i=1; i<=n; i++)
 	 	 	{
 	 	 	printf the_id[i]"\t" >> "results/canopus_pp.tsv"
 	 	 	
 	 	 	for(j=0; j<=maxindex; j++)
 	 	 	 	{
 	 	 	 	if(class[1,j]!="" && j!=maxindex || class[2,j]!="" && j!=maxindex)
 	 	 	 	 	{
 	 	 	 	 	if(pp[the_id[i],j]=="")
 	 	 	 	 	 	{
 	 	 	 	 	 	printf 0"\t" >> "results/canopus_pp.tsv"
 	 	 	 	 	 	}
 	 	 	 	 	else
 	 	 	 	 	 	{
 	 	 	 	 	 	printf pp[the_id[i],j]"\t" >> "results/canopus_pp.tsv"
 	 	 	 	 	 	}
 	 	 	 	 	}
 	 	 	 	else if(class[1,j]!="" && j==maxindex || class[2,j]!="" && j==maxindex)
 	 	 	 	 	{
 	 	 	 	 	if(pp[the_id[i],j]=="")
 	 	 	 	 	 	{
 	 	 	 	 	 	printf 0"\n" >> "results/canopus_pp.tsv"
 	 	 	 	 	 	}
 	 	 	 	 	else
 	 	 	 	 	 	{
 	 	 	 	 	 	printf pp[the_id[i],j]"\n" >> "results/canopus_pp.tsv"
 	 	 	 	 	 	}
 	 	 	 	 	}
 	 	 	 	}
 	 	 	}
 	 	}' $data1 $data2 $data3 $datas

echo "classification_extract_sum have been successfully written into <results/canopus_pp.tsv>"
;;
```

```{r eval = F, echo = T}
###################################
```

```{r eval = F, echo = T}
###################################
```

```{r eval = F, echo = T}
###################################

classification_extract_filter)
echo "Run classification_extract_filter.";
	if [ -f results/canopus_pp.tsv ]
	then
	echo "Project path acknowledged."
	else
	 	until [ -d $projectpath ] && [ -f $projectpath/results/canopus_pp.tsv ] && [ -f $projectpath/results/canopus_summary.tsv ]
	 	do
	 	read -p "Please input the path of the sirius project >>> " projectpath;
	 	done;
	 	cd $projectpath;
	fi;	
	
check=0
	until [[ "$check" == "yes" ]] || [[ "$check" == "no" ]]
	do
	read -p "Collate the posterior probabilities of the classification of each feature? [yes/no] >>> " check;
	done;
	
	if [[ $check == "yes" ]]
	then
	definition_limit=0
	
	 	until [[ "$definition_limit" > "0.01" ]] && [[ "$definition_limit" < "1" ]]
	 	do
	 	read -p "Please enter the posterior probabilities limition. 0.5~0.99 may work well. >>> " definition_limit;
	 	done;
	
	data1="canopus_summary.tsv"
 
 	data2="canopus.tsv"
 
 	data3="results/canopus_pp.tsv"
	
	awk -F $'\t' '
	 	{
	 	if(NR==FNR)
	 	 	{
	 	 	if(FNR==1)
	 	 	 	{
	 	 	 	p_file=FILENAME
	 	 	 	\
	 	 	 	for(i=1; i<=NF; i++)
	 	 	 	 	{
		 	 	 	if($i~/name/)
		 	 	 	 	{
		 	 	 	 	col_id=i
		 	 	 	 	}
		 	 	 	if($i~/specific/)
		 	 	 	 	{
		 	 	 	 	col_specific=i
		 	 	 	 	}
		 	 	 	if($i~/level/)
		 	 	 	 	{
		 	 	 	 	col_level=i
		 	 	 	 	}
		 	 	 	if($i~/subclass/)
		 	 	 	 	{
		 	 	 	 	col_subclass=i
		 	 	 	 	}
		 	 	 	if($i~/^class/)
		 	 	 	 	{
		 	 	 	 	col_class=i
		 	 	 	 	}
		 	 	 	if($i~/superclass/)
		 	 	 	 	{
		 	 	 	 	col_superclass=i
		 	 	 	 	}
	 	 	 	 	}
	 	 	 	}
	 	 	if(FNR>=2)
	 	 	 	{
	 	 	 	n=split($col_id,a,"[_]")
	 	 	 	\
	 	 	 	id=a[n]
	 	 	 	\
	 	 	 	specific[id]=$col_specific
	 	 	 	\
	 	 	 	level[id]=$col_level
	 	 	 	\
	 	 	 	subclass[id]=$col_subclass
	 	 	 	\
	 	 	 	class[id]=$col_class
	 	 	 	\
	 	 	 	superclass[id]=$col_superclass
	 	 	 	}
	 	 	}
	 	if(FILENAME~/canopus.tsv/)
	 	 	{
	 	 	if(FNR==1)
	 	 	 	{
	 	 	 	close(p_file)
	 	 	 	\
	 	 	 	p_file=FILENAME
	 	 	 	\
	 	 	 	for(i=1; i<=NF; i++)
	 	 	 	 	{
		 	 	 	if($i~/name/)
		 	 	 	 	{
		 	 	 	 	col_name=i
		 	 	 	 	}
		 	 	 	if($i~/description/)
		 	 	 	 	{
		 	 	 	 	col_description=i
		 	 	 	 	}
	 	 	 	 	}
	 	 	 	}
	 	 	if(FNR>=2)
	 	 	 	{
	 	 	 	description[$col_name]=$col_description
	 	 	 	}
	 	 	}
	 	if(FILENAME~"'$data3'")
	 	 	{
	 	 	if(FNR==1)
	 	 	 	{
	 	 	 	close(p_file)
	 	 	 	\
	 	 	 	for(i=1; i<=NF; i++)
	 	 	 	 	{
	 	 	 	 	if($i~/^id$/)
	 	 	 	 	 	{
	 	 	 	 	 	col_id=i
	 	 	 	 	 	}
	 	 	 	 	if(i>=2)
	 	 	 	 	 	{
	 	 	 	 	 	col_class_name[i]=$i
	 	 	 	 	 	}
	 	 	 	 	}
	 	 	 	printf "id\t"  "definition_source\t"  "definition\t"  "definition_pp\t"  "definition_description\t" \
	 	 	 	\
	 	 	 	"specific\t"  "specific_pp\t"  "level_5\t"  "level_5_pp\t" \
	 	 	 	\
	 	 	 	"subclass\t"  "subclass_pp\t"  "class\t"  "class_pp\t"  "superclass\t"  "superclass_pp\n" \
	 	 	 	\
	 	 	 	> "results/stat_classification.tsv"
	 	 	 	}
	 	 	if(FNR>=2)
	 	 	 	{
	 	 	 	for(i=2; i<=NF; i++)
	 	 	 	 	{
	 	 	 	 	c_pp[col_class_name[i]]=sprintf("%.4f",$i)
	 	 	 	 	}
	 	 	 	if(level[$col_id] != "" && c_pp[level[$col_id]] >= "'$definition_limit'")
	 	 	 	 	{
	 	 	 	 	definition_source="level_5"
	 	 	 	 	\
	 	 	 	 	definition=level[$col_id]
	 	 	 	 	}
	 	 	 	else if(subclass[$col_id] != "" && c_pp[subclass[$col_id]] >= "'$definition_limit'")
	 	 	 	 	{
	 	 	 	 	definition_source="subclass"
	 	 	 	 	\
	 	 	 	 	definition=subclass[$col_id]
	 	 	 	 	}
	 	 	 	else if(class[$col_id] != "" && c_pp[class[$col_id]] >= "'$definition_limit'")
	 	 	 	 	{
	 	 	 	 	definition_source="class"
	 	 	 	 	\
	 	 	 	 	definition=class[$col_id]
	 	 	 	 	}
	 	 	 	else if(superclass[$col_id] != "" && c_pp[superclass[$col_id]] >= "'$definition_limit'")
	 	 	 	 	{
	 	 	 	 	definition_source="superclass"
	 	 	 	 	\
	 	 	 	 	definition=superclass[$col_id]
	 	 	 	 	}
	 	 	 	else
	 	 	 	 	{
	 	 	 	 	definition_source="null"
	 	 	 	 	\
	 	 	 	 	definition="null"
	 	 	 	 	\
	 	 	 	 	c_pp[definition]="null"
	 	 	 	 	\
	 	 	 	 	description[definition]="null"
	 	 	 	 	}
	 	 	 	printf $col_id"\t"  definition_source"\t"  definition"\t"  c_pp[definition]"\t"  description[definition]"\t" \
	 	 	 	\
	 	 	 	specific[$col_id]"\t"  c_pp[specific[$col_id]]"\t"  level[$col_id]"\t"  c_pp[level[$col_id]]"\t" \
	 	 	 	\
	 	 	 	subclass[$col_id]"\t"  c_pp[subclass[$col_id]]"\t"  class[$col_id]"\t"  c_pp[class[$col_id]]"\t" \
	 	 	 	\
	 	 	 	superclass[$col_id]"\t"  c_pp[superclass[$col_id]]"\n" >> "results/stat_classification.tsv"
	 	 	 	}
	 	 	}
	 	}' $data1 $data2 $data3
 	
 	echo "classification_extract_filter have been successfully written into <results/stat_classification.tsv>"
 	
 	fi;
;;
```

```{r eval = F, echo = T}
###################################
```

```{r eval = F, echo = T}
###################################
```

```{r eval = F, echo = T}
###################################
```

```{r eval = F, echo = T}
###################################
fragment_tree_network)

echo "Run fragment_tree_network.";

	if [ -d temp ] && [ -f ftalign.tsv ] && [ -f .format ]
	then
	echo "Project path acknowledged."
	
	else
	 	until [ -d $projectpath ] && [ -f $projectpath/ftalign.tsv ] && [ -f $projectpath/.format ]
	 	do
	 	read -p "Please input the path of the sirius project. Make sure you have moved the fragment tree alignment results to the directory where the project is located. >>> " projectpath;
	 	done;
	 	cd $projectpath;
	fi;

echo "Please enter the minimum alignment similarity that you want to filter."

tlimit=0
	until [[ "$tlimit" > "0.01" ]] && [[ "$tlimit" < "0.99" ]]
	do
	read -p "0.4-0.7 is recommended >>> " tlimit;
	done;

 	if ! [ -d temp/ftaligntemp ]
	then 
	mkdir temp/ftaligntemp
 	fi;
 	
data="ftalign.tsv"

savepath="temp/ftaligntemp/tmp"

awk -F $'\t' -v OFS=$'\t' '
 	{
 	print NR,FNR
 	
 	if(NR==FNR)
 	 	{
	 	for(i=1; i<=NF; i++)
	 	 	{
	 	 	if(NR==1 && i!=1 || NR!=1 && i==1)
	 	 	 	{
	 	 	 	n=split($i,x,"[_]")
	 	 	 	\
	 	 	 	raw[NR,i]=x[n]
	 	 	 	}
	 	 	else
	 	 	 	{
	 	 	 	if(NR==i)
	 	 	 	 	{
	 	 	 	 	raw_norm[NR,i]=$i
	 	 	 	 	}
	 	 	 	}
	 	 	}
	 	}
	if(NR>FNR && FNR>=2)
	 	{
	 	for(i=2; i<=NF; i++)
	 	 	{
	 	 	norm1=$i/raw_norm[i,i]
	 	 	 	
	 	 	norm2=$i/raw_norm[FNR,FNR]
	 	 	 	
	 	 	norms=sprintf("%.2f", ((norm1+norm2)/2))
	 	 	
	 	 	if(norms > '$tlimit' && norms < 1)
	 	 	 	{
	 	 	 	if(raw[FNR,1]>=raw[1,i])
	 	 	 	 	{
	 	 	 	 	print raw[FNR,1], raw[1,i], norms > "'$savepath'"
	 	 	 	 	}
	 	 	 	else
	 	 	 	 	{
	 	 	 	 	print raw[1,i], raw[FNR,1], norms > "'$savepath'"
	 	 	 	 	}
	 	 	 	}
	 	 	}
	 	}
 	}' $data $data

sort -u $savepath > temp/ftaligntemp/filter_net_$tlimit

echo "fragment_tree_network have been successfully written into <temp/ftaligntemp/filter_net_$tlimit>"
;;

```

```{r eval = F, echo = T}
###################################
```

```{r eval = F, echo = T}
###################################
```

```{r eval = F, echo = T}
###################################
```

```{r eval = F, echo = T}
###################################

fragment_tree_network_delta)

	if [ -d temp ] && [ -f ftalign.tsv ] && [ -f .format ]
	then
	echo "Project path acknowledged."
	else
	 	until [ -d $projectpath ] && [ -f $projectpath/ftalign.tsv ] && [ -f $projectpath/.format ]
	 	do
	 	read -p "Please input the path of the sirius project >>> " projectpath;
	 	done;
	cd $projectpath;
	fi;
echo "The following module attempts to compute the differential fingerprints of connected clusters based on the molecular fingerprint results of sirius 4."

```

```{r eval = F, echo = T}
###################
```

```{r eval = F, echo = T}
###################
```

```{r eval = F, echo = T}
###################

plimit=0
	until [[ "$plimit" > "0.5" ]] && [[ "$plimit" < "0.99" ]]
	do
	read -p "Please enter the minimum posterior probability of the molecular fingerprint to be filtered. 0.9-0.99 is recommended. >>> " plimit;
	done;

plimit2=0
	until [[ "$plimit2" > "0.1" ]] && [[ "$plimit2" < "$plimit" ]]
	do
	read -p "The minimum posterior probability of the molecular fingerprint to be controled. 0.1-0.5 may work well. >>> " plimit2;
	done;
	
tlimit=$(ls temp/ftaligntemp/filter_net_* | awk -F _ '{print $NF}')

check_rep=$(awk 'END{print NR}' <(echo "$tlimit"))

	if [[ "$check_rep" > "1" ]]
	then
	tlimit=0
	 	until [ -f temp/ftaligntemp/filter_net_$tlimit ]
	 	do
	 	read -p "Plural and different fragment_tree_network files were found to exist locally. Please select a tlimit parameter you have utilized to run fragment_tree_network_delta. >>> " tlimit;
	 	done;
	fi;
	
	
	if [ -f temp/ftaligntemp/refilter_net_$tlimit ]
	then rm temp/ftaligntemp/refilter_net_$tlimit
	fi;
	
	if [ -f temp/ftaligntemp/fpsample ]
	then rm temp/ftaligntemp/fpsample
	fi;

echo "Running delta_fingerprint computation..."

echo "Aquiring data from sirius index..."

data1="*_*/compound.info"

data2="temp/ftaligntemp/filter_net_$tlimit"

echo "Run fragment_tree_network_delta."

savepath="temp/ms_data"

echo "step 1: ms data"

awk -F "[\t]||[:]||[_]" -v OFS=$'\t' '

 	BEGIN{  
 	 	printf "..."
 	 	
 	 	printf "id\t"  "m/z\t"  "rt\n" > "results/mz_and_rt.tsv"
 	 	}
 	{
 	if(FILENAME~/compound.info/)
 	 	{
 	 	if(FNR==1)
 	 	 	{
 	 	 	printf "Info: catch >>> "FILENAME"\n"
 	 	 	}
 	 	if($1=="name")
 	 	 	{
 	 	 	i+=1;
 	 	 	
 	 	 	id[i]=$NF;
 	 	 	
 	 	 	n=split($NF,a,"[_]")
 	 	 	
 	 	 	printf a[n]"\t" >> "results/mz_and_rt.tsv"
 	 	 	}
 	 	if($1=="ionMass")
 	 	 	{
 	 	 	mz[id[i]]=$NF
 	 	 	
 	 	 	printf sprintf("%.4f",$NF)"\t" >> "results/mz_and_rt.tsv"
 	 	 	}
 	 	if($1=="ionType")
 	 	 	{
 	 	 	type[id[i]]=$NF
 	 	 	}
 	 	if($1=="rt")
 	 	 	{
 	 	 	rt[id[i]]=$2;
 	 	 	
 	 	 	printf sprintf("%.2f",$2/60)"\n" >> "results/mz_and_rt.tsv"
 	 	 	}
 	 	}
 	if(FILENAME~/ftaligntemp/)
 	 	{
 	 	#source  target  ftalign  delta_mz  delta_rt  source_iontype  target_iontype;
 	 	
 	 	if(FNR==1)
 	 	 	{
 	 	 	printf "" > "'$savepath'"
 	 	 	}
 	 	print $1,$2,$3,sprintf("%.3f",mz[$2]-mz[$1]),sprintf("%.2f",rt[$2]-rt[$1]),type[$1],type[$2] \
 	 	\
 	 	>> "'$savepath'"
 	 	}
 	}' $data1 $data2

```

```{r eval = F, echo = T}
########################

echo "step 2: data path"

source_file="temp/Mo_filename"

data="temp/ms_data"

awk -F $'\t' -v OFS=$'\t' '
 	{
 	if(NR==FNR)
 	 	{
 	 	n=split($2, a, "[_]")
 	 	
 	 	file[a[n]]=$2
 	 	
 	 	formu_type[a[n]]=$3
 	 	}
 	if(NR!=FNR)
 	 	{
 	 	#<path>sourceFormula  <path>targetFormula
 	 	
 	 	path1=file[$1]"/fingerprints/"formu_type[$1]".fpt"
 	 	
 	 	path2=file[$2]"/fingerprints/"formu_type[$2]".fpt"
 	 	
 	 	data[path1]=path1
 	 	
 	 	data[path2]=path2
 	 	}
 	}
 	END{
 	 	for(i in data)
 	 	 	{
 	 	 	n+=1
 	 	 	
 	 	 	print "Check file:",n
 	 	 	
 	 	 	if(getline<i==-1)
 	 	 	 	{
 	 	 	 	printf "Escape filename: " i "\n"
 	 	 	 	}
 	 	 	else
 	 	 	 	{
 	 	 	 	printf i" " > "temp/datapath"
 	 	 	 	}
 	 	 	close(i)
 	 	 	}
 	 	print "Sum:",n
 	 	}' $source_file $data
 
datapath=$(cat temp/datapath)

echo "step 3: fingerprint"
 	
data_allfp="temp/data_allfp"

awk -F $'\t' '
 	BEGIN{
 	 	n=0
 	 	}
 	{
 	if(FNR==1)
 	 	{
 	 	if(n>1)
 	 	 	{
 	 	 	close(file)
 	 	 	}
 	 	file=FILENAME;
 	 	
 	 	print "Get fingerprints: ",FILENAME
 	 	
 	 	n+=1;
 	 	
 	 	printf FILENAME"\n"$0"\n" > "'$data_allfp'"
 	 	}
 	else
 	 	{
 	 	print $0 > "'$data_allfp'"
 	 	}
 	}' $datapath

```

```{r eval = F, echo = T}
###########################


awk -F $'\t' -v OFS=$'\t' '
 	{
 	if(NR==1)
 	 	{
 	 	for(i=1; i<=NF; i++)
 	 	 	{
 	 	 	if($i~/absolute/)
 	 	 	 	{
 	 	 	 	col_index=i
 	 	 	 	}
 	 	 	if($i~/description/)
 	 	 	 	{
 	 	 	 	col_description=i
 	 	 	 	}
 	 	 	}
 	 	}
 	if(NR>=2)
 	 	{
 	 	print $col_index,$col_description
 	 	}
 	}' csi_fingerid.tsv > temp/ftaligntemp/pos_fingerprint_index;

awk -F $'\t' -v OFS=$'\t' '
 	{
 	if(NR==1)
 	 	{
 	 	for(i=1; i<=NF; i++)
 	 	 	{
 	 	 	if($i~/absolute/)
 	 	 	 	{
 	 	 	 	col_index=i
 	 	 	 	}
 	 	 	if($i~/description/)
 	 	 	 	{
 	 	 	 	col_description=i
 	 	 	 	}
 	 	 	}
 	 	}
 	if(NR>=2)
 	 	{
 	 	print $col_index,$col_description
 	 	}
 	}' csi_fingerid_neg.tsv > temp/ftaligntemp/neg_fingerprint_index;

posindex="temp/ftaligntemp/pos_fingerprint_index"

negindex="temp/ftaligntemp/neg_fingerprint_index"

data="temp/ms_data"

echo "step 4: merge data"

awk -F $'\t' '
 	BEGIN{
 	 	file=0
 	 	x=0
 	 	count=0
 	 	f=0
 	 	posnum=0
 	 	negnum=0
 	 	}
 	{
 	if(FNR==1)
 	 	{
 	 	file+=1
 	 	}
 	if(NR==FNR)
 	 	{
 	 	if(($1~/fingerprint/))
 	 	 	{
 	 	 	if(x>f)
 	 	 	 	{
 	 	 	 	f=x  # calculate the max index.
 	 	 	 	}
 	 	 	count+=1;  # calculate the all fingerprints file number.
 	 	 	\
 	 	 	split($1,a,"[/]"); e=split(a[1],b,"[_]"); id=b[e]; #catch the id.
 	 	 	\
 	 	 	x=0;
 	 	 	}
 	 	else
 	 	 	{
 	 	 	x+=1;
 	 	 	\
 	 	 	fp[id,x]=$1;
 	 	 	}
 	 	}
 	if(file==2)
 	 	{
 	 	pos[FNR]=$1
 	 	
 	 	posnum+=1
 	 	}
 	if(file==3)
 	 	{
 	 	neg[FNR]=$1
 	 	
 	 	negnum+=1
 	 	}
 	if(file==4)
 	 	{
 	 	if(fp[$1,1]!="" && fp[$2,1]!="")
 	 	 	{
 	 	 	n1=split($6, g, "[]]");
 	 	 	
 	 	 	n2=split($7, h, "[]]");
 	 	 	
 	 	 	if(g[n1]=="+" && h[n2]=="+")
 	 	 	 	{
 	 	 	 	for(x=1; x<=posnum; x++)
 	 	 	 	 	{
 	 	 	 	 	if(fp[$1,x]>='$plimit' && fp[$2,x]<='$plimit2')
	 	 	 	 	 	{
	 	 	 	 	 	data_s[FNR,x]=pos[x]
	 	 	 	 	 	}
	 	 	 	 	else if(fp[$2,x]>='$plimit' && fp[$1,x]<='$plimit2')
	 	 	 	 	 	{
	 	 	 	 	 	data_t[FNR,x]=pos[x]
	 	 	 	 	 	}
 	 	 	 	 	}
 	 	 	 	}
 	 	 	if(g[n1]=="-" && h[n2]=="-")
 	 	 	 	{
 	 	 	 	for(x=1; x<=negnum; x++)
 	 	 	 	 	{
 	 	 	 	 	if(fp[$1,x]>='$plimit' && fp[$2,x]<='$plimit2')
	 	 	 	 	 	{
	 	 	 	 	 	data_s[FNR,x]=neg[x]
	 	 	 	 	 	}
	 	 	 	 	else if(fp[$2,x]>='$plimit' && fp[$1,x]<='$plimit2')
	 	 	 	 	 	{
	 	 	 	 	 	data_t[FNR,x]=neg[x]
	 	 	 	 	 	}
 	 	 	 	 	}
 	 	 	 	}
 	 	 	if(g[n1]=="-" && h[n2]=="+" || h[n2]=="-" && g[n1]=="+")
 	 	 	 	{
 	 	 	 	for(i=1; i<=posnum; i++)
 	 	 	 	 	{
 	 	 	 	 	for(j=1; j<=negnum; j++)
 	 	 	 	 	 	{
 	 	 	 	 	 	if(pos[i]==neg[j])
 	 	 	 	 	 	 	{
 	 	 	 	 	 	 	mirror[i]=j 	#if pos=i, the identical index of neg is mirror[i]
 	 	 	 	 	 	 	}
 	 	 	 	 	 	}
 	 	 	 	 	}
 	 	 	 	}
 	 	 	if(g[n1]=="-" && h[n2]=="+")	
 	 	 	 	{
 	 	 	 	for(x=1; x<=f; x++)
 	 	 	 	 	{
 	 	 	 	 	if(fp[$1,mirror[x]]>='$plimit' && fp[$2,x]<='$plimit2')
 	 	 	 	 	 	{
 	 	 	 	 	 	data_s[FNR,x]=neg[mirror[x]]
 	 	 	 	 	 	}
 	 	 	 	 	else if(fp[$2,x]>='$plimit' && fp[$1,mirror[x]]<='$plimit2')
 	 	 	 	 	 	{
 	 	 	 	 	 	data_t[FNR,x]=neg[mirror[x]]
 	 	 	 	 	 	}
 	 	 	 	 	}
 	 	 	 	}
 	 	 	if(h[n2]=="-" && g[n1]=="+")
 	 	 	 	{
 	 	 	 	for(x=1; x<=f; x++)
 	 	 	 	 	{
 	 	 	 	 	if(fp[$1,x] >= '$plimit' && fp[$2,mirror[x]]<='$plimit2')
 	 	 	 	 	 	{
 	 	 	 	 	 	data_s[FNR,x]=neg[mirror[x]]
 	 	 	 	 	 	}
 	 	 	 	 	else if(fp[$2,mirror[x]]>='$plimit' && fp[$1,x]<='$plimit2')
 	 	 	 	 	 	{
 	 	 	 	 	 	data_t[FNR,x]=neg[mirror[x]]
 	 	 	 	 	 	}
 	 	 	 	 	}	 	
 	 	 	 	}
 	 	 	}
 	 	if(FNR==1)
 	 	 	{
 	 	 	printf "source\t"  "target\t"  "ftalign_similarity\t"  "delta_m/z\t"  "source_fp_uniq\t"  "target_fp_uniq\n"
 	 	 	}
 	 	else
 	 	 	{
 	 	 	printf $1"\t"  $2"\t"  $3"\t"  $4"\t";
 	 	 	\
 	 	 	if(fp[$1,1]=="" || fp[$2,1]=="")
 	 	 	 	{
 	 	 	 	printf "NA@NA\n"
 	 	 	 	}
 	 	 	else
 	 	 	 	{
 	 	 	 	printf "source:"  #the source fingerprint uniq.
 	 	 	 	\
 	 	 	 	for(x=1; x<=f; x++)
 	 	 	 	 	{
 	 	 	 	 	if(data_s[FNR,x]!="")
 	 	 	 	 	 	{
 	 	 	 	 	 	printf data_s[FNR,x]","
 	 	 	 	 	 	}
 	 	 	 	 	};
 	 	 	 	printf "@target:"  #the target fingerprint uniq.
 	 	 	 	\
 	 	 	 	for(x=1; x<=f; x++)
 	 	 	 	 	{
 	 	 	 	 	if(data_t[FNR,x]!="")
 	 	 	 	 	 	{
 	 	 	 	 	 	printf data_t[FNR,x]","
 	 	 	 	 	 	}
 	 	 	 	 	}
 	 	 	 	printf "\n"
 	 	 	 	}
 	 	 	}
 	 	}
 	}' $data_allfp $posindex $negindex $data | sed -e 's/,@/\t/g; s/,$//g; s/@/\t/g' \
 	\
 	> results/source_target_tree_$tlimit.tsv;
 	 
	echo "All instances have written into <results/source_target_tree_$tlimit.tsv>."
;;
```

```{r eval = F, echo = T}
###################################
```

```{r eval = F, echo = T}
###################################
compound_idenfication)

echo "Run compound_idenfication."







echo "compound_idenfication "

exit

;;
```

```{r eval = F, echo = T}
###################################
```

```{r eval = F, echo = T}
###################################
double_ion_network)

exit;

;;

```

```{r eval = F, echo = T}
###################################
```

```{r eval = F, echo = T}
###################################
```

```{r eval = F, echo = T}
###################################
```

```{r eval = F, echo = T}
###################################
exit)
echo "The mystery of creation is like the darkness of night--it is great.
Delusions of knowledge are like the fog of the morning."
exit;
;;
```

```{r eval = F, echo = T}
###################################
```

```{r eval = F, echo = T}
###################################
```

```{r eval = F, echo = T}
###################################
```

```{r eval = F, echo = T}
###################################
*)
echo "error"
exit;
;;
esac;
done;#(for)
done;#(select)

```

# File: mz_alignment.sh

```{r eval = F, echo = T}
data1="serum_neg_mzmine_0030.mgf"
awk -F $'\t' '
{
  if()
}'
```

# File: name_iupuc.sh

```{r eval = F, echo = T}
# vconda activate STOUT
echo "INFO: make sure you have run: conda activate STOUT"
workdir=$(dirs | sed 's/~/\/home\/'$USER'/g')
read -p "Please input file name to convert >>> " i
awk -F $'\t' '
{
  if(FNR==1)
    {
      for(i=1; i<=NF; i++)
        {
          if($i~/^smiles$/)
            {
              col_smiles=i
            }
        }
    }
  if(FNR>=2)
    {
      printf $col_smiles"\n" > "SMILES_temp"
    }
}' $i
sed -i s#\'##g SMILES_temp
file=SMILES_temp
cd /home/$USER/Downloads/codes/github_tool/SMILES-to-IUPAC-Translator
python STOUT_V_2.1.py --STI ${workdir}/$file ${workdir}/iupuc_${i} #SMILES to IUPAC
## python STOUT_V_2.1.py --STI test out #SMILES to IUPAC
cd $workdir
rm SMILES_temp
```

# File: obabel.sh

```{r eval = F, echo = T}
cd ~/operation/back/0703_all/results/structure_2d/
data="../../com_compound.tsv"
data_repel="pubchem.tsv"
awk -F $'\t' '
 	{
 	if(NR==FNR)
 	 	{
	 	if(FNR==1)
	 	 	{
	 	 	for(i=1; i<=NF; i++)
	 	 	 	{
	 	 	 	if($i~/^id$/)
	 	 	 	 	{
	 	 	 	 	col_id=i
	 	 	 	 	}
	 	 	 	if($i~/smiles/)
	 	 	 	 	{
	 	 	 	 	col_smilse=i
	 	 	 	 	}
	 	 	 	if($i~/links/)
	 	 	 	 	{
	 	 	 	 	col_links=i
	 	 	 	 	}
	 	 	 	}
	 	 	}
	 	if(FNR>=2)
	 	 	{
	 	 	# print FNR," >>> ",$col_id
	 	 	if($col_links~/^PubChem/)
	 	 	 	{
	 	 	 	split($col_links, a, "[:][(]||[,][ ]||[)][;]||[)]")
	 	 	 	cid[$col_id]=a[2]
	 	 	 	# print a[2]
	 	 	 	}
	 	 	}
	 	}
	if(NR>FNR)
	 	{
	 	if(FNR==1)
	 	 	{
	 	 	file=FILENAME
	 	 	}
	 	if(FNR>=2)
	 	 	{
	 	 	repel[$1]=$1
	 	 	}
	 	}
	}
 	END{ 	
 	 	close(file)
 	 	RS="|||"
 	 	printf "id\t"  "cid\n" > "cid_metadata.tsv"
 	 	for(i in cid)
 	 	 	{
 	 	 	n+=1
 	 	 	printf i"\t"  cid[i]"\n" >> "cid_metadata.tsv"
 	 	 	if(n==1)
 	 	 	 	{
 	 	 	 	cid_set=cid[i]
 	 	 	 	}
 	 	 	if(n>=2)
 	 	 	 	{
 	 	 	 	cid_set=cid_set","cid[i]
 	 	 	 	}
 	 	 	}
 	 	# print cid_set
 	 	printf "id\t"  "cid\t" "IUPACName\t" "canonical_smiles\t"  "isomeric_smiles\n" >> "pubchem.tsv"
 	 	for(i in cid)
 	 	 	{
 	 	 	if(repel[i]=="")
 	 	 	 	{
	 	 	 	"curl https://pubchem.ncbi.nlm.nih.gov/rest/pug/compound/cid/" \
	 	 	 	\
	 	 	 	cid[i] \
	 	 	 	\
	 	 	 	"/property/IUPACName,CanonicalSMILES,IsomericSMILES/CSV" \
	 	 	 	\
	 	 	 	|getline data;
	 	 	 	gsub(/(.*)\n/,"",data)
	 	 	 	gsub(/,/,"\t",data)
	 	 	 	printf i"\t" data"\n" >> "pubchem.tsv"
	 	 	 	close("curl https://pubchem.ncbi.nlm.nih.gov/rest/pug/compound/cid/" \
	 	 	 	\
	 	 	 	cid[i] \
	 	 	 	\
	 	 	 	"/property/CanonicalSMILES,IsomericSMILES/CSV")
	 	 	 	}
	 	 	}
 	 	}' $data $data_repel
 ######################
 data="pubchem.tsv"
 sort -r $data | uniq > re_pubchem.tsv
 ######################
 data="re_pubchem.tsv"
 awk -F $'\t' '
  	{
  	if(FNR==1)
  	 	{
  	 	for(i=1; i<=NF; i++)
  	 	 	{
  	 	 	if($i~/^id$/)
  	 	 	 	{
  	 	 	 	col_id=i
  	 	 	 	}
  	 	 	if($i~/isomeric/)
  	 	 	 	{
  	 	 	 	col_isomeric=i
  	 	 	 	}
  	 	 	}
  	 	}
  	if(FNR>=2)
  	 	{
  	 	print $col_isomeric
  	 	system("obabel -:"  $col_isomeric  " -osvg -O "  $col_id  ".svg")
  	 	close("obabel -:"  $col_isomeric  " -osvg -O "  $col_id  ".svg")
  	 	}
  	}' $data
 #####################
 sed -i 's/white/transparent/g' [0-9]*.svg
 #####################
 ls *.svg | awk '
  	{
  	if($0~/cairo/)
  	 	{
  	 	next
  	 	}
  	else
  	 	{
  	 	system("cairosvg "  $0  " -o cairo_"  $0)
  	 	close("cairosvg "  $0  " -o cairo_"  $0)
  	 	}
  	}'
 #####################
 #####################
 #####################
 #####################
 # select <- c(279, 458, 574, 1107, 1445, 2227, 2529, 2664, 2824, 3380, 3918, 3938)
 idset=279,458,574,1107,1445,2227,2529,2664,2824,3380,3918,3938
 mkdir smiles_draw
 #path=~/operation/back/0703_all
 data="../../com_lignans_and_iridoids.tsv"
 savepath="smiles_draw"
 awk -F $'\t' '
  	BEGIN{
  	 	n=split("'$idset'", a, "[,]")
  	 	print n, a[1], a[2]
  	 	}
  	{
  	if(FNR==1)
  	 	{
  	 	print FILENAME
  	 	for(i=1; i<=NF; i++)
  	 	 	{
  	 	 	if($i~/^id/)
  	 	 	 	{
  	 	 	 	col_id=i
  	 	 	 	}
  	 	 	if($i~/smiles/)
  	 	 	 	{
  	 	 	 	col_smiles=i
  	 	 	 	}
  	 	 	}
  	 	}
  	if(FNR>=2)
  	 	{
  	 	for(i in a)
  	 	 	{
  	 	 	if($col_id==a[i])
  	 	 	 	{
  	 	 	 	print $col_id, $col_smiles
  	 	 	 	system("obabel -:\""  $col_smiles  "\" -osvg -O '$savepath'/"  $col_id  ".svg")
  	 	 	 	close("obabel -:\""  $col_smiles  "\" -osvg -O '$savepath'/"  $col_id  ".svg")
  	 	 	 	}
  	 	 	}
  	 	}
  	}' $data
 ###########################
 ###########################
 idset=279,458,574,1107,1445,2227,2529,2664,2824,3380,3918,3938
 data1="re_pubchem.tsv"
 data2="../../com_lignans_and_iridoids.tsv"
 savepath="smiles_draw"
 awk -F $'\t' '
  	BEGIN{
  	 	n=split("'$idset'", a, "[,]")
  	 	print n, a[1], a[2]
  	 	}
  	{
  	if(FNR==1)
  	 	{
  	 	for(i=1; i<=NF; i++)
  	 	 	{
  	 	 	if($i~/^id$/)
  	 	 	 	{
  	 	 	 	col_id=i
  	 	 	 	}
  	 	 	if($i~/isomeric/)
  	 	 	 	{
  	 	 	 	col_isomeric=i
  	 	 	 	}
  	 	 	if($i~/^smiles/)
  	 	 	 	{
  	 	 	 	col_smiles=i
  	 	 	 	}
  	 	 	}
  	 	}
  	if(FNR>=2 && FILENAME ~/pubchem/)
  	 	{
  	 	for(i in a)
  	 	 	{
  	 	 	if($col_id==a[i])
  	 	 	 	{
	 	  	 	iso[$col_id]=$col_isomeric
	 	  	 	}
	 	  	}
  	 	}
  	if(FNR>=2 && FILENAME ~/com_/)
  	 	{
  	 	for(i in a)
  	 	 	{
  	 	 	if($col_id==a[i])
  	 	 	 	{
	 	  	 	smiles[$col_id]=$col_smiles
	 	  	 	}
	 	  	}
  	 	}
  	}
  	END{
  	 	printf "id\t"  "smiles\t"  "isomeric\n" > "'$savepath'/structure_chemdraw.tsv"
  	 	for(i in a)
  	 	 	{
  	 	 	printf a[i]"\t"  smiles[a[i]]"\t"  iso[a[i]]"\n" > "'$savepath'/structure_chemdraw.tsv"
  	 	 	}
  	 	}' $data1 $data2
 #####################
 #####################
 #####################
 #####################
 #####################
 ## complementation get SDF data
 mkdir sdf
 data="../../com_compound.tsv"
 savepath="sdf/"
 awk -F $'\t' '
 	{
 	if(NR==FNR)
 	 	{
	 	if(FNR==1)
	 	 	{
	 	 	for(i=1; i<=NF; i++)
	 	 	 	{
	 	 	 	if($i~/^id$/)
	 	 	 	 	{
	 	 	 	 	col_id=i
	 	 	 	 	}
	 	 	 	if($i~/smiles/)
	 	 	 	 	{
	 	 	 	 	col_smilse=i
	 	 	 	 	}
	 	 	 	if($i~/links/)
	 	 	 	 	{
	 	 	 	 	col_links=i
	 	 	 	 	}
	 	 	 	}
	 	 	}
	 	if(FNR>=2)
	 	 	{
	 	 	# print FNR," >>> ",$col_id
	 	 	if($col_links~/^PubChem/)
	 	 	 	{
	 	 	 	split($col_links, a, "[:][(]||[,][ ]||[)][;]||[)]")
	 	 	 	cid[$col_id]=a[2]
	 	 	 	# print a[2]
	 	 	 	}
	 	 	}
	 	}
	}
 	END{	
 	 	for(i in cid)
 	 	 	{
 	 	 	if(repel[i]=="")
 	 	 	 	{
	 	 	 	system("curl https://pubchem.ncbi.nlm.nih.gov/rest/pug/compound/cid/" \
	 	 	 	\
	 	 	 	cid[i] \
	 	 	 	\
	 	 	 	"/SDF > '$savepath'" i ".SDF")
	 	 	 	close("curl https://pubchem.ncbi.nlm.nih.gov/rest/pug/compound/cid/" \
	 	 	 	\
	 	 	 	cid[i] \
	 	 	 	\
	 	 	 	"/SDF > '$savepath'" i ".SDF")
	 	 	 	}
	 	 	}
 	 	}' $data
 #####################
 sed -i '1c\ ' sdf/[0-9]*.SDF
 #####################
 ls sdf/[0-9]*.SDF | awk -F $'\t' '
  	{
  	system("obabel "  $0  " -iSDF -osvg -O "  $col_id  ".svg")
  	close("obabel "  $0  " -iSDF -osvg -O "  $col_id  ".svg")
  	}' 
 #####################
 sed -i -e 's/white/transparent/g; s/stroke-width="2.0"/stroke-width="4.0"/g;' sdf/[0-9]*SDF.svg
 #####################
 ls sdf/[0-9]*.svg | awk '
  	{
  	if($0~/cairo/)
  	 	{
  	 	next
  	 	}
  	else
  	 	{
  	 	system("cairosvg "  $0  " -o "  $0 ".cairo.svg")
  	 	close("cairosvg "  $0  " -o "  $0 ".cairo.svg")
  	 	}
  	}'
 #####################
 ##################### 
 #####################
 ## mavin molconvert
 #####################
  ls smiles_draw/[0-9]*_1.sdf | awk -F $'\t' '
  	{
  	split($0, a, "[_][1][.][s][d][f]")
  	system("obabel "  $0  " -iSDF -osvg -O "  a[1]  ".svg")
  	close("obabel "  $0  " -iSDF -osvg -O "  a[1]  ".svg")
  	print a[1]".svg"
  	}'
 #####################
 ### create name
 molconvert "name:common,all" -s "COC(=O)C1=COC(C2C1CC=C2CO)OC3C(C(C(C(O3)CO)O)O)O"

```

# File: pubchem_hub_keggn.sh

```{r eval = F, echo = T}
mkdir synonyms
data=fingerid_candidate_top.tsv
# data=fingerid_first_score.tsv
awk -F $'\t' '
{
  if(NR==FNR)
    {
      if(FNR==1)
        {
          for(i=1; i<=NF; i++)
            {
              if($i~/^id$/)
                {
                  col_id=i
                }
              if($i~/smiles/)
                {
                  col_smilse=i
                }
              if($i~/links/)
                {
                  col_links=i
                }
            }
        }
      if(FNR>=2)
        {
          if(id==$col_id)
            {
              rankn+=1
            }
        else
          {
            rankn=1
          }
          id=$col_id
          # print FNR," >>> ",$col_id
          if($col_links~/^PubChem/)
            {
              l=split($col_links, a, "[;]")
              if(a[1]~/PubChem/)
                {
                  n=split( a[1], b, "[(]||[,][ ]||[)]" )
                  for(i=2; i<=n-1; i++)
                    {
                      cid_set[b[i]]=$col_id
                      rank_compound[$col_id, b[i]]=rankn
                    }
                }
            }
          if($col_links~/KEGG/)
            {
              l=split($col_links, a, "[;]")
              for(j=1; j<=l; j++)
                {
                  if(a[j]~/KEGG/)
                    {
                      n=split( a[j], b, "[(]||[,][ ]||[)]" )
                      for(i=2; i<=n-1; i++)
                        {
                          kegg_set[b[i]]=$col_id
                          rank_compound[$col_id, b[i],"kegg"]=rankn
                        }
                    }
                }
            }
        }
    }
}
END{ 	
printf "cid\t" "id\t" "kegg\t" "score_rank\n" > "synonyms/kegg_complement.tsv"
for(i in kegg_set)
  {
    printf "null\t"  kegg_set[i]"\t"  i"\t"  rank_compound[kegg_set[i], i, "kegg"]"\n" > "synonyms/kegg_complement.tsv"
  }
printf "id\t"  "cid\t" "score_rank\n" > "synonyms/cid_metadata.tsv"
for(i in cid_set)
  {
    if(i!="null")
      {
        n+=1
        printf cid_set[i]"\t"  i"\t" rank_compound[cid_set[i], i]"\n" >> "synonyms/cid_metadata.tsv"
        if(n==1)
          {
            cid_sets=i
          }
        if(n>=2)
          {
            cid_sets=cid_sets","i
          }
      }
  }
# print cid_set
}' $data
## oganize cid dataset
list=$(
  awk -F $'\t' '
  {
    if(NR==2)
      {
        printf $2
      }
    if(NR>2)
      {
        n+=1
        if(n<=100)
          {
            printf ","$2
          }
      else
        {
          n=1
          printf "\n"$2
        }
      }
  }' synonyms/cid_metadata.tsv
)
nrow=$(awk 'END{print NR}' <(echo "$list"))
## search pubchem
for i in $(seq $nrow)
do
  cids=$(awk '{if(NR=='$i'){print $0}}' <(echo "$list"))
  check=$(echo "$cids" | awk '{if($0~/^[0-9]/){printf 0}else{printf 1}}')
  while [ $check == 0 ]
  do
    echo "Try catch pubchem API (${i}/${nrow})..."
    ## check file
    if [ -f synonyms/${i}_synonyms.XML ]
    then
      check=$(awk '{if(FNR==1){if($0~/xml version/){printf "1"}else{printf "0"}}}
      END{if(FNR==0){printf "0"}}' synonyms/${i}_synonyms.XML)
    fi;
    ## catch data via curl
    if [ $check == 0 ]
    then
      curl --connect-timeout 20 --retry 100 --retry-delay 30 https://pubchem.ncbi.nlm.nih.gov/rest/pug/compound/cid/${cids}/synonyms/XML > synonyms/${i}_synonyms.XML
    fi;
  done
done
## data reformat
awk -F "[>]||[<][/]" '
{
  if(NR==1)
    {
      target_file="synonyms/reformat_kegg.tsv"
      printf "cid\t" "kegg\n" > target_file
    }
  if($1~/<CID$/)
    {
      cid=$2
    }
  if($2~/^C[0-9]*[0-9]$/)
    {
      printf cid"\t" $2"\n" > target_file
    }
}' synonyms/*_synonyms.XML

## excute next step
## history
## serum_neg.R
```

# File: pubchem_hub.sh

```{r eval = F, echo = T}
data="fingerid_first_score.tsv"
## data='lignans_and_iridoids.tsv'
awk -F $'\t' '
 	{
 	if(NR==FNR)
 	 	{
	 	if(FNR==1)
	 	 	{
	 	 	for(i=1; i<=NF; i++)
	 	 	 	{
	 	 	 	if($i~/^id$/)
	 	 	 	 	{
	 	 	 	 	col_id=i
	 	 	 	 	}
	 	 	 	if($i~/smiles/)
	 	 	 	 	{
	 	 	 	 	col_smilse=i
	 	 	 	 	}
	 	 	 	if($i~/links/)
	 	 	 	 	{
	 	 	 	 	col_links=i
	 	 	 	 	}
	 	 	 	}
	 	 	}
	 	if(FNR>=2)
	 	 	{
	 	 	# print FNR," >>> ",$col_id
	 	 	if($col_links~/^PubChem/)
	 	 	 	{
	 	 	 	split($col_links, a, "[:][(]||[,][ ]||[)][;]||[)]")
	 	 	 	cid[$col_id]=a[2]
	 	 	 	# print a[2]
	 	 	 	}
	 	 	}
	 	}
	}
 	END{ 	
 	 	printf "id\t"  "cid\n" > "cid_metadata.tsv"
 	 	for(i in cid)
 	 	 	{
 	 	 	n+=1
 	 	 	printf i"\t"  cid[i]"\n" >> "cid_metadata.tsv"
 	 	 	if(n==1)
 	 	 	 	{
 	 	 	 	cid_set=cid[i]
 	 	 	 	}
 	 	 	if(n>=2)
 	 	 	 	{
 	 	 	 	cid_set=cid_set","cid[i]
 	 	 	 	}
 	 	 	}
 	 	# print cid_set
 	 	}' $data

list=$(
  awk -F $'\t' '
  {
    if(NR==2)
      {
        printf $2
      }
    if(NR>2)
      {
        n+=1
        if(n<=100)
          {
            printf ","$2
          }
      else
        {
          n=1
          printf "\n"$2
        }
      }
  }' cid_metadata.tsv
)

nrow=$(awk 'END{print NR}' <(echo "$list"))

for i in $(seq $nrow)
do
  cids=$(awk '{if(NR=='$i'){print $0}}' <(echo "$list"))
  check=$(echo "$cids" | awk '{if($0~/^[0-9]/){printf 0}else{printf 1}}')
  while [ $check == 0 ]
  do
    echo "Try catch pubchem API (${i}/${nrow})..."
    if [ -f ${i}_smiles.csv ]
    then
      check=$(awk '
      {
        if(FNR==1)
          {
            if($0~/CID/)
              {
                printf "1"
              }
          else
            {
              printf "0"
            }
        }
    }
  END{
  if(FNR==0)
    {
      printf "0"
    }
}' ${i}_smiles.csv)
    fi;
if [ $check == 0 ]
then
  curl --connect-timeout 20 --retry 100 --retry-delay 30 https://pubchem.ncbi.nlm.nih.gov/rest/pug/compound/cid/${cids}/property/IUPACName,CanonicalSMILES,IsomericSMILES/CSV > ${i}_smiles.csv
fi;
done;
done;

## run pubchem_hub_merge.R
```

# File: R_network_code.sh

```{r eval = F, echo = T}
mkdir r_network
mkdir r_network/temp
mkdir r_network/ms2_figures
mkdir r_network/structure_svg
mkdir r_network/frags_figures
mkdir r_network/annonation
mkdir r_network/nodes_figures
```

```{r eval = F, echo = T}
#############################
```

```{r eval = F, echo = T}
#############################
```

```{r eval = F, echo = T}
#############################
```

```{r eval = F, echo = T}
#####
```

```{r eval = F, echo = T}
##############
```

```{r eval = F, echo = T}
######for Unix
#edges
file="results/source_target_tree*"
data=$(awk '{if(($1 ~ /^[0-9]/)){print $0}}' $file)
```

```{r eval = F, echo = T}
################
```

```{r eval = F, echo = T}
################
```

```{r eval = F, echo = T}
################
awk -F ["\t":,] '{
 	if(NR==1)
 	 	{
 	 	printf "from\t"  "to\t"  "length\t"  "width\t"  "label\t"  "arrows\t"  "dashes\t"  "smooth\t"  "shadow\t"  "title\n"
 	 	}
 	if(NR>=2)
 	 	{
 	 	norm=sprintf("%.2f",$3);
 	 	\
 	 	norm2=sprintf("%.2f",$4);
 	 	\
 	 	len=150/$3;
 	 	\
 	 	width=10*$3;
 	 	\
 	 	printf $1"\t"  $2"\t"  len"\t"  width"\t"  norm2"\t"  "to\t"  "FALSE\t"  "FALSE\t"  "FALSE\t" \
 	 	\
 	 	"<b>ftalign_similarity:"norm"</b>"  "</br>"  "<b>delta_m/z:"norm2"</b>"  "</br>";\
 	 	\
 	 	for(i=5; i<=NF; i++)
 	 	 	{
 	 	 	if(i>=6 && $i=="NA")
 	 	 	 	{
 	 	 	 	NA=1
 	 	 	 	}
	 	 	if($i=="source")
 	 	 	 	{
 	 	 	 	a=i+1;
 	 	 	 	}
 	 	 	if($i=="target")
 	 	 	 	{
 	 	 	 	b=i;
 	 	 	 	\
 	 	 	 	c=i+1
 	 	 	 	}
 	 	 	};
 	 	if(NA==1)
 	 	 	{
 	 	 	printf "fp:NA\n";
 	 	 	}
 	 	if(NA!=1)
 	 	 	{
 	 	 	printf "</br>source_uniq_fp:</br>";
 	 	 	\
 	 	 	for(x=a; x<b; x++)
 	 	 	 	{
 	 	 	 	printf "<a href=+frags_figures|" $x ".svg+target=+_blank+>" $x "</a> ";
 	 	 	 	}
 	 	 	printf "</br>target_uniq_fp:</br>";
 	 	 	\
 	 	 	for(y=c; y<=NF; y++)
 	 	 	 	{
 	 	 	 	if(y!=NF)
 	 	 	 	 	{
 	 	 	 	 	printf "<a href=+frags_figures|" $y ".svg+target=+_blank+>" $y "</a> ";
 	 	 	 	 	}
 	 	 	 	else
 	 	 	 	 	{
 	 	 	 	 	printf "<a href=+frags_figures|" $y ".svg+target=+_blank+>" $y "</a>\n";
 	 	 	 	 	}
 	 	 	 	}
 	 	 	}
 	 	}
 	}' <(echo "$data") | sed -e 's/|/\//g;s/+/\"/g;$d' > r_network/edges.tsv
###<a href="test.txt"target="_blank">点击打开本地文件</a>
```

```{r eval = F, echo = T}
############################
```

```{r eval = F, echo = T}
############################
```

```{r eval = F, echo = T}
############################
```

```{r eval = F, echo = T}
############################
```

```{r eval = F, echo = T}
############################
```

```{r eval = F, echo = T}
############################
```

```{r eval = F, echo = T}
############################
###to create nodes(table)
#sort sample
mzmine_path="../neg.csv"
version=$(echo | awk '{l=asort(a,b);print l}')
 	if [ $version == 0 ]
 	then
 	mzmine_data=$(awk -F , '
 	 	{
 	 	if(NR==1)
 	 	 	{
 	 	 	for(i=4; i<=NF; i++)
 	 	 	 	{
 	 	 	 	col_sample[$i]=i
 	 	 	 	}
 	 	 	l=asorti(col_sample,b)
 	 	 	\
 	 	 	printf $1 "\t" $2 "\t" $3 "\t"
 	 	 	\
 	 	 	for(i=1; i<l; i++)
 	 	 	 	{
 	 	 	 	printf b[i] "\t"
 	 	 	 	}
 	 	 	printf b[l] "\n"
 	 	 	}
 	 	if(NR>=2)
 	 	 	{
 	 	 	printf $1"\t" $2"\t" $3"\t"
 	 	 	\
 	 	 	for(i=1; i<l; i++)
 	 	 	 	{
 	 	 	 	printf $col_sample[b[i]] "\t"
 	 	 	 	}
 	 	 	printf $col_sample[b[l]] "\n"
 	 	 	}
 	 	}' $mzmine_path)
 	echo "$mzmine_data" > r_network/mzmine_table.tsv
 	fi;
mzmine="r_network/mzmine_table.tsv"
```

```{r eval = F, echo = T}
###########################
```

```{r eval = F, echo = T}
###########################
awk -F $'\t' '
 	{
 	if(NR==1)
 	 	{
 	 	printf "id\tlabel\tgroup\tvalue\tshape\timage\tshadow\ttitle\n"
 	 	}
 	if(NR>=2)
 	 	{
 	 	norm=sprintf("%.4f",$2);
 	 	\
 	 	normrt=sprintf("%.2f",$3);
 	 	\
 	 	printf $1"\t"  norm  "\tNA"  "\t5"  "\timage"  "\tnodes_figures|"$1".svg\t"  "FALSE\t"\
 	 	\
 	 	"<b>ID:"$1"</b>" "</br>" "m/z:"norm "</br>" "RT(min):"normrt "</br>"\
 	 	\
 	 	"<a href=+ms2_figures|"$1".svg+target=+_blank+>See_MS2_spectra</a>" "</br>"\
 	 	\
 	 	"<a href=+structure_svg|"$1".svg+target=+_blank+>See_Structure_svg</a>" "</br>"\
 	 	\
 	 	"<a href=+annonation|"$1"+target=+_blank+>See_annonation</a>"\
 	 	\
 	 	"\n"
 	 	}
 	}' $mzmine | sed -e 's/|/\//g;s/+/\"/g;$d' > r_network/nodes.tsv
```

```{r eval = F, echo = T}
####tooltips#<a href="test.txt"target="_blank">点击打开本地文件</a>
```

```{r eval = F, echo = T}
###########################
```

```{r eval = F, echo = T}
###########################
```

```{r eval = F, echo = T}
############################
###to create ms2 figure(table)
data1="temp/Mo_filename"
data2="*_*/spectrum.ms"
data3=$(awk -F $'\t' '
 	{
 	if(system("test -f " $2 "/spectra/" $1 "*.tsv"))
 	 	{
 	 	printf ""
 	 	}
 	else
 	 	{
 	 	printf $2 "/spectra/" $1 "*.tsv "
 	 	}
 	}' $data1)
# to   r_network/ms2_figures/<id>_<formula>.tsv
mkdir results/ms2_figures
savepath="results/ms2_figures/"
awk -F ["\t"" "] '
 	BEGIN{
 	 	file_number=0
 	 	}
 	{
 	if(FNR==1)
 	 	{
 	 	if(FILENAME!=p_filename)
 	 	 	{
 	 	 	file_number+=1
 	 	 	}
 	 	if(file_number>=2)
 	 	 	{
 	 	 	close(p_filename)
 	 	 	}
 	 	p_filename=FILENAME
 	 	\
 	 	if((FILENAME~/spectrum.ms/))
 	 	 	{
 	 	 	step=2
 	 	 	}
 	 	else if((FILENAME~/spectra/))
 	 	 	{
 	 	 	step=3
 	 	 	}
 	 	}
 	if(NR==FNR)
 	 	{
 	 	formu[FNR]=$1
 	 	\
 	 	file[FNR]=$2
 	 	\
 	 	n=split($2,a,"[_]")
 	 	\
 	 	id[FNR]=a[n]
 	 	\
 	 	rows_data1=FNR
 	 	}
 	else if(step==2)
 	 	{
 	 	if(FNR==1)
 	 	 	{
 	 	 	the_id=$2
 	 	 	start=0
 	 	 	}
 	 	if(($1~/ms2peaks/))
 	 	 	{
 	 	 	start=FNR
 	 	 	}
 	 	if(start!=0)
 	 	 	{
 	 	 	n_ms2=FNR-start
 	 	 	\
 	 	 	msms[the_id,"mz",n_ms2]=$1
 	 	 	\
 	 	 	msms[the_id,"inten",n_ms2]=$2
 	 	 	\
 	 	 	if(max_n=="" || max_n<n_ms2)
 	 	 	 	{
 	 	 	 	max_n=n_ms2
 	 	 	 	}
 	 	 	if(max_inten[the_id]=="" || max_inten[the_id]<$2)
 	 	 	 	{
 	 	 	 	max_inten[the_id]=$2
 	 	 	 	}
 	 	 	}	
 	 	}
 	else if(step==3)
 	 	{
 	 	if(FNR==1)
 	 	 	{
 	 	 	if(step3_pro>=2)
 	 	 	 	{
 	 	 	 	close("'$savepath'"  the_id  ".tsv")
 	 	 	 	}
 	 	 	for(i=1; i<=rows_data1; i++)
 	 	 	 	{
 	 	 	 	if((FILENAME ~ file[i]) && (FILENAME ~ formu[i]))
 	 	 	 	 	{
 	 	 	 	 	the_id=id[i]
 	 	 	 	 	\
 	 	 	 	 	formula=formu[i]
 	 	 	 	 	\
 	 	 	 	 	break
 	 	 	 	 	}
 	 	 	 	else x=n+1
 	 	 	 	}
 	 	 	if(x==rows_data1+1)
 	 	 	 	{
 	 	 	 	nextfile
 	 	 	 	}
 	 	 	step3_pro+=1
 	 	 	\
 	 	 	if(step3_pro==1)
 	 	 	 	{
 	 	 	 	FS="[\t]"
 	 	 	 	if(FNR==1)
 	 	 	 	 	{
 	 	 	 	 	for(i=1; i<=NF; i++)
 	 	 	 	 	 	{
 	 	 	 	 	 	if(($i~/mz/))
 	 	 	 	 	 	 	{
 	 	 	 	 	 	 	col_mz=i
 	 	 	 	 	 	 	}
 	 	 	 	 	 	if(($i~/rel/))
 	 	 	 	 	 	 	{
 	 	 	 	 	 	 	col_rel=i
 	 	 	 	 	 	 	}
 	 	 	 	 	 	if($i~/formula/)
 	 	 	 	 	 	 	{
 	 	 	 	 	 	 	col_formula=i
 	 	 	 	 	 	 	}
 	 	 	 	 	 	if($i~/ionization/)
 	 	 	 	 	 	 	{
 	 	 	 	 	 	 	col_ion=i
 	 	 	 	 	 	 	}
 	 	 	 	 	 	}
 	 	 	 	 	}
 	 	 	 	}
 	 	 	printf "mz\t"  "rel.intensity\t"  "formula\t"  "ionization\n" > "'$savepath'"  the_id  ".tsv"
 	 	 	\
 	 	 	for(j=1; j<=max_n; j++)
 	 	 	 	{
 	 	 	 	if(msms[the_id,"mz",j]!="")
 	 	 	 	 	{
 	 	 	 	 	printf msms[the_id,"mz",j]"\t" \
 	 	 	 	 	\
 	 	 	 	 	(msms[the_id,"inten",j]/max_inten[the_id])*100 "\n" >> "'$savepath'"  the_id  ".tsv"
 	 	 	 	 	}
 	 	 	 	}
 	 	 	}
 	 	if(FNR>=2)
 	 	 	{
 	 	 	norm=$col_rel*(-1)
 	 	 	\
 	 	 	printf $col_mz"\t"  norm"\t"  $col_formula"\t"  $col_ion"\n" >> "'$savepath'"  the_id  ".tsv"
 	 	 	}
 	 	}
 	}' $data1 $data2 $data3
```

```{r eval = F, echo = T}
###########################
#create match point
mkdir results/ms2_figures_match
data="results/ms2_figures/*.tsv"
savepath="results/ms2_figures_match/"
mz_tolerance="0.01"
in_tolerance="20"
awk -F $'\t' '
 	{
 	if(FNR==1)
 	 	{
 	 	file_num+=1
 	 	n=split(FILENAME,a,"[/]")
 	 	split(a[n],b,"[.]")
 	 	id=b[1]
 	 	if(file_num==1)
 	 	 	{
 	 	 	p_id=id
 	 	 	p_file=FILENAME
 	 	 	for(i=1; i<=NF; i++)
 	 	 	 	{
 	 	 	 	if($i~/mz/)
 	 	 	 	 	{
 	 	 	 	 	col_mz=i
 	 	 	 	 	}
 	 	 	 	if($i~/intensity/)
 	 	 	 	 	{
 	 	 	 	 	col_intensity=i
 	 	 	 	 	}
 	 	 	 	if($i~/formula/)
 	 	 	 	 	{
 	 	 	 	 	col_formula=i
 	 	 	 	 	}
 	 	 	 	if($i~/ionization/)
 	 	 	 	 	{
 	 	 	 	 	col_ion=i
 	 	 	 	 	}
 	 	 	 	}
 	 	 	}
 	 	if(file_num>=2)
 	 	 	{
 	 	 	close(p_file)
 	 	 	for(i in neg_mz)
 	 	 	 	{
 	 	 	 	for(j in pos_mz)
 	 	 	 	 	{
 	 	 	 	 	if(neg_mz[i]>=pos_mz[j]-"'$mz_tolerance'" && neg_mz[i]<=pos_mz[j]+"'$mz_tolerance'")
 	 	 	 	 	 	{
 	 	 	 	 	 	if((-1)*neg_in[i]>=pos_in[j]-"'$in_tolerance'" && (-1)*neg_in[i]<=pos_in[j]+"'$in_tolerance'")
 	 	 	 	 	 	 	{
 	 	 	 	 	 	 	match_p[i]+=1
 	 	 	 	 	 	 	match_p[j]+=1
 	 	 	 	 	 	 	}
 	 	 	 	 	 	}
 	 	 	 	 	}
 	 	 	 	}
 	 	 	delete neg_mz
 	 	 	delete pos_mz
 	 	 	printf "mz\t"  "rel.intensity\t"  "match\t"  "formula\t"  "ionization\n" > "'$savepath'" p_id ".tsv"
 	 	 	for(i=2; i<=max_FNR[p_file]; i++)
 	 	 	 	{
 	 	 	 	if(match_p[p_file,i]=="")
	 	 	 	 	{
	 	 	 	 	match_p[p_file,i]=0
	 	 	 	 	}
 	 	 	 	printf mz[p_file,i]"\t" intensity[p_file,i]"\t" match_p[p_file,i]"\t" formula[p_file,i]"\t" ion[p_file,i]"\n" \
 	 	 	 	\
 	 	 	 	>> "'$savepath'" p_id ".tsv"
 	 	 	 	}
 	 	 	if(p_id==2664)
 	 	 	 	{
 	 	 	 	printf file_num"\n"
 	 	 	 	}
 	 	 	close("'$savepath'" p_id ".tsv")
 	 	 	p_id=id
 	 	 	p_file=FILENAME
 	 	 	}
 	 	}
 	if(FNR>=2)
 	 	{
 	 	max_FNR[FILENAME]=FNR
 	 	mz[FILENAME,FNR]=$col_mz
 	 	intensity[FILENAME,FNR]=$col_intensity
 	 	formula[FILENAME,FNR]=$col_formula
 	 	ion[FILENAME,FNR]=$col_ion
 	 	if($col_intensity>0)
 	 	 	{
 	 	 	pos_mz[FILENAME,FNR]=$col_mz
 	 	 	pos_in[FILENAME,FNR]=$col_intensity
 	 	 	}
 	 	else
 	 	 	{
 	 	 	neg_mz[FILENAME,FNR]=$col_mz
 	 	 	neg_in[FILENAME,FNR]=$col_intensity
 	 	 	}
 	 	}
 	}
 	END{
 	 	for(i in neg_mz)
 	 	 	{
 	 	 	for(j in pos_mz)
 	 	 	 	{
 	 	 	 	if(neg_mz[i]>=pos_mz[j]-"'$mz_tolerance'" && neg_mz[i]<=pos_mz[j]+"'$mz_tolerance'")
 	 	 	 	 	{
 	 	 	 	 	if((-1)*neg_in[i]>=pos_in[j]-"'$in_tolerance'" && (-1)*neg_in[i]<=pos_in[j]+"'$in_tolerance'")
 	 	 	 	 	 	{
 	 	 	 	 	 	match_p[i]+=1
 	 	 	 	 	 	match_p[j]+=1
 	 	 	 	 	 	}
 	 	 	 	 	}
 	 	 	 	}
 	 	 	}
 	 	delete neg_mz
 	 	delete pos_mz
 	 	printf "mz\t"  "rel.intensity\t"  "match\t"  "formula\t"  "ionization\n" > "'$savepath'" p_id ".tsv"
 	 	for(i=2; i<=max_FNR[p_file]; i++)
 	 	 	{
 	 	 	if(match_p[p_file,i]=="")
 	 	 	 	{
 	 	 	 	match_p[p_file,i]=0
 	 	 	 	}
 	 	 	printf mz[p_file,i]"\t" intensity[p_file,i]"\t" match_p[p_file,i]"\t" formula[p_file,i]"\t" ion[p_file,i]"\n" \
 	 	 	\
 	 	 	>> "'$savepath'" p_id ".tsv"
 	 	 	}
 	 	}' $data
```

```{r eval = F, echo = T}
###########################
```

```{r eval = F, echo = T}
########Supplementary label and annonate
mkdir results/ms2_figures_label
data1="results/re_neg_RT.tsv"
data2="results/fingerid_first_score.tsv"
data3="results/ms2_figures_match/*.tsv"
savepath="results/ms2_figures_label/"
distance="10"
plus="5"
awk -F $'\t' '
 	BEGIN{
 	 	srand()
 	 	}
 	{
 	if(FILENAME~/re_neg_RT/)
 	 	{
 	 	if(FNR==1)
 	 	 	{
 	 	 	for(i=1; i<=NF; i++)
 	 	 	 	{
 	 	 	 	if($i~/ID/)
 	 	 	 	 	{
 	 	 	 	 	col_id=i
 	 	 	 	 	}
 	 	 	 	if($i~/retention/)
 	 	 	 	 	{
 	 	 	 	 	col_rt=i
 	 	 	 	 	}
 	 	 	 	if($i~/m\/z/)
 	 	 	 	 	{
 	 	 	 	 	col_mz=i
 	 	 	 	 	}
 	 	 	 	}
 	 	 	p_file=FILENAME
 	 	 	}
 	 	if(FNR>=2)
 	 	 	{
 	 	 	precursor[$col_id]=$col_mz
 	 	 	rt[$col_id]=$col_rt
 	 	 	}
 	 	}
 	if(FILENAME~/fingerid/)
 	 	{
 	 	if(FNR==1)
 	 	 	{
 	 	 	for(i=1; i<=NF; i++)
 	 	 	 	{
 	 	 	 	if($i~/^id/)
 	 	 	 	 	{
 	 	 	 	 	col_id=i
 	 	 	 	 	}
 	 	 	 	if($i~/similarity/)
 	 	 	 	 	{
 	 	 	 	 	col_similarity=i
 	 	 	 	 	}
 	 	 	 	}
 	 	 	p_file=FILENAME
 	 	 	}
 	 	if(FNR>=2)
 	 	 	{
 	 	 	similarity[$col_id]=$col_similarity
 	 	 	}
 	 	}
 	if(FILENAME~/ms2_figures/)
 	 	{
	 	if(FNR==1)
	 	 	{
	 	 	close(p_file)
	 	 	file_num+=1
	 	 	p_file=FILENAME
	 	 	n=split(FILENAME,a,"[/]")
	 	 	split(a[n],b,"[.]")
	 	 	id=b[1]
	 	 	printf $0"\t"  "y_label\t" "precursor m/z\t" "RT (min)\t" "similarity\n" \
	 	 	\
	 	 	> "'$savepath'"a[n]
	 	 	if(file_num==1)
	 	 	 	{
	 	 	 	for(i=1; i<=NF; i++)
	 	 	 	 	{
	 	 	 	 	if($i~/mz/)
	 	 	 	 	 	{
	 	 	 	 	 	col_mz=i
	 	 	 	 	 	}
	 	 	 	 	if($i~/intensity/)
	 	 	 	 	 	{
	 	 	 	 	 	col_intensity=i
	 	 	 	 	 	}
	 	 	 	 	}
	 	 	 	}
	 	 	}
	 	if(FNR>=2)
	 	 	{
	 	 	printf $0"\t" >> "'$savepath'"a[n]
	 	 	mz[FNR]=$col_mz
	 	 	intensity[FNR]=$col_intensity
	 	 	if(intensity[FNR]>0)
	 	 	 	{
	 	 	 	y_label[FNR]=intensity[FNR]+"'$distance'"
	 	 	 	}
	 	 	else
	 	 	 	{
	 	 	 	y_label[FNR]=intensity[FNR]-"'$distance'"
	 	 	 	}
	 	 	for(i=2; i>=1; i--)
	 	 	 	{
	 	 	 	if(mz[FNR-i]!="")
	 	 	 	 	{
	 	 	 	 	distance=((mz[FNR]-mz[FNR-i])^2+(intensity[FNR]-intensity[FNR-i])^2)^(1/2)
	 	 	 	 	if(distance<"'$distance'"*(1/(2*i)))
	 	 	 	 	 	{
	 	 	 	 	 	if(y_label[FNR]>0)
	 	 	 	 	 	 	{
	 	 	 	 	 	 	# y_label[FNR]+=("'$plus'"+int(16*rand()+16*rand()))
	 	 	 	 	 	 	y_label[FNR]=0
	 	 	 	 	 	 	}
	 	 	 	 	 	else
	 	 	 	 	 	 	{
	 	 	 	 	 	 	# y_label[FNR]-=("'$plus'"+int(16*rand()+16*rand()))
	 	 	 	 	 	 	y_label[FNR]=0
	 	 	 	 	 	 	}
	 	 	 	 	 	}
	 	 	 	 	}
	 	 	 	}
	 	 	printf y_label[FNR] >> "'$savepath'"a[n]
	 	 	if(FNR==2)
	 	 	 	{
	 	 	 	printf "\t"sprintf("%.4f",precursor[id])"\t"  sprintf("%.2f",rt[id])"\t" sprintf("%.2f",similarity[id]) \
	 	 	 	\
	 	 	 	>> "'$savepath'"a[n]
	 	 	 	}
	 	 	printf "\n" >> "'$savepath'"a[n]
	 	 	}
 	 	}
 	}' $data1 $data2 $data3
#plot the map ms2_figures
```

```{r eval = F, echo = T}
###########################
```

```{r eval = F, echo = T}
###########################
```

```{r eval = F, echo = T}
###########################
###table_for_R_paint
	if [ -f results/select_canopus_filter_step3.tsv ]
	then 
	cp results/select_canopus_filter_step3.tsv r_network/temp/select
	elif [ -f results/select_canopus_filter_step2.tsv ]
	then 
	cp results/select_canopus_filter_step2.tsv r_network/temp/select
	else 
	cp results/select_canopus_filter_step1.tsv r_network/temp/select
	fi;
mkdir r_network/nodes_figures
data="r_network/temp/select"
awk -F $'\t' -v OFS=$'\t' '
	{
	if(NR==1)
	 	{
	 	for(i=2; i<=NF; i++)
	 	 	{
	 	 	class[i]=$i
	 	 	}
	 	}
	if(NR>=2)
	 	{
	 	id[NR]=$1;
	 	\
	 	N=NR-1;
	 	\
	 	printf "class\tgroup\tposterior_probability\n" > "r_network/nodes_figures/class_"$1".tsv"
	 	\
	 	for(i=2; i<=NF; i++)
	 	 	{
	 	 	if(i!=NF)
	 	 	 	{
	 	 	 	printf class[i]"\tNA\t"$i"\n" >> "r_network/nodes_figures/class_"$1".tsv"
	 	 	 	}
	 	 	else
	 	 	 	{
	 	 	 	printf class[i]"\tNA\t"$i >> "r_network/nodes_figures/class_"$1".tsv"
	 	 	 	\
	 	 	 	if(NR>=3)
 	 	 	 	 	{
 	 	 	 	 	close("r_network/nodes_figures/class_"id[N]".tsv")
 	 	 	 	 	}
	 	 	 	}
	 	 	}
	 	}
 	}' $data
```

```{r eval = F, echo = T}
###########################
```

```{r eval = F, echo = T}
###########################
```

```{r eval = F, echo = T}
##########################
```

```{r eval = F, echo = T}
######features area to file.
mzmine="r_network/mzmine_table.tsv"
awk -F $'\t' '
 	{
 	if(NR==1)
 	 	{
 	 	for(i=1;i<=NF;i++)
 	 	 	{
 	 	 	sample[i]=$i
 	 	 	}
 	 	}
 	if(NR>=2)
 	 	{
 	 	id[NR]=$1;
 	 	\
 	 	printf "number\tsample\tarea\tlog10_area\n" > "r_network/nodes_figures/area_"$1".tsv"
 	 	\
 	 	N=NR-1
 	 	\
 	 	for(i=4;i<=NF;i++)
 	 	 	{
 	 	 	n=i-3;
 	 	 	if($i!=0)
 	 	 	 	{
 	 	 	 	norm=sprintf("%.2f",log($i)/log(10))
 	 	 	 	}
 	 	 	else
 	 	 	 	{
 	 	 	 	norm=0
 	 	 	 	};
 	 	 	if(i!=NF)
 	 	 	 	{
 	 	 	 	printf n"\t"sample[i]"\t"$i"\t"norm"\n" >> "r_network/nodes_figures/area_"$1".tsv"
 	 	 	 	}
 	 	 	else
 	 	 	 	{
 	 	 	 	printf n"\t"sample[i]"\t"$i"\t"norm >> "r_network/nodes_figures/area_"$1".tsv"
 	 	 	 	if(NR>=3)
 	 	 	 	 	{
 	 	 	 	 	close("r_network/nodes_figures/area_"id[N]".tsv")
 	 	 	 	 	}
 	 	 	 	}
 	 	 	}
 	 	}
 	}' $mzmine
```

```{r eval = F, echo = T}
#########################
```

```{r eval = F, echo = T}
#########################
pr=$(awk -F $'\t' -v OFS=$'\t' '
 	{
 	if(NR>=2)
 	 	{
 	 	class="r_network/nodes_figures/class_"$1".tsv"
 	 	\
 	 	area="r_network/nodes_figures/area_"$1".tsv"
 	 	\
 	 	if(system("test -f " class))
 	 	 	{
 	 	 	c=0
 	 	 	}
 	 	else
 	 	 	{
 	 	 	c=1
 	 	 	}
 	 	if(system("test -f " area))
 	 	 	{
 	 	 	a=0
 	 	 	}
 	 	else
 	 	 	{
 	 	 	a=1
 	 	 	}
 	 	printf $1  "_"  c  "_"  a  "@"
 	 	}
 	}' $mzmine)
```

```{r eval = F, echo = T}
####R nodes image class;area
script=$(echo '
	setwd("r_network/nodes_figures")
	args<-commandArgs(TRUE)
	#####################
 	if ( "tidyverse" %in% rownames(installed.packages())==FALSE)
 	{
	install.packages("tidyverse")
	}
	library(tidyverse)
	library(grid)
	n=args[1]
	seq <- as.character(unlist(strsplit(n, split="@")))
        #############
	for(sum in seq)
	 	{
	 	sp=as.character(unlist(strsplit(sum, split="_")))
	 	id=sp[1]
	 	checkfile=sp[2]
	 	checkfile2=sp[3]
	 	file=paste0("class_",id,".tsv")
	 	file2=paste0("area_",id,".tsv")
	 	savename=paste0(id,".svg")
	 	##########
	 	if(checkfile==1)
	 	 	{
	 	 	data <- read.csv(file=file,header=T,sep="\t")
	 	 	data <- data %>% gather(key = "observation", value="value", -c(1,2)) 
	 	 	nObsType <- nlevels(as.factor(data$observation))
	 	 	data <- data %>% arrange(group, class)
	 	 	data$id <- rep( seq(1, nrow(data)/nObsType), each=nObsType)
	 	 	label_data <- data %>% group_by(id, class) %>% summarize(tot=sum(value))
	 	 	number_of_bar <- nrow(label_data)
	 	 	angle <- 90 - 360 * (label_data$id-0.5) /number_of_bar
	 	 	label_data$hjust <- ifelse( angle < -90, 1, 0)
	 	 	label_data$angle <- ifelse(angle < -90, angle+180, angle)
	 	 	p <- 
	 	 	 ggplot(data) +
	  	 	 geom_bar(aes(x=as.factor(id), y=value, fill=observation), 
	  	 	          stat="identity", alpha=0.5
	  	 	          ) +
	  	 	 scale_fill_brewer(palette = "Paired") +
	  	 	 ylim(-1,1) +
	  	 	 theme_minimal() +
	  	 	 theme(
	    	 	       axis.text = element_blank(),
	    	 	       axis.title.y = element_blank(),
	    	 	       panel.grid = element_blank(),
	    	 	       legend.position = "none",
	  	 	      ) +
	  	 	labs(x = "", y = "")+
	  	 	guides(fill=guide_legend(title=NULL)) +
	  	 	coord_polar() +
	  	 	geom_text(data=label_data, aes(x=id, y=0, label=class, hjust=hjust),
	  	 	          color="black", alpha=0.6, fontface="bold", size=1, angle= label_data$angle, 
	  	 	          inherit.aes = FALSE )
	 	 	}
	 	if(checkfile2==1)
	 	 	{
	 	 	data <- read.csv(file=file2,header=T,sep="\t")
	 	 	num <- nrow(data)
	 	 	max <- 10
	 	 	l <- ggplot(data, aes(x = number+2*num, y = log10_area, fill = sample)) + 
	  	 	     geom_bar(stat = "identity", position=position_dodge(0.7), width = 0.5, alpha=0.5) +
	  	 	              scale_fill_brewer(palette = "Paired") +
  	   	 	     theme_minimal() +
	   	 	     theme(
	    	 	           axis.text = element_blank(),
	    	 	           axis.title = element_blank(),
	    	 	           panel.grid = element_blank(),
	    	 	           legend.position = "none",
	   	 	          ) +
  	   	 	     geom_text(data=data, aes(x=number+2*num, fontface="bold", y=0, label=sample),
  	   	 	               color="black", size=1, alpha=0.5
  	   	 	               )+
  	   	 	     geom_text(data=data, aes(x=number+2*num, y=max/2, fontface="bold",
  	   	 	               label=log10_area), color="black", size=1, alpha=0.5
  	   	 	               )+
  	   	 	     labs(x = "", y = "")+
  	   	 	     xlim(0,num*3.43) +
  	   	 	     ylim(0,max) +
  	   	 	     guides(fill=guide_legend(title=NULL)) +
  	   	 	     coord_polar(theta = "y")
  	 	 	}
```

```{r eval = F, echo = T}
######################
	 	svg(savename)
	 	grid.newpage()
	 	if(checkfile==1)
	 	 	{
	 	 	print(p)
	 	 	}
	 	vp <- viewport(x = 0.5, y = 0.51, width = 0.72, height = 0.72)
	 	pushViewport(vp)
	 	if(checkfile2==1)
	 	 	{
	 	 	print(l, vp = vp)
	 	 	}
	 	dev.off()
	 	}
	')
```

```{r eval = F, echo = T}
###################### bg = "transparent"
```

```{r eval = F, echo = T}
#################
Rscript <(echo "$script") $pr
```

```{r eval = F, echo = T}
#################
```

```{r eval = F, echo = T}
#################
```

```{r eval = F, echo = T}
#################
###a rough classification define;
data="results/select_canopus_filter_step3.tsv"
awk -F $'\t' -v OFS=$'\t' '{
	if(NR==1)
	 	{
	 	m=NR+1;
	 	max[m]=0;
	 	for(i=2; i<=NF; i++)
	 	 	{
	 	 	group[i]=$i;
	 	 	}
	 	}
	if(NR>=2)
	 	{
	 	id[NR]=$1;
	 	for(j=2; j<=NF; j++)
	 	 	{
	 	 	if(max[NR]<$j)
	 	 	 	{
	 	 	 	max[NR]=$j;
	 	 	 	class_d[NR]=group[j];
	 	 	 	}
	 	 	}
	 	m=NR+1;
	 	max[m]=0;
	 	}
	}
	END{
	for(a=1;a<=NR;a++)
	 	{
	 	if(a==1)
	 	 	{
	 	 	print "id","class","pp"
	 	 	};
	 	if(a>=2)
	 	 	{
	 	 	print id[a],class_d[a],max[a]
	 	 	}
	 	}
	}' $data > test.tsv
```

```{r eval = F, echo = T}
###############
```

```{r eval = F, echo = T}
###############
```

```{r eval = F, echo = T}
###############
climit="0.95"
numlimit="0.2"
mzmine="r_network/mzmine_table.tsv"
data1=results/canopus_pp_filter.tsv
data2=$(echo "$mzmine")
compar1="Raw"
compar2="Pro"
log=10
log_to=2
stat=$(awk -F $'\t' -v OFS=$'\t' '
 	{
 	if(NR==1)
 	 	{
 	 	for(i=2; i<=NF; i++)
 	 	 	{
 	 	 	class[i]=$i
 	 	 	num[i]=0
 	 	 	}
 	 	}
 	if(NR>=2)
 	 	{
 	 	for(i=2; i<=NF; i++)
 	 	 	{
 	 	 	if($i>='$climit')
 	 	 	 	{
 	 	 	 	num[i]+=1;
 	 	 	 	id[i,NR]=$1;
 	 	 	 	}
 	 	 	}
 	 	}
 	}
 	END{
 	for(i=2; i<=NF; i++)
 	 	{
 	 	p=num[i]/(NR-1)
 	 	\
 	 	if(p<='$numlimit') #
 	 	 	{
 	 	 	printf class[i]"\t"  num[i]"\t"
 	 	 	\
 	 	 	for(j=2; j<=NR; j++)
 	 	 	 	{
 	 	 	 	if(id[i,j]!="")
 	 	 	 	 	{
 	 	 	 	 	printf id[i,j]"@";
 	 	 	 	 	}
 	 	 	 	}
 	 	 	printf "\n"
 	 	 	}
 	 	}
 	}' $data1 | sed 's/@$//g')
forboxplot=$(awk -F ["\t"@] -v OFS=$'\t' '
 	BEGIN{
 	 	maxNF=0
 	 	rows=0
 	 	compar1n=0
 	 	compar2n=0
 	 	}
 	{
 	if(NR==FNR)
 	 	{
 	 	rows+=1
 	 	if(maxNF<NF)
 	 	 	{
 	 	 	maxNF=NF
 	 	 	}
 	 	class[FNR]=$1
 	 	\
 	 	num[FNR]=$2
 	 	\
 	 	for(j=3; j<=NF; j++)
 	 	 	{
 	 	 	id[FNR,j]=$j
 	 	 	}
 	 	}
 	else
 	 	{
 	 	if(FNR==1)
 	 	 	{
 	 	 	for(i=1; i<=NF; i++)
 	 	 	 	{
 	 	 	 	if(($i~/'$compar1'/))
 	 	 	 	 	{
 	 	 	 	 	colum1[i]=i
 	 	 	 	 	compar1n+=1
 	 	 	 	 	}
 	 	 	 	if(($i~/'$compar2'/))
 	 	 	 	 	{
 	 	 	 	 	colum2[i]=i
 	 	 	 	 	compar2n+=1
 	 	 	 	 	}
 	 	 	 	if(($i~/retention/))
 	 	 	 	 	{
 	 	 	 	 	rtcolum=i
 	 	 	 	 	}
 	 	 	 	if(($i~/m\/z/))
 	 	 	 	 	{
 	 	 	 	 	mzcolum=i
 	 	 	 	 	}
 	 	 	 	}
 	 	 	}
 	 	if(FNR>=2)
 	 	 	{
 	 	 	sum[1,$1]=0
 	 	 	\
 	 	 	sum[2,$1]=0
 	 	 	\
 	 	 	rt[$1]=$rtcolum
 	 	 	\
 	 	 	mz[$1]=$mzcolum
 	 	 	\
 	 	 	for(i=1; i<=NF; i++)
 	 	 	 	{
 	 	 	 	if(i==colum1[i] && colum1[i]!="")
 	 	 	 	 	{
 	 	 	 	 	sum[1,$1]+=$i
 	 	 	 	 	}
 	 	 	 	if(i==colum2[i] && colum2[i]!="")
 	 	 	 	 	{
 	 	 	 	 	sum[2,$1]+=$i
 	 	 	 	 	}
 	 	 	 	}
 	 	 	}
 	 	}
 	}
 	END{
 	 	printf "class\t"  "id\t"  "log'$log'_delta_area\t"  "pro_to_raw\t"  "log'$log_to'_pro_to_raw\t"  "variety\t"  "number\t";
 	 	\
 	 	printf "rt\t"  "m/z\n"
 	 	\
 	 	for(i=1; i<=rows; i++)
 	 	 	{
 	 	 	for(j=3; j<=maxNF; j++)
 	 	 	 	{
 	 	 	 	if(id[i,j]!="")
 	 	 	 	 	{
 	 	 	 	 	raw=(sum[1,id[i,j]]/compar1n)
 	 	 	 	 	\
 	 	 	 	 	pro=(sum[2,id[i,j]]/compar2n)
 	 	 	 	 	\
 	 	 	 	 	delta_area=pro-raw
 	 	 	 	 	\
 	 	 	 	 	to_raw=pro/raw
 	 	 	 	 	\
 	 	 	 	 	norm_to_raw=log(to_raw)/log('$log_to')
 	 	 	 	 	\
 	 	 	 	 	if(delta_area>0)
 	 	 	 	 	 	{
 	 	 	 	 	 	norm_delta=log(delta_area)/log('$log')
 	 	 	 	 	 	\
 	 	 	 	 	 	variety="increase"
 	 	 	 	 	 	}
 	 	 	 	 	else if(delta_area<0)
 	 	 	 	 	 	{
 	 	 	 	 	 	norm_delta=-1*(log(-1*delta_area)/log('$log'))
 	 	 	 	 	 	\
 	 	 	 	 	 	variety="decrease"
 	 	 	 	 	 	}
 	 	 	 	 	else
 	 	 	 	 	 	{
 	 	 	 	 	 	norm_delta=0
 	 	 	 	 	 	}
 	 	 	 	 	printf class[i]"\t"  id[i,j]"\t"  norm_delta"\t"  to_raw"\t"  norm_to_raw"\t"  variety"\t"  num[i]"\t" \
 	 	 	 	 	\
 	 	 	 	 	rt[id[i,j]]"\t"  mz[id[i,j]]"\n"
 	 	 	 	 	}
 	 	 	 	}
 	 	 	}
 	 	}' <(echo "$stat") $(echo "$data2"))
echo "$forboxplot" > boxplot.tsv
#Rscript	boxplot
Rscript=$(echo '
library(ggplot2)
source<-read.table(file="boxplot.tsv",header=T,sep="\t")
boxplot<-ggplot(source,aes(x=class,y=log2_pro_to_raw,fill=class))+
  stat_boxplot(geom="errorbar",width=0.3)+
  geom_boxplot()+
  geom_dotplot(binaxis ="y",
               stackdir="center",
               position="jitter",
               stackratio=0.2,
               dotsize = 0.25)+
  theme_minimal() +
  theme(
       legend.position="none",
       axis.text.x = element_blank(),
       text = element_text(size=30),
       )+
  geom_text(data=source, aes(x=class, y=-4, label=class),
	    color="black", fontface="bold", size=5, angle= 90, 
	    inherit.aes = FALSE )+
  geom_text(data=source, aes(x=class, y=5, label=number),
	    color="black", fontface="bold", size=5, 
	    inherit.aes = FALSE ) + 
  stat_summary(fun="mean",geom="point",shape=23,size=2.5,fill="grey")
pdf("boxplot.pdf",width=25,height=15)
boxplot
dev.off()
')
```

```{r eval = F, echo = T}
##############
lignans_iridoids=$(awk -F $'\t' -v OFS=$'\t' '
 	{
 	if(NR==1)
 	 	{
 	 	print "id","rt","m/z","classification","variety","pro/raw"
 	 	}
 	if(($1~/lignan/) || ($1~/ridoid/))
 	 	{
 	 	print $2,$8,$9,$1,$6,$4
 	 	}
  	}' <(echo "$forboxplot")
)
data=results/fingerid_first_score.tsv
list=lignans_and_iridoids.tsv
com=$(awk -F $'\t' '
 	BEGIN{
 	 	rows=0
 	 	}	
 	{
 	if(NR==FNR)
 	 	{
 	 	if(FNR>=2)
 	 	 	{
 	 	 	rows+=1
 	 	 	\
 	 	 	id[FNR]=$13;
 	 	 	\
 	 	 	simi[FNR]=$11
 	 	 	\
 	 	 	name[FNR]=$6
 	 	 	\
 	 	 	formula[FNR]=$3
 	 	 	\
 	 	 	smiles[FNR]=$7
 	 	 	\
 	 	 	pubchem[FNR]=$10
 	 	 	}
 	 	}
 	if(NR!=FNR)
 	 	{
 	 	if(FNR==1)
 	 	 	{
 	 	 	for(i=1; i<=NF; i++)
 	 	 	 	{
 	 	 	 	printf $i"\t"
 	 	 	 	}
 	 	 	printf "similarity\t"  "Name\t"  "Formula\t"  "Smiles\n";
 	 	 	}
 	 	if(FNR>=2)
 	 	 	{
 	 	 	for(i=1; i<=NF; i++)
 	 	 	 	{
 	 	 	 	printf $i"\t"
 	 	 	 	}
 	 	 	for(j=2;j<=rows;j++)
 	 	 	 	{
 	 	 	 	if(id[j]==$1)
 	 	 	 	 	{
 	 	 	 	 	printf simi[j]"\t"  name[j]"\t"  formula[j]"\t"  smiles[j]"\n";
 	 	 	 	 	}
 	 	 	 	}
 	 	 	}
 	 	}
 	}' $data $list)
 echo "$com" > com_lignans_and_iridoids.tsv
```

# File: random.sh

```{r eval = F, echo = T}
awk 'BEGIN{srand();print int(10*rand())"\t"int(10*rand())}'
```

# File: search_cid.sh

```{r eval = F, echo = T}

filename=$(cat list | awk '{name="/media/wizard/back/0703_all/*_"$0"/fingerid/*.tsv"; printf name" "}')

grep "445858" $filename
```

# File: someone_analyses.sh

```{r eval = F, echo = T}
mzmine_path="0630neg.csv"

savepath="fecal_pos_mzmine.tsv"

awk -F , '
 	{
 	if(NR==1)
 	 	{
 	 	for(i=4; i<=NF; i++)
 	 	 	{
 	 	 	col_sample[$i]=i
 	 	 	}
 	 	l=asorti(col_sample,b)
 	 	\
 	 	printf $1 "\t" $2 "\t" $3 "\t" > "'$savepath'"
 	 	\
 	 	for(i=1; i<l; i++)
 	 	 	{
 	 	 	printf b[i] "\t" >> "'$savepath'"
 	 	 	}
 	 	printf b[l] "\n" >> "'$savepath'"
 	 	}
 	if(NR>=2)
 	 	{
 	 	printf $1"\t" $2"\t" $3 "\t" >> "'$savepath'"
 	 	\
 	 	for(i=1; i<l; i++)
 	 	 	{
 	 	 	printf $col_sample[b[i]] "\t" >> "'$savepath'"
 	 	 	}
 	 	printf $col_sample[b[l]] "\n" >> "'$savepath'"
 	 	}
 	}' $mzmine_path
 	
 ####
 
 data="fecal_pos_mzmine.tsv"

savepath="fecal_pos_area.tsv"

awk -F $'\t' '
 	{
 	if(FNR==1)
 	 	{
 	 	for(i=1; i<=NF; i++)
 	 	 	{
 	 	 	if($i~/ID/)
 	 	 	 	{
 	 	 	 	col_id=i
 	 	 	 	}
 	 	 	if($i~/retention/)
 	 	 	 	{
 	 	 	 	col_rt=i
 	 	 	 	}
 	 	 	if($i~/m\/z/)
 	 	 	 	{
 	 	 	 	col_mz=i
 	 	 	 	}
 	 	 	if($i~/area/)
 	 	 	 	{
 	 	 	 	split($i,a,"[ ]")
 	 	 	 	
 	 	 	 	num+=1
 	 	 	 	
 	 	 	 	max_num=num
 	 	 	 	
 	 	 	 	col_area[num]=i
 	 	 	 	
 	 	 	 	col_name[num]=a[1]
 	 	 	 	}
 	 	 	}
 	 	}
 	if(FNR>=2)
 	 	{
 	 	n+=1
 	 	
 	 	id_seq[n]=$col_id
 	 	
 	 	rt[$col_id]=$col_rt
 	 	
 	 	mz[$col_mz]=$col_mz
 	 	
 	 	for(i=1; i<=max_num; i++)
 	 	 	{
 	 	 	area[$col_id,i]=$col_area[i]
 	 	 	}
 	 	}
 	}
 	END{
 	 	printf "sample" > "'$savepath'"
 	 	
 	 	for(i=1; i<=n; i++)
 	 	 	{
 	 	 	printf "\t"id_seq[i] >> "'$savepath'"
 	 	 	}
 	 	printf "\n" >> "'$savepath'"
 	 	
 	 	for(i=1; i<=max_num; i++)
 	 	 	{
 	 	 	printf col_name[i] >> "'$savepath'"
 	 	 	
 	 	 	for(j=1; j<=n; j++)
 	 	 	 	{
 	 	 	 	printf "\t"area[id_seq[j],i] >> "'$savepath'"
 	 	 	 	}
 	 	 	printf "\n" >> "'$savepath'"
 	 	 	}
 	 	}' $data	
 
 #######
 	
data1="fecal_pos_area.tsv"

data2="metadata.tsv"

savepath="re_metadata.tsv"

awk -F $'\t' '
 	{
 	if(NR==FNR && FNR>=2)
 	 	{
 	 	sort_sample[FNR]=$1
 	 	}
 	if(NR>FNR && FNR==1)
 	 	{
 	 	printf $0"\n" > "'$savepath'"
 	 	}
 	if(NR>FNR && FNR>=2)
 	 	{
 	 	split($1,a,"[ ]")
 	 	
 	 	name=a[1]
 	 	
 	 	data[name]=name"\t"$2"\t"$3
 	 	}
 	}
 	END{
 	 	for(i=2; i<=FNR; i++)
 	 	 	{
 	 	 	printf data[sort_sample[i]]"\n" >> "'$savepath'"
 	 	 	}
 	 	}' $data1 $data2

mv $savepath "metadata.tsv"	

```

```{r eval = F, echo = T}
######

mkdir re_pca_plsda

 	 	
 	 	compare1="pro"
 	 	
 	 	compare2="raw"
 	 	
	 	data1="fecal_pos_area.tsv"

	 	data2="metadata.tsv"
	 	
	 	savepath1="re_pca_plsda/${compare1}_${compare2}_pca.tsv"

	 	savepath2="re_pca_plsda/metadata_${compare1}_${compare2}.tsv"
	 	
	 	awk -F $'\t' '
	 	 	{
	 	 	if(FNR==1)
	 	 	 	{
	 	 	 	if(FILENAME=="'$data1'")
	 	 	 	 	{
	 	 	 	 	print $0 > "'$savepath1'"
	 	 	 	 	}
	 	 	 	else
	 	 	 	 	{
	 	 	 	 	print $0 > "'$savepath2'"
	 	 	 	 	}
	 	 	 	}
	 	 	if(FNR>=2)
	 	 	 	{
	 	 	 	if($1~/^'$compare1'/)
	 	 	 	 	{
	 	 	 	 	if(FILENAME=="'$data1'")
	 	 	 	 	 	{
	 	 	 	 	 	print $0 >> "'$savepath1'"
	 	 	 	 	 	}
	 	 	 	 	else
	  	 	 	 	 	{
	 	 	 	 	 	print $0 >> "'$savepath2'"
	 	 	 	 	 	}
	 	 	 	 	}
	 	 	 	if($1~/^'$compare2'/)
	 	 	 	 	{
	 	 	 	 	if(FILENAME=="'$data1'")
	 	 	 	 	 	{
	 	 	 	 	 	print $0 >> "'$savepath1'"
	 	 	 	 	 	}
	 	 	 	 	else
	  	 	 	 	 	{
	 	 	 	 	 	print $0 >> "'$savepath2'"
	 	 	 	 	 	}
	 	 	 	 	}
	 	 	 	}
	 	 	}' $data1 $data2
	 	 	
```

```{r eval = F, echo = T}
################
```

```{r eval = F, echo = T}
################	 	 	
	 	 		 	
data1="fecal_pos_area.tsv"

data2="metadata.tsv"

compare1="blank"

compare2="std"

compare3="raw"

compare4="pro"

#data1="fecal_pos_area.tsv"

#data2="metadata.tsv"

savepath1="re_pca_plsda/multi_pca.tsv"

savepath2="re_pca_plsda/metadata_multi.tsv"

awk -F $'\t' '
 	{
 	if(FNR==1)
 	 	{
 	 	if(FILENAME=="'$data1'")
 	 	 	{
 	 	 	print $0 > "'$savepath1'"
 	 	 	}
 	 	else
 	 	 	{
 	 	 	print $0 > "'$savepath2'"
 	 	 	}
 	 	}
 	if(FNR>=2)
 	 	{
 	 	if($1~/^'$compare1'/)
 	 	 	{
 	 	 	if(FILENAME=="'$data1'")
 	 	 	 	{
 	 	 	 	print $0 >> "'$savepath1'"
 	 	 	 	}
 	 	 	else
 	 	 	 	{
 	 	 	 	print $0 >> "'$savepath2'"
 	 	 	 	}
 	 	 	}
 	 	if($1~/^'$compare2'/)
 	 	 	{
 	 	 	if(FILENAME=="'$data1'")
 	 	 	 	{
 	 	 	 	print $0 >> "'$savepath1'"
 	 	 	 	}
 	 	 	else
 	 	 	 	{
 	 	 	 	print $0 >> "'$savepath2'"
 	 	 	 	}
 	 	 	}
 	 	if($1~/^'$compare3'/)
 	 	 	{
 	 	 	if(FILENAME=="'$data1'")
 	 	 	 	{
 	 	 	 	print $0 >> "'$savepath1'"
 	 	 	 	}
 	 	 	else
 	 	 	 	{
 	 	 	 	print $0 >> "'$savepath2'"
 	 	 	 	}
 	 	 	}
 	 	if($1~/^'$compare4'/)
 	 	 	{
 	 	 	if(FILENAME=="'$data1'")
 	 	 	 	{
 	 	 	 	print $0 >> "'$savepath1'"
 	 	 	 	}
 	 	 	else
 	 	 	 	{
 	 	 	 	print $0 >> "'$savepath2'"
 	 	 	 	}
 	 	 	}
 	 	}
 	}' $data1 $data2
 	

wd="re_pca_plsda"

Rscript pca_ggbiplot.R $wd


wd="re_pca_plsda"

Rscript pca_prcomp.R $wd

mkdir re_pca_plsda/opls_da

data="re_pca_plsda/*.tsv"

savepath="re_pca_plsda/opls_da/"

awk -F $'\t' '
 	{
 	if(FNR==1)
 	 	{
 	 	n=split(FILENAME,a,"[/]")
 	 	
 	 	file=a[n]
 	 	}
 	if(file~/multi/)
 	 	{
 	 	nextfile;
 	 	}
 	if(file~/pca.tsv/ || file~/metadata/)
 	 	{
 	 	if(FNR==1)
 	 	 	{
 	 	 	printf $0"\n" > "'$savepath'"file
 	 	 	}
 	 	if(FNR>=2)
 	 	 	{
 	 	 	printf $0"\n" >> "'$savepath'"file
 	 	 	}
 	 	}
 	}' $data
 	
 #########
 	
 wd="re_pca_plsda/opls_da"

 Rscript ~/Downloads/opls_da.R $wd	
 
 
 
 
 
 

```

# File: temp.sh

```{r eval = F, echo = T}
# location="~/operation/re_fecal_neg/kegg"”
cd ~/operation/re_fecal_neg/kegg
savepath="cnumber_cid.tsv"
awk -F "[:][ ]" '
{
  if(FNR==1)
    {
      printf "kegg number\t" "pubchem id" > "'$savepath'"
    }
  if($0~/BEGIN_COMPOUND/)
    {
      getline
      if($0~/C[0-9]*/)
        {
          cnum=$0
          next_sub=1
          print "Catch C number: ", $0
          printf "\n"cnum > "'$savepath'"
        }
    else
      {
        next_sub=0
        print "Invalid sublist."
      }
    }
  if($1~/PubChem/ && next_sub==1)
    {
      printf "\t"$2 > "'$savepath'"
    }
}' dblink.list 
## filter the blank and output the list
data="cnumber_cid.tsv"
nlimit=100
list=$(awk -F $'\t' '
{
  if($1~/C[0-9]*/)
    {
      if($2=="")
        {
          print "Escape CID of",$1
        }
      if($2!="")
        {
          gsub(/ /,"",$2)
          if(n>'$nlimit')
            {
              n=0
              print cid_set
            }
          n+=1
          if(n==1)
            {
              cid_set=$2
            }
        else
          {
            cid_set=cid_set","$2
          }
      }
  }
}
END{
print cid_set
}' $data)
## nrow
nrow=$(awk 'END{print NR}' <(echo "$list"))
##
for i in $(seq $nrow)
do
  cids=$(awk '{if(NR=='$i'){print $0}}' <(echo "$list"))
  check=$(echo "$cids" | awk '{if($0~/^[0-9]/){printf 0}else{printf 1}}')
  while [ $check == 0 ]
  do
    echo "Try catch pubchem API (${i}/${nrow})..."
    if [ -f ${i}_smiles.csv ]
    then
      check=$(awk '
      {
        if(FNR==1)
          {
            if($0~/CID/)
              {
                printf "1"
              }
          else
            {
              printf "0"
            }
        }
    }
  END{
  if(FNR==0)
    {
      printf "0"
    }
}' ${i}_smiles.csv)
    fi;
if [ $check == 0 ]
then
  curl --connect-timeout 20 --retry 100 --retry-delay 30 https://pubchem.ncbi.nlm.nih.gov/rest/pug/compound/cid/${cids}/property/CanonicalSMILES,IsomericSMILES/CSV > ${i}_smiles.csv
fi;
done;
done;

```

# File: test.sh

```{r eval = F, echo = T}
commit bffd9d726387529b2e4c629bfcfd71e5821578e8
Author: yellow-byte <84759258+yellow-byte@users.noreply.github.com>
Date:   Thu Dec 30 21:33:39 2021 +0800

    Delete MCnebula_1.0.sh

diff --git a/MCnebula_1.0.sh b/MCnebula_1.0.sh
deleted file mode 100644
index 63d2074..0000000
--- a/MCnebula_1.0.sh
+++ /dev/null
@@ -1,1306 +0,0 @@
-##########################
-##########################
-echo "We are all in the gutter, 
-but some of us are looking at the stars.";
-PS3='Please select the workflow to be executed. >>> '
-select command in \
-  "default" \
-  "structure_extract" \
-  "classification_extract_sum" \
-  "classification_extract_filter" \
-  "fragment_tree_network" \
-  "fragment_tree_network_delta" \
-  "compound_idenfication" \
-  "double_ion_network" \
-  "exit" 
-do
-  if [[ $command == "default" ]]
-  then
-    confirm=0
-    until [[ $confirm == "yes" ]] || [[ $confirm == "no" ]]
-    do
-      read -p "Running all proccesses sequentially? [yes/no] >>> " confirm
-    done;
-    if [[ $confirm == "no" ]]
-    then exit
-    fi;
-    default="structure_extract classification_extract_sum classification_extract_filter fragment_tree_network fragment_tree_network_delta"
-    list=$(echo $default);
-  else list=$( echo $command)
-  fi;
-  for option in $(echo $list)
-  do
-    case $option in
-      ###################################
-      ###################################
-      ###################################
-      ###################################
-      structure_extract)
-      echo "Run structure_extract."
-      projectpath=0
-      until [ -d $projectpath ] && [ -f $projectpath/canopus_summary.tsv ] && [ -f $projectpath/.format ]
-      do
-        read -p "Please input the path of the sirius project >>> " projectpath;
-      done;
-      cd $projectpath;
-      mkdir results;
-      mkdir temp;
-      mkdir temp/fintemp;
-      if [ -f temp/Mo_filename ]
-      then rm temp/Mo_filename
-      fi;
-      data="*_*/fingerid/*.tsv"
-      awk -F $'\t' '
-      BEGIN{
-      all_id=0
-      max_id=-1
-      p_id="null"
-      printf "Info: loading the data..."
-    }
-  {
-    if(FNR==1)
-      {
-        if(NR>FNR)
-          {
-            close(pfile)
-          }
-        f=split(FILENAME,a,"[/]");
-        n=split(a[1],b,"[_]");
-        id=b[n];
-        if(id!=p_id)
-          {
-            all_id+=1
-            if(id>max_id)
-              {
-                max_id=id
-              }
-          }
-        file[id]=a[1]
-        split(a[f], g, "[.]")
-        formu_type[id]=g[1]
-        if(all_id==1)
-          {
-            for(i=1; i<=NF; i++)
-              {
-                if(($i~/inchikey2D/))
-                  {
-                    col_2D=i
-                  }
-                if($i=="inchi")
-                  {
-                    col_inchi=i
-                  }
-                if(($i~/Formula/))
-                  {
-                    col_formu=i
-                  }
-                if($i=="score")
-                  {
-                    col_score=i
-                  }
-                if($i=="name")
-                  {
-                    col_name=i
-                  }
-                if($i=="smiles")
-                  {
-                    col_smiles=i
-                  }
-                if($i=="xlogp")
-                  {
-                    col_x=i
-                  }
-                if(($i~/imilarity/))
-                  {
-                    col_simi=i
-                  }
-                if($i~/links/)
-                  {
-                    col_links=i
-                  }
-              }
-          }
-        pfile=FILENAME
-        printf g[1]"\t"formu_type[id]"\n"
-        printf "Info: the data of " id " (ID) has input. The filename is " FILENAME ".\n"
-      }
-    if(FNR>=2)
-      {
-        row_score=$col_score
-        row_simi=$col_simi
-        if(max["score",id]=="" || max["score",id]+0<row_score+0)
-          {
-            max["score",id]=row_score
-            name["score",id]=$col_name
-            formula["score",id]=$col_formu
-            formu_type["score",id]=formu_type[id]
-            simi["score",id]=$col_simi
-            smiles["score",id]=$col_smiles
-            inchi["score",id]=$col_inchi
-            in2D["score",id]=$col_2D
-            score["score",id]=$col_score
-            xlogp["score",id]=$col_x
-            links["score",id]=$col_links
-          }
-        if(max["simi",id]=="" || max["simi",id]+0<row_simi+0)
-          {
-            max["simi",id]=row_simi
-            name["simi",id]=$col_name
-            formula["simi",id]=$col_formu
-            formu_type["simi",id]=formu_type[id]
-            simi["simi",id]=$col_simi
-            smiles["simi",id]=$col_smiles
-            inchi["simi",id]=$col_inchi
-            in2D["simi",id]=$col_2D
-            score["simi",id]=$col_score
-            xlogp["simi",id]=$col_x
-            links["simi",id]=$col_links
-          }
-      }
-  }
-END{
-printf "id\t"  "name\t"  "formula\t"  "similarity\t"  "smiles\t"  "inchi\t"  "inchikey2D\t"  "score\t"  "xlogp\t"  "links\n" > "results/fingerid_sum.tsv"
-for(l in file)
-  {
-    if(max["score",l]!="")
-      {
-        printf l"\t"  name["score",l]"\t"  formula["score",l]"\t"  simi["score",l]"\t"  smiles["score",l]"\t"  inchi["score",l]"\t"  in2D["score",l]"\t"  score["score",l]"\t"  xlogp["score",l]"\t"  links["score",l]"\n" >> "results/fingerid_sum.tsv"
-        printf formula["score",l]"\t"  file[l]"\t"  formu_type["score",l]"\n" > "temp/Mo_filename"
-      }
-    if(max["simi",l]!="" && max["simi",l]!=max["score",l])
-      {
-        printf l"\t"  name["simi",l]"\t"  formula["simi",l]"\t"  simi["simi",l]"\t"  smiles["simi",l]"\t"  inchi["simi",l]"\t"  in2D["simi",l]"\t"  score["simi",l]"\t"  xlogp["simi",l]"\t"  links["simi",l]"\n" >> "results/fingerid_sum.tsv"
-      }
-  }
-}' $data
-data_sum="results/fingerid_sum.tsv"
-awk -F $'\t' '
-{
-  if(NR==1)
-    {
-      for(i=1; i<=NF; i++)
-        {
-          if($i~/id/)
-            {
-              col_id=i
-            }
-          if($i~/score/)
-            {
-              col_score=i
-            }
-        }
-    }
-  if(NR>=2)
-    {
-      id=$col_id
-      if(max_id+0<id || max_id=="")
-        {
-          max_id=id
-        }
-      if(score[id]+0<$col_score+0 || score[id]=="")
-        {
-          score[id]=$col_score
-          data[id]=$0
-        }
-    }
-}
-END{
-printf "id\t"  "name\t"  "formula\t"  "similarity\t"  "smiles\t"  "inchi\t"  "inchikey2D\t"  "score\t"  "xlogp\t"  "links\n" > "results/fingerid_first_score.tsv"
-for(i=1; i<=max_id; i++)
-  {
-    if(data[i]!="")
-      {
-        printf data[i] "\n" >> "results/fingerid_first_score.tsv"
-      }
-  }
-}' $data_sum
-echo "structure_extract results have been successfully assembled into <results/fingerid_sum.tsv> and <results/fingerid_first_score.tsv>";
-;;
-###################################
-###################################
-###################################
-###################################
-classification_extract_sum)
-echo "Run classification_extract_sum.";
-if [ -f temp/Mo_filename ] && [ -f canopus.tsv ] && [ -f canopus_neg.tsv ] && [ -f .format ]
-then
-  echo "Project path acknowledged."
-else
-  until [ -d $projectpath ] && [ -f $projectpath/canopus.tsv ] && [ -f $projectpath/.format ]
-  do
-    read -p "Please input the path of the sirius project >>> " projectpath;
-  done;
-  cd $projectpath;
-fi;
-data1="temp/Mo_filename"
-data2="canopus.tsv"
-data3="canopus_neg.tsv"
-datas=$(awk -F $'\t' '
-{
-  x=$2"/canopus/"$3".fpt"
-  if(getline < x == 1)
-    {
-      printf x" "
-    }
-  close(x)
-}' $data1)
-##################
-awk -F $'\t' '
-{
-  if(NR==FNR)
-    {
-      i=split($2,s,"[_]")
-      the_id[FNR]=s[i]
-      n=FNR
-    }
-  if(FILENAME ~ /canopus.tsv/)
-    {
-      if(FNR==1)
-        {
-          for(i=1; i<=NF; i++)
-            {
-              if($i ~ /^name/)
-                {
-                  col_class=i
-                }
-              if($i ~ /absolute/)
-                {
-                  col_abindex=i
-                }
-            }
-        }
-      if(FNR>=2)
-        {
-          abindex[1,FNR]=$col_abindex
-          indexset[$col_abindex]=$col_class
-        }
-    }
-  if(FILENAME ~ /canopus_neg.tsv/)
-    {
-      p_filename=FILENAME
-      if(FNR==1)
-        {
-          for(i=1; i<=NF; i++)
-            {
-              if($i ~ /name/)
-                {
-                  col_class=i
-                }
-              if($i ~ /absolute/)
-                {
-                  col_abindex=i
-                }
-            }
-        }
-      if(FNR>=2)
-        {
-          abindex[2,FNR]=$col_abindex
-          indexset[$col_abindex]=$col_class
-        }
-    }
-  if(FILENAME ~ /.fpt/)
-    {
-      if(FNR==1)
-        {
-          close(p_filename)
-          printf "Info: data_file name of " p_filename " has been input.\n"
-          p_filename=FILENAME
-          split(FILENAME,a,"[/]");
-          m=split(a[1],b,"[_]");
-          id=b[m];
-          if(FILENAME ~ /\+.fpt/)
-            {
-              ion=1
-            }
-          if(FILENAME ~ /\-.fpt/)
-            {
-              ion=2
-            }
-        }
-      pp[id,abindex[ion,FNR+1]]=sprintf("%.3f",$1)
-    }
-}
-END{
-printf "id" > "results/canopus_pp.tsv"
-for(i in indexset)
-  {
-    ord+=1
-    orderlist[ord]=i
-    printf "\t"indexset[i] >> "results/canopus_pp.tsv"
-  }
-printf "\n" >> "results/canopus_pp.tsv"
-for(i=1; i<=n; i++)
-  {
-    printf the_id[i] >> "results/canopus_pp.tsv"
-    for(j=1; j<=ord; j++)
-      {
-        if(pp[the_id[i],orderlist[j]]=="")
-          {
-            pp[the_id[i],orderlist[j]]=0
-          }
-        printf "\t"pp[the_id[i],orderlist[j]] >> "results/canopus_pp.tsv"
-      }
-    printf "\n" >> "results/canopus_pp.tsv"
-  }
-}' $data1 $data2 $data3 $datas
-echo "classiication_extract_sum have been successfully written into <results/canopus_pp.tsv>"
-;;
-###################################
-###################################
-###################################
-classification_extract_filter)
-echo "Run classification_extract_filter.";
-if [ -f results/canopus_pp.tsv ]
-then
-  echo "Project path acknowledged."
-else
-  until [ -d $projectpath ] && [ -f $projectpath/results/canopus_pp.tsv ] && [ -f $projectpath/results/canopus_summary.tsv ]
-  do
-    read -p "Please input the path of the sirius project >>> " projectpath;
-  done;
-  cd $projectpath;
-fi; 
-check=0
-until [[ "$check" == "yes" ]] || [[ "$check" == "no" ]]
-do
-  read -p "Collate the posterior probabilities of the classification of each feature? [yes/no] >>> " check;
-done;
-if [[ $check == "yes" ]]
-then
-  definition_limit=0
-  until [[ "$definition_limit" > "0.01" ]] && [[ "$definition_limit" < "1" ]]
-  do
-    read -p "Please enter the classes posterior probabilities limition. 0.5~0.99 may work well. >>> " definition_limit;
-  done;
-  data1="canopus_summary.tsv"
-  data2="canopus.tsv"
-  data3="results/canopus_pp.tsv"
-  awk -F $'\t' '
-  {
-    if(NR==FNR)
-      {
-        if(FNR==1)
-          {
-            p_file=FILENAME
-            for(i=1; i<=NF; i++)
-              {
-                if($i~/name/)
-                  {
-                    col_id=i
-                  }
-                if($i~/specific/)
-                  {
-                    col_specific=i
-                  }
-                if($i~/level/)
-                  {
-                    col_level=i
-                  }
-                if($i~/subclass/)
-                  {
-                    col_subclass=i
-                  }
-                if($i~/^class/)
-                  {
-                    col_class=i
-                  }
-                if($i~/superclass/)
-                  {
-                    col_superclass=i
-                  }
-              }
-          }
-        if(FNR>=2)
-          {
-            n=split($col_id,a,"[_]")
-            id=a[n]
-            specific[id]=$col_specific
-            level[id]=$col_level
-            subclass[id]=$col_subclass
-            class[id]=$col_class
-            superclass[id]=$col_superclass
-          }
-      }
-    if(FILENAME~/canopus.tsv/)
-      {
-        if(FNR==1)
-          {
-            close(p_file)
-            p_file=FILENAME
-            for(i=1; i<=NF; i++)
-              {
-                if($i~/name/)
-                  {
-                    col_name=i
-                  }
-                if($i~/description/)
-                  {
-                    col_description=i
-                  }
-              }
-          }
-        if(FNR>=2)
-          {
-            description[$col_name]=$col_description
-          }
-      }
-    if(FILENAME~"'$data3'")
-      {
-        if(FNR==1)
-          {
-            close(p_file)
-            for(i=1; i<=NF; i++)
-              {
-                if($i~/^id$/)
-                  {
-                    col_id=i
-                  }
-                if(i>=2)
-                  {
-                    col_class_name[i]=$i
-                  }
-              }
-            printf "id\t"  "definition_source\t"  "definition\t"  "definition_pp\t"  "definition_description\t"  "specific\t"  "specific_pp\t"  "level_5\t"  "level_5_pp\t"  "subclass\t"  "subclass_pp\t"  "class\t"  "class_pp\t"  "superclass\t"  "superclass_pp\n"  > "results/stat_classification.tsv"
-          }
-        if(FNR>=2)
-          {
-            for(i=2; i<=NF; i++)
-              {
-                c_pp[col_class_name[i]]=sprintf("%.4f",$i)
-              }
-            if(level[$col_id] != "" && c_pp[level[$col_id]] >= "'$definition_limit'")
-              {
-                definition_source="level_5"
-                definition=level[$col_id]
-              }
-          else if(subclass[$col_id] != "" && c_pp[subclass[$col_id]] >= "'$definition_limit'")
-            {
-              definition_source="subclass"
-              definition=subclass[$col_id]
-            }
-        else if(class[$col_id] != "" && c_pp[class[$col_id]] >= "'$definition_limit'")
-          {
-            definition_source="class"
-            definition=class[$col_id]
-          }
-      else if(superclass[$col_id] != "" && c_pp[superclass[$col_id]] >= "'$definition_limit'")
-        {
-          definition_source="superclass"
-          definition=superclass[$col_id]
-        }
-    else
-      {
-        definition_source="null"
-        definition="null"
-        c_pp[definition]="null"
-        description[definition]="null"
-      }
-    printf $col_id"\t"  definition_source"\t"  definition"\t"  c_pp[definition]"\t"  description[definition]"\t"  specific[$col_id]"\t"  c_pp[specific[$col_id]]"\t"  level[$col_id]"\t"  c_pp[level[$col_id]]"\t"  subclass[$col_id]"\t"  c_pp[subclass[$col_id]]"\t"  class[$col_id]"\t"  c_pp[class[$col_id]]"\t"  superclass[$col_id]"\t"  c_pp[superclass[$col_id]]"\n" >> "results/stat_classification.tsv"
-  }
-}
-}' $data1 $data2 $data3
-echo "classification_extract_filter have been successfully written into <results/stat_classification.tsv>"
-fi;
-;;
-###################################
-###################################
-###################################
-###################################
-fragment_tree_network)
-echo "Run fragment_tree_network.";
-if [ -d temp ] && [ -f ftalign.tsv ] && [ -f .format ]
-then
-  echo "Project path acknowledged."
-else
-  until [ -d $projectpath ] && [ -f $projectpath/ftalign.tsv ] && [ -f $projectpath/.format ]
-  do
-    read -p "Please input the path of the sirius project. Make sure you have moved the fragment tree alignment results to the directory where the project is located. >>> " projectpath;
-  done;
-  cd $projectpath;
-fi;
-echo "Please enter the minimum alignment similarity(tlimit) that you want to filter."
-tlimit=0
-until [[ "$tlimit" > "0.01" ]] && [[ "$tlimit" < "0.99" ]]
-do
-  read -p "0.4-0.7 is recommended >>> " tlimit;
-done;
-if ! [ -d temp/ftaligntemp ]
-then 
-  mkdir temp/ftaligntemp
-fi;
-data="ftalign.tsv"
-savepath="temp/ftaligntemp/tmp"
-awk -F $'\t' -v OFS=$'\t' '
-{
-  printf "Info: NR = " NR ". FNR = " FNR ".\n"
-  if(NR==FNR)
-    {
-      for(i=1; i<=NF; i++)
-        {
-          if(NR==1 && i!=1 || NR!=1 && i==1)
-            {
-              n=split($i,x,"[_]")
-              raw[NR,i]=x[n]
-            }
-        else
-          {
-            if(NR==i)
-              {
-                raw_norm[NR,i]=$i
-              }
-          }
-      }
-  }
-if(NR>FNR && FNR>=2)
-  {
-    for(i=2; i<=NF; i++)
-      {
-        norm1=$i/raw_norm[i,i]
-        norm2=$i/raw_norm[FNR,FNR]
-        norms=sprintf("%.2f", ((norm1+norm2)/2))
-        if((norms+0 > '$tlimit'+0))
-          {
-            if(raw[FNR,1]+0>=raw[1,i]+0)
-              {
-                print raw[FNR,1], raw[1,i], norms > "'$savepath'"
-              }
-            if(raw[FNR,1]+0<raw[1,i]+0)
-              {
-                print raw[1,i], raw[FNR,1], norms > "'$savepath'"
-              }
-          }
-      }
-  }
-}' $data $data
-sort -u $savepath > temp/ftaligntemp/tmp2
-savepath="temp/ftaligntemp/filter_net_$tlimit"
-awk -F $'\t' '
-{
-  if(NR==FNR)
-    {
-      if($1!=$2)
-        {
-          replink[$1]=$1
-          replink[$2]=$2
-        }
-    }
-  if(NR!=FNR)
-    {
-      if($1!=$2)
-        {
-          printf $0"\n" > "'$savepath'" 
-        } 
-      if($1==$2)
-        {
-          if(replink[$1]=="")
-            {
-              printf $0"\n" > "'$savepath'"
-            }
-        }
-    }
-}' temp/ftaligntemp/tmp2 temp/ftaligntemp/tmp2
-echo "fragment_tree_network have been successfully written into <temp/ftaligntemp/filter_net_$tlimit>"
-;;
-###################################
-###################################
-###################################
-###################################
-fragment_tree_network_delta)
-if [ -d temp ] && [ -f ftalign.tsv ] && [ -f .format ]
-then
-  echo "Project path acknowledged."
-else
-  until [ -d $projectpath ] && [ -f $projectpath/ftalign.tsv ] && [ -f $projectpath/.format ]
-  do
-    read -p "Please input the path of the sirius project >>> " projectpath;
-  done;
-  cd $projectpath;
-fi;
-echo "The following module attempts to compute the differential fingerprints of connected clusters based on the molecular fingerprint results of sirius 4."
-###################
-###################
-###################
-plimit=0
-until [[ "$plimit" > "0.5" ]] && [[ "$plimit" < "0.99" ]]
-do
-  read -p "If the minimum alignment similarity is greater than 0.3, this step will automatic calculate the discrepancy fingerprint between alignment features(in beta). Please enter the minimum posterior probability of the molecular fingerprint(plimit_1) to be filtered. 0.9-0.99 is recommended. >>> " plimit;
-done;
-plimit2=0
-until [[ "$plimit2" > "0.1" ]] && [[ "$plimit2" < "$plimit" ]]
-do
-  read -p "The minimum posterior probability of the molecular fingerprint(plimit_2) to be controled. 0.1-0.5 may work well. >>> " plimit2;
-done;
-tlimit=$(ls temp/ftaligntemp/filter_net_* | awk -F _ '{print $NF}')
-check_rep=$(awk 'END{print NR}' <(echo "$tlimit"))
-if [[ "$check_rep" > "1" ]]
-then
-  tlimit=0
-  until [ -f temp/ftaligntemp/filter_net_$tlimit ]
-  do
-    read -p "Plural and different fragment_tree_network files were found to exist locally. Please select a tlimit parameter you have utilized to run fragment_tree_network_delta. >>> " tlimit;
-  done;
-fi;
-if [ -f temp/ftaligntemp/refilter_net_$tlimit ]
-then rm temp/ftaligntemp/refilter_net_$tlimit
-fi;
-if [ -f temp/ftaligntemp/fpsample ]
-then rm temp/ftaligntemp/fpsample
-fi;
-echo "Running delta_fingerprint computation..."
-echo "Aquiring data from sirius index..."
-data1="*_*/compound.info"
-data2="temp/ftaligntemp/filter_net_$tlimit"
-echo "Run fragment_tree_network_delta."
-savepath="temp/ms_data_$tlimit"
-echo "step 1: ms data"
-if ! [ -f $savepath ]
-then
-  awk -F "[\t]||[:]||[_]" -v OFS=$'\t' '
-  BEGIN{  
-  printf "..."
-  printf "id\t"  "m/z\t"  "rt\n" > "results/mz_and_rt.tsv"
-}
-{
-  if(FILENAME~/compound.info/)
-    {
-      if(FNR==1)
-        {
-          printf "Info: catch >>> "FILENAME"\n"
-        }
-      if($1=="name")
-        {
-          i+=1;
-          id[i]=$NF;
-          n=split($NF,a,"[_]")
-          printf a[n]"\t" >> "results/mz_and_rt.tsv"
-        }
-      if($1=="ionMass")
-        {
-          mz[id[i]]=$NF
-          printf sprintf("%.4f",$NF)"\t" >> "results/mz_and_rt.tsv"
-        }
-      if($1=="ionType")
-        {
-          type[id[i]]=$NF
-        }
-      if($1=="rt")
-        {
-          rt[id[i]]=$2;
-          printf sprintf("%.2f",$2/60)"\n" >> "results/mz_and_rt.tsv"
-        }
-    }
-  if(FILENAME~/ftaligntemp/)
-    {
-      #source  target  ftalign  delta_mz  delta_rt  source_iontype  target_iontype;
-      if(FNR==1)
-        {
-          printf "" > "'$savepath'"
-        }
-      print $1,$2,$3,sprintf("%.3f",mz[$2]-mz[$1]),sprintf("%.2f",rt[$2]-rt[$1]),type[$1],type[$2]  >> "'$savepath'"
-    }
-}' $data1 $data2
-fi;
-########################
-echo "step 2: data path"
-source_file="temp/Mo_filename"
-data="temp/ms_data_$tlimit"
-savepath="temp/datapath_$tlimit"
-if ! [ -f $savepath ]
-then
-  awk -F $'\t' -v OFS=$'\t' '
-  {
-    if(NR==FNR)
-      {
-        n=split($2, a, "[_]")
-        file[a[n]]=$2
-        formu_type[a[n]]=$3
-      }
-    if(NR!=FNR)
-      {
-        #<path>sourceFormula  <path>targetFormula
-        path1=file[$1]"/fingerprints/"formu_type[$1]".fpt"
-        path2=file[$2]"/fingerprints/"formu_type[$2]".fpt"
-        data[path1]=path1
-        data[path2]=path2
-      }
-  }
-END{
-for(i in data)
-  {
-    n+=1
-    print "Check file:",n
-    if(getline<i==-1)
-      {
-        printf "Escape filename: " i "\n"
-      }
-  else
-    {
-      printf i" " > "'$savepath'"
-    }
-  close(i)
-}
-print "Sum:",n
-}' $source_file $data
-fi;
-datapath=$(cat temp/datapath_$tlimit)
-echo "step 3: fingerprint"
-data_allfp="temp/data_allfp_$tlimit"
-if ! [ -f $data_allfp ]
-then
-  awk -F $'\t' '
-  BEGIN{
-  n=0
-}
-{
-  if(FNR==1)
-    {
-      if(n>1)
-        {
-          close(file)
-        }
-      file=FILENAME;
-      print "Get fingerprints: ",FILENAME
-      n+=1;
-      printf FILENAME"\n"$0"\n" > "'$data_allfp'"
-    }
-else
-  {
-    print $0 > "'$data_allfp'"
-  }
-}' $datapath
-fi;
-###########################
-awk -F $'\t' -v OFS=$'\t' '
-{
-  if(NR==1)
-    {
-      for(i=1; i<=NF; i++)
-        {
-          if($i~/absolute/)
-            {
-              col_index=i
-            }
-          if($i~/description/)
-            {
-              col_description=i
-            }
-        }
-    }
-  if(NR>=2)
-    {
-      print $col_index,$col_description
-    }
-}' csi_fingerid.tsv > temp/ftaligntemp/pos_fingerprint_index;
-awk -F $'\t' -v OFS=$'\t' '
-{
-  if(NR==1)
-    {
-      for(i=1; i<=NF; i++)
-        {
-          if($i~/absolute/)
-            {
-              col_index=i
-            }
-          if($i~/description/)
-            {
-              col_description=i
-            }
-        }
-    }
-  if(NR>=2)
-    {
-      print $col_index,$col_description
-    }
-}' csi_fingerid_neg.tsv > temp/ftaligntemp/neg_fingerprint_index;
-posindex="temp/ftaligntemp/pos_fingerprint_index"
-negindex="temp/ftaligntemp/neg_fingerprint_index"
-data="temp/ms_data_$tlimit"
-echo "step 4: merge data"
-awk -F $'\t' '
-BEGIN{
-file=0
-x=0
-count=0
-f=0
-posnum=0
-negnum=0
-}
-{
-  if(FNR==1)
-    {
-      file+=1
-    }
-  if(NR==FNR)
-    {
-      if(($1~/fingerprint/))
-        {
-          if(x+0>f+0)
-            {
-              f=x  # calculate the max index.
-            }
-          count+=1;  # calculate the all fingerprints file number.
-          split($1,a,"[/]"); e=split(a[1],b,"[_]"); id=b[e]; #catch the id.
-          x=0;
-        }
-    else
-      {
-        x+=1;
-        fp[id,x]=$1;
-      }
-  }
-if(file==2)
-  {
-    pos[FNR]=$1
-    posnum+=1
-  }
-if(file==3)
-  {
-    neg[FNR]=$1
-    negnum+=1
-  }
-if(file==4)
-  {
-    if("'$tlimit'"+0 >= 0.3)
-      {
-        if(fp[$1,1]!="" && fp[$2,1]!="")
-          {
-            n1=split($6, g, "[]]");
-            n2=split($7, h, "[]]");
-            if(g[n1]=="+" && h[n2]=="+")
-              {
-                for(x=1; x<=posnum; x++)
-                  {
-                    if(fp[$1,x]+0>='$plimit'+0 && fp[$2,x]+0<='$plimit2'+0)
-                      {
-                        data_s[FNR,x]=pos[x]
-                      }
-                  else if(fp[$2,x]+0>='$plimit'+0 && fp[$1,x]+0<='$plimit2'+0)
-                    {
-                      data_t[FNR,x]=pos[x]
-                    }
-                }
-            }
-          if(g[n1]=="-" && h[n2]=="-")
-            {
-              for(x=1; x<=negnum; x++)
-                {
-                  if(fp[$1,x]+0>='$plimit'+0 && fp[$2,x]+0<='$plimit2'+0)
-                    {
-                      data_s[FNR,x]=neg[x]
-                    }
-                else if(fp[$2,x]+0>='$plimit'+0 && fp[$1,x]+0<='$plimit2'+0)
-                  {
-                    data_t[FNR,x]=neg[x]
-                  }
-              }
-          }
-        if(g[n1]=="-" && h[n2]=="+" || h[n2]=="-" && g[n1]=="+")
-          {
-            for(i=1; i<=posnum; i++)
-              {
-                for(j=1; j<=negnum; j++)
-                  {
-                    if(pos[i]==neg[j])
-                      {
-                        mirror[i]=j  #if pos=i, the identical index of neg is mirror[i]
-                      }
-                  }
-              }
-          }
-        if(g[n1]=="-" && h[n2]=="+") 
-          {
-            for(x=1; x<=f; x++)
-              {
-                if(fp[$1,mirror[x]]+0>='$plimit'+0 && fp[$2,x]+0<='$plimit2'+0)
-                  {
-                    data_s[FNR,x]=neg[mirror[x]]
-                  }
-              else if(fp[$2,x]+0>='$plimit'+0 && fp[$1,mirror[x]]+0<='$plimit2'+0)
-                {
-                  data_t[FNR,x]=neg[mirror[x]]
-                }
-            }
-        }
-      if(h[n2]=="-" && g[n1]=="+")
-        {
-          for(x=1; x<=f; x++)
-            {
-              if(fp[$1,x]+0>= '$plimit'+0 && fp[$2,mirror[x]]+0<='$plimit2'+0)
-                {
-                  data_s[FNR,x]=neg[mirror[x]]
-                }
-            else if(fp[$2,mirror[x]]+0>='$plimit'+0 && fp[$1,x]+0<='$plimit2'+0)
-              {
-                data_t[FNR,x]=neg[mirror[x]]
-              }
-          }   
-      }
-  }
-}
-if(FNR==1)
-  {
-    printf "source\t"  "target\t"  "ftalign_similarity\t"  "delta_m/z\t"  "source_fp_uniq\t"  "target_fp_uniq\n"
-  }
-else
-  {
-    printf $1"\t"  $2"\t"  $3"\t"  $4"\t";
-    if('$tlimit'+0 >= 0.3)
-      {
-        if(fp[$1,1]=="" || fp[$2,1]=="")
-          {
-            printf "NA@NA\n"
-          }
-      else
-        {
-          printf "source:"  #the source fingerprint uniq.
-          for(x=1; x<=f; x++)
-            {
-              if(data_s[FNR,x]!="")
-                {
-                  printf data_s[FNR,x]","
-                }
-            };
-          printf "@target:"  #the target fingerprint uniq.
-          for(x=1; x<=f; x++)
-            {
-              if(data_t[FNR,x]!="")
-                {
-                  printf data_t[FNR,x]","
-                }
-            }
-          printf "\n"
-        }
-    }
-else
-  {
-    printf "NA@NA\n"
-  }
-}
-}
-}' $data_allfp $posindex $negindex $data | sed -e 's/,@/\t/g; s/,$//g; s/@/\t/g'  > results/source_target_tree_$tlimit.tsv;
-echo "All instances have written into <results/source_target_tree_$tlimit.tsv>."
-#####################################
-echo "step 5: separate child-nebula from parent-nebula."
-data="results/stat_classification.tsv"
-savepath="temp/filter_0_class.tsv"
-awk -F $'\t' '
-{
-  if(FNR==1)
-    {
-      for(i=1; i<=NF; i++)
-        {
-          if($i~/^definition$/)
-            {
-              col_class=i
-            }
-        }
-    }
-  if(FNR>=2)
-    {
-      class[$col_class]=$col_class
-    }
-}
-END{
-for(i in class)
-  {
-    printf class[i]"\n" > "'$savepath'"
-  }
-}' $data
-######################################
-data1="temp/filter_0_class.tsv" 
-data2="results/canopus_pp.tsv"
-data3="results/fingerid_first_score.tsv"
-until [[ "$similarity_limit" > 0 ]] && [[ "$similarity_limit" < 1 ]]
-do
-  read -p "Please set the Tanimoto similarity threshold contribute to child-nebula. >>> " similarity_limit;
-done;
-until [[ "$definition_limit" > 0.01 ]] && [[ "$definition_limit" < 1 ]]
-do
-  read -p "Please enter the classes posterior probabilities limition. 0.5~0.99 may work well. >>> " definition_limit;
-done;
-class_pp_limit=$definition_limit
-savepath="temp/idenfication_filter_$class_pp_limit.tsv"
-awk -F $'\t' '
-{
-  if(NR==FNR)
-    {
-      filter_class[$1]=$1
-    }
-  if(FILENAME~/canopus/)
-    {
-      if(FNR==1)
-        {
-          col_id=1
-          for(i=2; i<=NF; i++)
-            {
-              for(j in filter_class)
-                {
-                  if(j==$i)
-                    {
-                      col_class[j]=i
-                      print i
-                    }
-                }
-            }
-        }
-      if(FNR>=2)
-        {
-          for(i in col_class)
-            {
-              if(sprintf("%.3f",$col_class[i])+0>="'$class_pp_limit'"+0)
-                {
-                  class_set[i,$col_id]=i
-                  print "ID: ",$1,i,$col_class[i]
-                }
-            }
-        }
-    }
-  if(FILENAME~/fingerid_first_score/)
-    {
-      if(FNR==1)
-        {
-          for(i=1; i<=NF; i++)
-            {
-              if($i~/^id/)
-                {
-                  col_id=i
-                }
-              if($i~/similarity/)
-                {
-                  col_similarity=i
-                }
-            }
-          printf "class_nebula_facet\t"  $0"\n" > "'$savepath'"
-        }
-      if(FNR>=2)
-        {
-          if($col_similarity+0 >= "'$similarity_limit'"+0)
-            {
-              for(i in class_set)
-                {
-                  if(i~"\034"$col_id"$")
-                    {
-                      printf class_set[i]"\t"  $0"\n" > "'$savepath'"
-                    }
-                }
-            }
-        }
-    }
-}' $data1 $data2 $data3
-###################################
-data="temp/idenfication_filter_$class_pp_limit.tsv"
-savepath="temp/idenfication_filter2_${class_pp_limit}.tsv"
-until [[ "$num_limit_1" -gt 0 ]]
-do
-  read -p "Please enter the features number threshold contribute to child-nebula (min number). >>> " num_limit_1;
-done;
-until [[ "$num_limit_2" -gt "$num_limit_1" ]]
-do
-  read -p "Please enter the features number threshold contribute to child-nebula (max number). >>> " num_limit_2;
-done;
-awk -F $'\t' '
-{
-  if(FNR==1)
-    {
-      printf $0"\n" > "'$savepath'"
-      for(i=1; i<=NF; i++)
-        {
-          if($i~/class_nebula_facet/)
-            {
-              col_class=i
-            }
-        }
-    }
-  if(FNR>=2)
-    {
-      num[$col_class]+=1
-      data[FNR]=$0
-      class[FNR]=$col_class
-    }
-}
-END{
-for(i in num)
-  {
-    if(num[i]+0 >= '$num_limit_1'+0 && num[i]+0 <= '$num_limit_2')
-      {
-        printf "The nodes number of the child-nebula is " num[i] ".\n"
-        for(j in class)
-          {
-            if(class[j]==i)
-              {
-                printf data[j]"\n" >> "'$savepath'"
-              }
-          }
-      }
-  }
-}' $data
-##################################
-mkdir results/network_facet_$class_pp_limit
-data1="temp/idenfication_filter2_${class_pp_limit}.tsv"
-data2="results/source_target_tree_$tlimit.tsv" # "results/source_target_tree_0.4.tsv"
-save_class="results/filter_child_class.tsv"
-savepath="results/network_facet_$class_pp_limit/"
-awk -F $'\t' '
-{
-  if(NR==FNR)
-    {
-      if(FNR==1)
-        {
-          for(i=1; i<=NF; i++)
-            {
-              if($i~/class_nebula_facet/)
-                {
-                  col_class=i
-                }
-              if($i~/^id$/)
-                {
-                  col_id=i
-                }
-            }
-        }
-      if(FNR>=2)
-        {
-          class[$col_class]=$col_class
-          class_id[$col_class,$col_id]=$col_id
-          stat_id[$col_class,$col_id]=$col_id
-          belong[$col_class,$col_id]=$col_class
-        }
-    }
-  if(NR>FNR)
-    {
-      if(FNR==1)
-        {
-          for(i in class)
-            {
-              printf i"\n" > "'$save_class'"
-              printf $0"\t"  "facet\n" > "'$savepath'" i ".tsv"
-            }
-        }
-      if(FNR>=2)
-        {
-          for(i in class)
-            {
-              if( class_id[i,$1]==$1 && class_id[i,$2]==$2 )
-                {
-                  printf $0"\t"  i"\n" >> "'$savepath'" i ".tsv"
-                  delete stat_id[i,$1]
-                  delete stat_id[i,$2]
-                }
-            }
-        }
-    }
-}
-END{
-for(i in stat_id)
-  {
-    ## source target similarity delta_mz fp fp class
-    printf stat_id[i]"\t" stat_id[i]"\t"  "1\t"  "0\t"  "null\t"  "null\t"  belong[i]"\n"  >> "'$savepath'" belong[i] ".tsv"
-  }
-}' $data1 $data2
-#####################
-data1="canopus.tsv"
-data2="results/filter_child_class.tsv"
-data3="results/canopus_pp.tsv"
-savepath="results/canopus_pp_filter.tsv"
-awk -F $'\t' '
-{
-  if(FILENAME~/canopus.tsv/)
-    {
-      if(FNR==1)
-        {
-          for(i=1; i<=NF; i++)
-            {
-              if($i~/absolute/)
-                {
-                  col_index=i
-                }
-              if($i~/^id/)
-                {
-                  col_chemid=i
-                }
-              if($i~/name/)
-                {
-                  col_name=i
-                }
-              if($i~/description/)
-                {
-                  col_des=i
-                }
-            }
-        }
-      if(FNR>2)
-        {
-          ab_index[$col_name]=$col_index
-          chemid[$col_name]=$col_chemid
-          des[$col_name]=$col_des
-        }
-    }
-  if(FILENAME~/filter_child_class/)
-    {
-      class[$1]=$1
-      if(FNR==1)
-        {
-          printf "index\t"  "chem_id\t"  "name\t"  "description\n" > "results/child_class.tsv"
-        }
-      printf ab_index[$1]"\t"  chemid[$1]"\t"  $1"\t"  des[$1]"\n" >> "results/child_class.tsv"
-    }
-  if(FILENAME~/canopus_pp/)
-    {
-      if(FNR==1)
-        {
-          printf $1 > "'$savepath'"
-          for(i=2; i<=NF; i++)
-            {
-              if(class[$i]!="")
-                {
-                  n+=1
-                  printf "\tC"ab_index[$i] >> "'$savepath'"
-                  col_set[n]=i
-                }
-            }
-          printf "\n" >> "'$savepath'"
-        }
-      if(FNR>=2)
-        {
-          printf $1 >> "'$savepath'"
-          for(i=1; i<=n; i++)
-            {
-              printf "\t"$col_set[i] >> "'$savepath'"
-            }
-          printf "\n" >> "'$savepath'"
-        }
-    }
-}' $data1 $data2 $data3
-;;
-###################################
-###################################
-compound_idenfication)
-echo "Run compound_idenfication."
-echo "compound_idenfication "
-exit
-;;
-###################################
-###################################
-double_ion_network)
-exit;
-;;
-###################################
-###################################
-###################################
-###################################
-exit)
-echo "The mystery of creation is like the darkness of night--it is great.
-Delusions of knowledge are like the fog of the morning."
-exit;
-;;
-###################################
-###################################
-###################################
-###################################
-*)
-echo "error"
-exit;
-;;
-esac;
-done;#(for)
-done;#(select)
```

# File: uformat.sh

```{r eval = F, echo = T}
sudo fdisk -l
umount 
sudo mkfs -V -t vfat /dev/sdb1
```

# File: wechat.sh

```{r eval = F, echo = T}
docker run -d --name wechat --device /dev/snd --ipc=host \
-v /tmp/.X11-unix:/tmp/.X11-unix \
-v $HOME/WeChatFiles:/WeChatFiles \
-e DISPLAY=unix$DISPLAY \
-e XMODIFIERS=@im=fcitx \
-e QT_IM_MODULE=fcitx \
-e GTK_IM_MODULE=fcitx \
-e AUDIO_GID=`getent group audio | cut -d: -f3` \
-e GID=`id -g` \
-e UID=`id -u` \
bestwu/wechat

```

# File: zotero.sh

```{r eval = F, echo = T}
cd /mnt/data/wizard/Zotero_linux-x86_64
bash -c "$(dirname $(realpath $(echo %k | sed -e 's/^file:\/\///')))/zotero -url %U"
```

