---
title: R codes of MCnebula2
bibliography: '`r system.file("extdata", "library.bib", package = "utils.tool")`'
csl: '`r system.file("extdata", "nature.csl", package = "utils.tool")`'
reference-section-title: "Reference"
output:
  custom_docx_document:
    reference_docx: '`r system.file("extdata", "ch_thesis.docx", package = "utils.tool")`'
---


# 前2500行代码：

```{r eval = F, echo = T}
# ==========================================================================
# Generic for base method (get or replace data in slots) of class
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
#' @importFrom methods as formalArgs getGeneric getMethodsForDispatch
#' @importFrom methods initialize is new selectMethod show showMethods
## class-melody
setGeneric("melody", 
           function(x) standardGeneric("melody"))
setGeneric("melody<-", 
           function(x, value) standardGeneric("melody<-"))

setGeneric("palette_set", 
           function(x) standardGeneric("palette_set"))
setGeneric("palette_set<-", 
            function(x, value) standardGeneric("palette_set<-"))
setGeneric("palette_gradient", 
           function(x) standardGeneric("palette_gradient"))
setGeneric("palette_gradient<-", 
           function(x, value) standardGeneric("palette_gradient<-"))
setGeneric("palette_stat", 
           function(x) standardGeneric("palette_stat"))
setGeneric("palette_stat<-", 
           function(x, value) standardGeneric("palette_stat<-"))
setGeneric("palette_col", 
           function(x) standardGeneric("palette_col"))
setGeneric("palette_col<-", 
           function(x, value) standardGeneric("palette_col<-"))
setGeneric("palette_label", 
           function(x) standardGeneric("palette_label"))
setGeneric("palette_label<-", 
           function(x, value) standardGeneric("palette_label<-"))

## class-nebula
setGeneric("parent_nebula", 
           function(x) standardGeneric("parent_nebula"))
setGeneric("parent_nebula<-", 
           function(x, value) standardGeneric("parent_nebula<-"))
setGeneric("child_nebulae", 
           function(x) standardGeneric("child_nebulae"))
setGeneric("child_nebulae<-", 
           function(x, value) standardGeneric("child_nebulae<-"))

setGeneric("igraph", 
           function(x) standardGeneric("igraph"))
setGeneric("igraph<-", 
           function(x, value) standardGeneric("igraph<-"))
setGeneric("tbl_graph", 
           function(x) standardGeneric("tbl_graph"))
setGeneric("tbl_graph<-", 
           function(x, value) standardGeneric("tbl_graph<-"))
setGeneric("layout_ggraph", 
           function(x) standardGeneric("layout_ggraph"))
setGeneric("layout_ggraph<-", 
           function(x, value) standardGeneric("layout_ggraph<-"))
setGeneric("grid_layout", 
           function(x) standardGeneric("grid_layout"))
setGeneric("grid_layout<-", 
           function(x, value) standardGeneric("grid_layout<-"))
setGeneric("viewports", 
           function(x) standardGeneric("viewports"))
setGeneric("viewports<-", 
           function(x, value) standardGeneric("viewports<-"))
setGeneric("panel_viewport", 
           function(x) standardGeneric("panel_viewport"))
setGeneric("panel_viewport<-", 
           function(x, value) standardGeneric("panel_viewport<-"))
setGeneric("legend_viewport", 
           function(x) standardGeneric("legend_viewport"))
setGeneric("legend_viewport<-", 
           function(x, value) standardGeneric("legend_viewport<-"))
setGeneric("structures_grob", 
           function(x) standardGeneric("structures_grob"))
setGeneric("structures_grob<-", 
           function(x, value) standardGeneric("structures_grob<-"))
setGeneric("nodes_ggset", 
           function(x) standardGeneric("nodes_ggset"))
setGeneric("nodes_ggset<-", 
           function(x, value) standardGeneric("nodes_ggset<-"))
setGeneric("nodes_grob", 
           function(x) standardGeneric("nodes_grob"))
setGeneric("nodes_grob<-", 
           function(x, value) standardGeneric("nodes_grob<-"))
setGeneric("ppcp_data", 
           function(x) standardGeneric("ppcp_data"))
setGeneric("ppcp_data<-", 
           function(x, value) standardGeneric("ppcp_data<-"))
setGeneric("ration_data", 
           function(x) standardGeneric("ration_data"))
setGeneric("ration_data<-", 
           function(x, value) standardGeneric("ration_data<-"))
setGeneric("ggset_annotate", 
           function(x) standardGeneric("ggset_annotate"))
setGeneric("ggset_annotate<-", 
           function(x, value) standardGeneric("ggset_annotate<-"))

## class-mcnebula
setGeneric("creation_time", 
           function(x) standardGeneric("creation_time"))
setGeneric("creation_time<-", 
           function(x, value) standardGeneric("creation_time<-"))
setGeneric("ion_mode", 
           function(x) standardGeneric("ion_mode"))
setGeneric("ion_mode<-", 
           function(x, value) standardGeneric("ion_mode<-"))
setGeneric("match.features_id", 
           function(x) standardGeneric("match.features_id"))
setGeneric("match.candidates_id", 
           function(x) standardGeneric("match.candidates_id"))
setGeneric("specific_candidate", 
           function(x) standardGeneric("specific_candidate"))
setGeneric("classification", 
           function(x) standardGeneric("classification"))
setGeneric("hierarchy", 
           function(x) standardGeneric("hierarchy"))
setGeneric("stardust_classes", 
           function(x) standardGeneric("stardust_classes"))
setGeneric("features_annotation", 
           function(x) standardGeneric("features_annotation"))
setGeneric("features_quantification", 
           function(x) standardGeneric("features_quantification"))
setGeneric("features_quantification<-", 
           function(x, value) standardGeneric("features_quantification<-"))
setGeneric("sample_metadata", 
           function(x) standardGeneric("sample_metadata"))
setGeneric("sample_metadata<-", 
           function(x, value) standardGeneric("sample_metadata<-"))
setGeneric("nebula_index", 
           function(x) standardGeneric("nebula_index"))
setGeneric("spectral_similarity", 
           function(x) standardGeneric("spectral_similarity"))
setGeneric("spectral_similarity<-", 
           function(x, value) standardGeneric("spectral_similarity<-"))

## class-project
setGeneric("project_version", 
           function(x) standardGeneric("project_version"))
setGeneric("project_version<-", 
           function(x, value) standardGeneric("project_version<-"))
setGeneric("project_path", 
           function(x) standardGeneric("project_path"))
setGeneric("project_path<-", 
           function(x, value) standardGeneric("project_path<-"))
## class-project_conformation
setGeneric("project_conformation", 
           function(x) standardGeneric("project_conformation"))
setGeneric("project_conformation<-", 
           function(x, value) standardGeneric("project_conformation<-"))

setGeneric("file_name", 
           function(x) standardGeneric("file_name"))
setGeneric("file_name<-", 
           function(x, value) standardGeneric("file_name<-"))
setGeneric("file_api", 
           function(x) standardGeneric("file_api"))
setGeneric("file_api<-", 
           function(x, value) standardGeneric("file_api<-"))
setGeneric("attribute_name", 
           function(x) standardGeneric("attribute_name"))
setGeneric("attribute_name<-", 
           function(x, value) standardGeneric("attribute_name<-"))

## class-project_metadata
setGeneric("project_metadata", 
           function(x) standardGeneric("project_metadata"))
setGeneric("project_metadata<-", 
           function(x, value) standardGeneric("project_metadata<-"))

setGeneric("metadata", 
           function(x) standardGeneric("metadata"))
setGeneric("metadata<-", 
           function(x, value) standardGeneric("metadata<-"))

## class-project_api
setGeneric("project_api", 
           function(x) standardGeneric("project_api"))
setGeneric("project_api<-", 
           function(x, value) standardGeneric("project_api<-"))

setGeneric("methods_read", 
           function(x) standardGeneric("methods_read"))
setGeneric("methods_read<-", 
           function(x, value) standardGeneric("methods_read<-"))
setGeneric("methods_format", 
           function(x) standardGeneric("methods_format"))
setGeneric("methods_format<-", 
           function(x, value) standardGeneric("methods_format<-"))
setGeneric("methods_match", 
           function(x) standardGeneric("methods_match"))
setGeneric("methods_match<-", 
           function(x, value) standardGeneric("methods_match<-"))

## class-project_dataset
## class-mcn_dataset
setGeneric("project_dataset", 
           function(x) standardGeneric("project_dataset"))
setGeneric("project_dataset<-", 
           function(x, value) standardGeneric("project_dataset<-"))
setGeneric("mcn_dataset", 
           function(x) standardGeneric("mcn_dataset"))
setGeneric("mcn_dataset<-", 
           function(x, value) standardGeneric("mcn_dataset<-"))

## class-msframe
setGeneric("msframe", 
           function(x) standardGeneric("msframe"))
setGeneric("msframe<-", 
           function(x, value) standardGeneric("msframe<-"))

setGeneric("entity", 
           signature = c(msframe = "x"),
           function(x) standardGeneric("entity"))
setGeneric("entity<-", 
           signature = c(msframe = "x"),
           function(x, value) standardGeneric("entity<-"))

## class-command
setGeneric("command", 
           function(x) standardGeneric("command"))
setGeneric("command<-", 
           function(x, value) standardGeneric("command<-"))

setGeneric("command_name", 
           function(x) standardGeneric("command_name"))
setGeneric("command_name<-", 
           function(x, value) standardGeneric("command_name<-"))
setGeneric("command_function", 
           function(x) standardGeneric("command_function"))
setGeneric("command_function<-", 
           function(x, value) standardGeneric("command_function<-"))
setGeneric("command_args", 
           function(x) standardGeneric("command_args"))
setGeneric("command_args<-", 
           function(x, value) standardGeneric("command_args<-"))

## class-code_block
setGeneric("code_block", 
           function(x) standardGeneric("code_block"))
setGeneric("code_block<-", 
           function(x, value) standardGeneric("code_block<-"))

setGeneric("codes", 
           function(x) standardGeneric("codes"))
setGeneric("codes<-", 
           function(x, value) standardGeneric("codes<-"))

## class-ggset
setGeneric("ggset", 
           function(x) standardGeneric("ggset"))
setGeneric("ggset<-", 
           function(x, value) standardGeneric("ggset<-"))

setGeneric("layers", 
           function(x) standardGeneric("layers"))
setGeneric("layers<-", 
           function(x, value) standardGeneric("layers<-"))

## class-section
setGeneric("section", 
           function(x) standardGeneric("section"))
setGeneric("section<-", 
           function(x, value) standardGeneric("section<-"))
setGeneric("heading", 
           function(x) standardGeneric("heading"))
setGeneric("heading<-", 
           function(x, value) standardGeneric("heading<-"))

setGeneric("level", 
           function(x) standardGeneric("level"))
setGeneric("level<-", 
           function(x, value) standardGeneric("level<-"))
setGeneric("paragraph", 
           function(x) standardGeneric("paragraph"))
setGeneric("paragraph<-", 
           function(x, value) standardGeneric("paragraph<-"))

## class-VIRTUAL
setGeneric("subscript", 
           function(x) standardGeneric("subscript"))
setGeneric("subscript<-", 
           function(x, value) standardGeneric("subscript<-"))

setGeneric("dataset", 
           function(x) standardGeneric("dataset"))
setGeneric("dataset<-", 
           function(x, value) standardGeneric("dataset<-"))

setGeneric("reference", 
           function(x) standardGeneric("reference"))
setGeneric("reference<-", 
           function(x, value) standardGeneric("reference<-"))

setGeneric("backtrack", 
           function(x) standardGeneric("backtrack"))
setGeneric("backtrack<-", 
           function(x, value) standardGeneric("backtrack<-"))

setGeneric("export_name", 
           function(x) standardGeneric("export_name"))
setGeneric("export_name<-", 
           function(x, value) standardGeneric("export_name<-"))
setGeneric("export_path", 
           function(x) standardGeneric("export_path"))
setGeneric("export_path<-", 
           function(x, value) standardGeneric("export_path<-"))

## class-statistic_set
setGeneric("statistic_set", 
           function(x) standardGeneric("statistic_set"))
setGeneric("statistic_set<-", 
           function(x, value) standardGeneric("statistic_set<-"))

setGeneric("design_matrix", 
           function(x) standardGeneric("design_matrix"))
setGeneric("design_matrix<-", 
           function(x, value) standardGeneric("design_matrix<-"))
setGeneric("contrast_matrix", 
           function(x) standardGeneric("contrast_matrix"))
setGeneric("contrast_matrix<-", 
           function(x, value) standardGeneric("contrast_matrix<-"))
setGeneric("top_table", 
           function(x) standardGeneric("top_table"))
setGeneric("top_table<-", 
           function(x, value) standardGeneric("top_table<-"))

## class-report
setGeneric("yaml", 
           function(x) standardGeneric("yaml"))
setGeneric("yaml<-", 
           function(x, value) standardGeneric("yaml<-"))
# ==========================================================================
# a class to store function and its name and args
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
#' @exportClass command
#'
#' @aliases command
#'
#' @title Preparation of an instruction to be executed
#'
#' @description Packing the funciton and the args inside this class object,
#' so that it can be performed easily at any time.
#'
#' @family call_commands
#'
#' @slot command_name character(1). Describe the command name.
#' @slot command_function function.
#' @slot command_args the parameters passed to the function.
#'
#' @rdname command-class
#'
.command <- 
  setClass("command", 
           contains = character(),
           representation = 
             representation(command_name = "character",
                            command_function = "function",
                            command_args = "list"
                            ),
           prototype = NULL
           )

# ==========================================================================
# method
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
#' @exportMethod show
#' @aliases show
#' @rdname command-class
setMethod("show", 
          signature = c(object = "command"),
          function(object){
            cat(command_name(object), "\n")
            args <- vapply(command_args(object), function(v) class(v)[1], "ch")
            if (length(args) >= 1) {
              cat(paste0(paste0(rep(" ", 2), collapse = ""),
                         names(args), ": ", args), sep = "\n")
            } else {
              cat(paste0(paste0(rep(" ", 2), collapse = ""),
                         "list()"), "\n")
            }
          })

#' @exportMethod command_name
#' @aliases command_name
#' @description \code{command_name}, \code{command_name<-}: getter and setter
#' for the \code{command_name} slot of the object.
#' @rdname command-class
setMethod("command_name", 
          signature = c(x = "command"),
          function(x){ x@command_name })

#' @exportMethod command_name<-
#' @aliases command_name<-
#' @param value The value for the slot.
#' @rdname command-class
#'
#' @examples
#' \dontrun{
#'   ## example 1
#'   com <- new_command(plot, x = 1:10)
#'   com
#'   call_command(com)
#'   
#'   ## example 2
#'   com <- new_command(data.frame, x = 1:10, y = 1:10, z = 1:10)
#'   call_command(com)
#'   
#'   ## example 3
#'   data <- data.frame(x = 1:10, y = 1:10)
#'   com1 <- new_command(ggplot, data)
#'   com2 <- new_command(geom_point, aes(x = x, y = y))
#'   call_command(com1) + call_command(com2)
#'   
#'   ## slots
#'   command_name(com)
#'   command_args(com)
#'   command_function(com)
#' }
setReplaceMethod("command_name", 
                 signature = c(x = "command"),
                 function(x, value){
                   initialize(x, command_name = value)
                 })

#' @exportMethod command_function
#' @aliases command_function
#' @description \code{command_function}, \code{command_function<-}: getter and setter
#' for the \code{command_function} slot of the object.
#' @rdname command-class
setMethod("command_function", 
          signature = c(x = "command"),
          function(x){ x@command_function })

#' @exportMethod command_function<-
#' @aliases command_function<-
#' @param value The value for the slot.
#' @rdname command-class
setReplaceMethod("command_function", 
                 signature = c(x = "command"),
                 function(x, value){
                   initialize(x, command_function = value)
                 })

#' @exportMethod command_args
#' @aliases command_args
#' @description \code{command_args}, \code{command_args<-}: getter and setter
#' for the \code{command_args} slot of the object.
#' @rdname command-class
setMethod("command_args", 
          signature = c(x = "command"),
          function(x){ x@command_args })

#' @exportMethod command_args<-
#' @aliases command_args<-
#' @param value The value for the slot.
#' @rdname command-class
setReplaceMethod("command_args", 
                 signature = c(x = "command"),
                 function(x, value){
                   initialize(x, command_args = value)
                 })


#' @exportMethod new_command
#' @aliases new_command
#' @description \code{new_command}: create an object of [command-class].
#' @param fun function.
#' @param ... parameters (with names or without names) passed to the function.
#' @param name character(1). Name to slot \code{command_name}.
#' @rdname command-class
setMethod("new_command", 
          signature = c(fun = "function",
                        name = "character"),
          function(fun, ..., name){
            args <- list(...)
            if (length(args) != 0) {
              args_name <- formalArgs(fun)
              if (is.null(names(args))) {
                names(args) <- args_name[1:length(args)]
              } else {
                args_name <- args_name[!args_name %in% names(args)]
                no_name_arg <- which(names(args) == "")
                names(args)[no_name_arg] <- args_name[1:length(no_name_arg)]
              }
            }
            new("command", command_name = name, command_function = fun,
                command_args = args)
          })

#' @importFrom rlang as_label
#' @exportMethod new_command
#' @aliases new_command
#' @rdname command-class
setMethod("new_command", 
          signature = setMissing("new_command",
                                 fun = "function"),
          function(fun, ...){
            name <- rlang::as_label(substitute(fun))
            if (length(name) != 1) {
              name <- paste0(name[2], name[1], name[3])
            }
            new_command(fun, ..., name = name)
          })

#' @exportMethod call_command
#' @aliases call_command
#' @description \code{call_command}: Execute the function (slot \code{command_function})
#' with the parameters (slot \code{command_args}).
#' @family call_commands
#' @rdname command-class
setMethod("call_command", 
          signature = c(x = "command"),
          function(x){
            do.call(command_function(x), command_args(x))
          })
# ==========================================================================
# a class to store a series of 'command' for consisting of a plot of 'ggplot'
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
#' @exportClass ggset
#'
#' @aliases ggset
#'
#' @title Management for 'ggplot' visualzation
#'
#' @description
#' Let each packed "ggplot2" function (packed as [command-class] object)
#' into layers in sequence, allowing post modifications programmatically
#' and visualizing as "ggplot2" plot at any time.
#'
#' @family layerSets
#'
#' @slot layers list with names. Each element of list must be a [command-class] object
#' packed 'ggplot2' function and its args.
#'
#' @rdname ggset-class
#' @order 1
#'
.ggset <- 
  setClass("ggset", 
           contains = c("layerSet"),
           representation = representation(),
           prototype = NULL
           )

# ==========================================================================
# validity
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
setValidity("ggset", 
            function(object){
              recepts <- c("command")
              tip <- paste0("'layer' in 'ggset' must be: ",
                            paste0("'", recepts, "'", collapse = ", "))
              validate_class_in_list(layers(object), recepts, tip)
            })

# ==========================================================================
# method
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
#' @importFrom crayon silver
#' @importFrom crayon yellow
#' @exportMethod show_layers
#' @aliases show_layers
#' @description \code{show_layers}: show functions and parameters in layers
#' with a pretty and readable form.
#' @rdname ggset-class
setMethod("show_layers", 
          signature = c(x = "ggset"),
          function(x){
            layers <- layers(x)
            cat(crayon::silver("layers of", length(layers), "\n"))
            mapply(layers, 1:length(layers),
                   FUN = function(com, seq){
                     cat(crayon::silver("  +++ layer", seq, "+++\n"))
                     cat("  ", crayon::yellow(command_name(com)), "\n",
                         rep(" ", 4), "Args:\n", sep = "")
                     args <- vapply(command_args(com), function(v) class(v)[1], "ch")
                     if (length(args) >= 1) {
                       cat(paste0(paste0(rep(" ", 6), collapse = ""),
                                  names(args), ": ", args), sep = "\n")
                     } else {
                       cat(paste0(paste0(rep(" ", 6), collapse = ""),
                                  "list()"), "\n")
                     }
                     cat("\n")
                   })
            cat("\n")
          })

#' @exportMethod new_ggset
#' @aliases new_ggset
#' @description \code{new_ggset}: Simplified creation of [ggset-class] object.
#' @param ... An arbitrary number of [command-class] object.
#' @rdname ggset-class
#'
#' @examples
#' \dontrun{
#'   data <- data.frame(x = 1:10, y = 1:10)
#'   layer1 <- new_command(ggplot, data)
#'   layer2 <- new_command(geom_point, aes(x = x, y = y))
#'   layer3 <- new_command(labs, x = "x label", y = "y label")
#'   layer4 <- new_command(theme, text = element_text(family = "Times"))
#'   
#'   ## gather
#'   ggset <- new_ggset(layer1, layer2, layer3, layer4)
#'   ggset
#'   ## visualize
#'   p <- call_command(ggset)
#'   p
#'   
#'   ## add layers
#'   layer5 <- new_command(
#'     geom_text,
#'     aes(x = x, y = y, label = paste0("label_", x))
#'   )
#'   layer6 <- new_command(ggtitle, "this is title")
#'   ggset <- add_layers(ggset, layer5, layer6)
#'   call_command(ggset)
#'   
#'   ## delete layers
#'   ggset <- delete_layers(ggset, 5:6)
#'   call_command(ggset)
#'   
#'   ## mutate layer
#'   ggset <- mutate_layer(ggset, "theme",
#'     legend.position = "none",
#'     plot.background = element_rect(fill = "red")
#'   )
#'   ggset <- mutate_layer(ggset, "geom_point",
#'     mapping = aes(x = x, y = y, color = x)
#'   )
#'   call_command(ggset)
#' }
setMethod("new_ggset", 
          signature = c(... = "ANY"),
          function(...){
            args <- list(...)
            names(args) <- vapply(args, command_name, "ch")
            new("ggset", layers = args)
          })

#' @exportMethod mutate_layer
#' @aliases mutate_layer
#' @description \code{mutate_layer}:
#' Pass new parameters or modify pre-existing parameters to the packed function.
#' @param x [ggset-class] object
#' @param layer numeric(1) or character(1). If "character", the name must be unique
#' in slot \code{layers}.
#' @param ... parameters passed to the layer.
#' @rdname ggset-class
setMethod("mutate_layer", 
          signature = c(x = "ggset",
                        layer = "numeric"),
          function(x, layer, ...){
            args <- list(...)
            command <- layers(x)[[ layer ]]
            old <- command_args(command)
            if (length(old) > 0) {
              args <- vecter_unique_by_names(c(args, old))
            }
            layers(x)[[ layer ]] <- 
              do.call(new_command,
                      c(command_function(command), args,
                        name = command_name(command)))
            return(x)
          })

#' @exportMethod mutate_layer
#' @aliases mutate_layer
#' @rdname ggset-class
setMethod("mutate_layer", 
          signature = c(x = "ggset", layer = "character"),
          function(x, layer, ...){
            seq <- which(names(layers(x)) == layer)
            if (length(seq) == 0) {
              stop( paste0("'", layer, "' not found") )
            } else if (length(seq) > 1) {
              stop(paste0("multiple layers of '", layer, "' were found"))
            } else {
              x <- mutate_layer(x, seq, ...)
            }
            return(x)
          })

#' @exportMethod add_layers
#' @aliases add_layers
#' @description \code{add_layers}: add extra [command-class] objects into slot \code{layers}.
#' @param x object contains slot \code{layers}.
#' @param ... extra [command-class] objects.
#' @rdname ggset-class
setMethod("add_layers", 
          signature = c(x = "ggset"),
          function(x, ...){
            args <- list(...)
            names(args) <- vapply(args, command_name, "ch")
            layers(x) <- c(layers(x), args)
            return(x)
          })

#' @exportMethod call_command
#' @aliases call_command
#' @description \code{call_command}: plot as 'ggplot' object.
#' @family call_commands
#' @rdname ggset-class
setMethod("call_command", 
          signature = c(x = "ggset"),
          function(x){
            layers <- layers(x)
            for (i in 1:length(layers)) {
              res <- try( call_command(layers[[i]]), silent = T )
              if (inherits(res, "try-error")) {
                stop(paste0("the 'command' named '", command_name(layers[[i]]),
                            "' (sequence:", i, ") in `layers(x)` caused error."))
              }
              if (i == 1) {
                p <- call_command(layers[[1]])
              } else {
                p <- p + res
              }
            }
            return(p)
          })
# ==========================================================================
# a class to store the filtered dataset from 'project_dataset'
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
#' @exportClass mcn_dataset
#'
#' @aliases mcn_dataset
#'
#' @title Store processed data 
#'
#' @description
#' This is a class object used to store filtered data and formated data.
#' These data would be used for further analysis or visualization.
#'
#' @seealso [dataset-class]
#' @seealso [subscript-class]
#'
#' @slot dataset list with names of [subscript-class]. Store preliminary filtered data.
#' @slot reference list with names of standard names. Store formated data, which is useful
#' reference for further analysis or visualization.
#' @slot backtrack list with names. Recovery stations halfway through data processing.
#'
#' @rdname mcn_dataset-class
#'
.mcn_dataset <- 
  setClass("mcn_dataset", 
           contains = c("dataset", "reference", "backtrack"),
           prototype = NULL
           )

# ==========================================================================
# method
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
#' @exportMethod mcn_dataset
#' @aliases mcn_dataset
#' @description \code{mcn_dataset}, \code{mcn_dataset<-}: getter and setter
#' for the \code{mcn_dataset} slot of the object.
#' @rdname mcn_dataset-class
setMethod("mcn_dataset", 
          signature = c(x = "ANY"),
          function(x){ x@mcn_dataset })

#' @exportMethod mcn_dataset<-
#' @aliases mcn_dataset<-
#' @param value The value for the slot.
#' @rdname mcn_dataset-class
setReplaceMethod("mcn_dataset", 
                 signature = c(x = "ANY"),
                 function(x, value){
                   initialize(x, mcn_dataset = value)
                 })


#' @exportMethod latest
#' @aliases latest
#' @description \code{latest}: get the first data in \code{dataset} slot and
#' format as "tbl". Equals:
#' - \code{latest(object)}
#' - \code{tibble::as_tibble(entity(dataset(x)[[1]]))}.
#' @family datasets
#' @family latests
#' @rdname mcn_dataset-class
setMethod("latest", 
          signature = c(x = "mcn_dataset"),
          function(x){
            tibble::as_tibble(entity(dataset(x)[[1]]))
          })


#' @exportMethod extract_mcnset
#' @aliases extract_mcnset
#' @description \code{extract_mcnset}: For fast extract data in object which containing
#' \code{mcn_dataset} slot. Normally not used.
#' @param subscript See [subscript-class]
#' @rdname mcn_dataset-class
setMethod("extract_mcnset", 
          signature = c(x = "ANY", subscript = "character"),
          function(x, subscript){
            if ( any( subscript == names(dataset(mcn_dataset(x))) ) )
              msframe <- dataset(mcn_dataset(x))[[ subscript ]]
            else
              stop("`subscript` not found in `dataset(mcn_dataset(x))`")
            lst <- list(msframe)
            names(lst) <- subscript
            return(lst)
          })



# ==========================================================================
# MCnebula2 overall object
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
#' @aliases MCnebula2
#'
#' @title Overview of MCnebula2
#'
#' @description 
#'
#' MCnebula2 was used for metabonomics data analysis.
#' It is written in the S4 system of object-oriented programming,
#' and starts with a "class", namely "mcnebula".
#' The whole process takes the "mcnebula" as the operating object to obtain visual
#' results or operating objects.
#'
#' Most methods of MCnebula2 are S4 methods and have the characteristics of
#' parameterized polymorphism, that is, different functions will be used for
#' processing according to different parameters passed to the same method.
#'
#' MCnebula workflow is a complete metabolomics data analysis process,
#' including initial data preprocessing (data format conversion, feature detection),
#' compound identification based on MS/MS,
#' statistical analysis,
#' compound structure and chemical class focusing,
#' multi-level data visualization, output report, etc.
#'
#' It should be noted that the MCnebula2 R package currently cannot realize
#' the entire analysis process of MCnebula workflow.
#' If users want to complete the entire workflow,
#' other software beyond the R console
#' (for example, the MSconvert tool of proteowizard is used for data format conversion,
#' which is a tool widely applicable to metabonomics and proteomics) should be used.
#' This is a pity, but we will gradually integrate all parts of the workflow into this R package
#' in the future to achieve one-stop analysis.
#'
#' The analysis process in R is integrated into the following methods:
#'
#' - [initialize_mcnebula()]
#' - [filter_structure()]
#' - [create_reference()]
#' - [filter_formula()]
#' - [create_stardust_classes()]
#' - [create_features_annotation()]
#' - [cross_filter_stardust()]
#' - [create_nebula_index()]
#' - [compute_spectral_similarity()]
#' - [create_parent_nebula()]
#' - [create_child_nebulae()]
#' - [create_parent_layout()]
#' - [create_child_layouts()]
#' - [activate_nebulae()]
#' - [visualize()]
#' - [binary_comparison()]
#' - ...
#'
#' @details
#'
#' \bold{Overall.} We know that the analysis of untargeted LC-MS/MS dataset generally
#' begin with feature detection.
#' It detects 'peaks' as features in MS1 (MASS level 1) data.
#' Each feature may represents a compound, and assigned with MS2 (MASS level 2) spectra.
#' The MS2 spectra was used to find out the compound identity.
#' The difficulty lies in annotating these features to discover their compound identity,
#' mining out meaningful information, so as to serve further biological research.
#' In addition, the un-targeted LC-MS/MS dataset is general a huge dataset,
#' which leads to time-consuming analysis of the whole process.
#' Herein, a classified visualization method, called MCnebula,
#' was used for addressing these difficulty.
#'
#' MCnebula utilizes the state-of-the-art computer prediction technology,
#' SIRIUS workflow (SIRIUS, ZODIAC, CSI:fingerID, CANOPUS),
#' for compound formula prediction, structure retrieve and classification prediction
#' (\url{https://bio.informatik.uni-jena.de/software/sirius/}).
#' MCnebula integrates an abundance-based classes (ABC) selection algorithm
#' into features annotation:
#' depending on the user,
#' MCnebula focuses chemical classes with more or less features in the dataset
#' (the abundance of classes), visualizes them, and displays the features they involved;
#' these classes can be dominant structural classes or sub-structural classes.
#' With MCnebula, we can switch from untargeted to targeted analysis,
#' focusing precisely on the compound or chemical class of interest to the researcher.
#'
#' \bold{MCnebula2.} The MCnebula2 package itself does not contain any part of 
#' molecular formula prediction, structure prediction and chemical prediction of compounds,
#' so the accuracy of these parts is not involved.
#' MCnebula2 performs downstream analysis by extracting the prediction data from SIRIUS project.
#' The core of MCnebula2 is its chemical filtering algorithm, called ABC selection algorithm.
#'
#' \bold{Chemical structure and formula.} To explain the ABC selection algorithm in detail,
#' we need to start with MS/MS spectral analysis and identification of compounds:
#' The analysis of MS/MS spectrum is a process of inference and prediction.
#' For example, we speculate the composition of elements based on the molecular weight of MS1;
#' combined with the possible fragmentation pattern of MS2 spectrum,
#' we speculate the potential molecular formula of a compound;
#' finally, we look for the exact compound from the compound structure database.
#' Sometimes, this process is full of uncertainty,
#' because there are too many factors that affect the reliability of MS/MS data
#' and the correctness of inference.
#' It can be assumed that there are complex candidates
#' for the potential chemical molecular formula,
#' chemical structure and chemical class behind MS/MS spectrum.
#' Suppose we have these data of candidates now,
#' MCnebula2 extracted these candidates and obtained the unique
#' molecular formula and chemical structure for each MS/MS spectrum
#' based on the highest score of
#' chemical structure prediction; in this process, as most algorithms do,
#' we make a choice based on the score,
#' and only select the result of highest score.
#'
#' The chemical formula and structure candidates can obtain by methods:
#'
#' - [filter_formula()]
#' - [filter_structure()]
#'
#' In order to obtain the best (maybe), corresponding and unique chemical formula
#' and structure from complex candidates, an important intermediate link:
#'
#' - [create_reference()]
#'
#' Above, we talked about chemical molecular formula,
#' chemical structural formula and chemical classes.
#' We obtained the unique chemical molecular formula and chemical structure formula
#' for reference by scoring and ranking.
#' But for chemical classes, we can't adopt such a simple way to get things done.
#' 
#' \bold{Chemical classification.} Chemical classification is a complex system.
#' Here, we only discuss the structure based chemotaxonomy system,
#' because the MS/MS spectrum is more indicative of the structure of compounds
#' than biological activity and other information.
#'
#' According to the division of the overall structure and local structure of compounds,
#' we can call the structural characteristics as the dominant structure and substructure.
#' (\url{https://jcheminf.biomedcentral.com/articles/10.1186/s13321-016-0174-y}).
#' Correspondingly, in the chemical classification system,
#' we can not only classify according to the dominant structure,
#' but also classify according to the substructure.
#' The chemical classification based on the dominant structure of compounds is easy to understand,
#' because we generally define it in this way.
#' For example, we will classify Taxifolin as "flavones", not "phenols",
#' although its local structure has a substructure of "phenol".
#'
#' We hope to classify a compound by its dominant structure rather than substructure,
#' because such classify is more concise and contains more information.
#' However, in the process of MS/MS spectral analysis,
#' we sometimes can only make chemical classification based on the substructure of compounds,
#' which may be due to: uncertainty in the process of structural analysis;
#' it may be an unknown compound; MS/MS spectral fragment information is insufficient.
#' In this case, it is necessary for us to classify the compounds with the aid of
#' substructure information, otherwise we have no knowledge of the compounds
#' for which we cannot obtain dominant structure information.
#'
#' Above, we discussed the complex chemical classification
#' for the substructure and dominant structure of compounds.
#' We must also be clear about the complexity of another aspect of chemotaxonomy,
#' i.e., the hierarchy of classification.
#' This is easy to understand. For example, "Flavones" belongs to its superior, "Flavonoids";
#' its next higher level, "Phynylpropanoids and polyketides";
#' the further upward classification is "organic compounds".
#'
#' \bold{ABC selection.}
#' The above section discusses the inferential prediction of individual MS/MS spectrum.
#' In the un-targeted LC-MS/MS dataset, each feature has a corresponding MS/MS spectrum,
#' and there are thousands of features in total.
#' The ABC selection algorithm regards all features as a whole,
#' examines the number and abundance of features of each chemical classification
#' (classification at different levels, classification of substructure and dominant structure),
#' and then selects representative classes
#' (mainly screening the classes according to the number or abundance range of features)
#' to serve the subsequent analysis.
#' The core methods for ABC selection algorithm are:
#'
#' - [create_stardust_classes()]
#' - [cross_filter_stardust()]
#' - [create_nebula_index()]
#'
#' Whether it is all filtered by the algorithm provided by MCnebula2's function
#' or custom filtered for some chemical classes, we now have a data called 'nebula_index'.
#' This data records a number of chemical classes and the 'features' attributed to them.
#' The subsequent analysis process or visualization will be based on it.
#' Each chemical class is considered as a 'nebula' and its classified 'features'
#' are the components of these 'nebulae'. In the visualization, these 'nebulae' will
#' be visualized as networks. Formally, we call these 'nebulae' formed on the basis
#' of 'nebula_index' data as Child-Nebulae. In comparison, when we put all the
#' 'features' together to form a large network, then this 'nebula' is called Parent-Nebulae.
#'
#' @name ABSTRACT-MCnebula2
NULL
#> NULL

#' @export mcnebula
#' @exportClass mcnebula
#'
#' @aliases mcnebula
#'
#' @title Overall object class of MCnebula2
#'
#' @description For analysis of MCnebula2, all data stored in this class object,
#' all main methods performed with this object.
#'
#' @family nebulae
#'
#' @slot creation_time character(1).
#' @slot ion_mode character(1).
#' @slot melody [melody-class] object.
#' @slot mcn_dataset [mcn_dataset-class] object.
#' @slot statistic_set [statistic_set-class] object.
#' @slot ... Slots inherit from [project-class], [nebula-class], [export-class].
#'
#' @rdname mcnebula-class
#'
mcnebula <- 
  setClass("mcnebula", 
           contains = c("project", "nebula", "export"),
           representation = 
             representation(creation_time = "character",
                            ion_mode = "character",
                            melody = "melody",
                            mcn_dataset = "mcn_dataset",
                            statistic_set = "statistic_set"
                            ),
           prototype = prototype(project_version = "sirius.v4",
                                 project_path = ".",
                                 creation_time = date(),
                                 ion_mode = "pos")
           )

# ==========================================================================
# method
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
#' @exportMethod show
#' @aliases show
#' @rdname mcnebula-class
setMethod("show", 
          signature = c(object = "mcnebula"),
          function(object){
            message( "A project of MCnebula2", ": ",
                    format(object.size(object), units = "MB"))
          })


#' @exportMethod latest
#' @aliases latest
#' @description \code{latest(x, slot, subscript)}: get the data in slot
#' (\code{mcn_dataset(object)} or \code{prject_dataset(object)})
#' and format as 'tbl'.
#' @param x [mcnebula-class] object
#' @param slot Character. Slot name.
#' @param subscript numeric or character. The sequence or name for dataset in the 'list'.
#' @family latests
#' @family subscripts
#' @seealso [tibble::as_tibble()]
#' @rdname mcnebula-class
#'
#' @examples
#' \dontrun{
#'   test <- mcnebula()
#'   class(test)
#'   
#'   test <- mcn_5features
#'   ## slots
#'   ion_mode(test)
#'   project_version(test)
#'   melody(test)
#'   export_name(test)
#'   ## ...
#'   
#'   ## 'fast channel'
#'   palette_label(test)
#'   palette_stat(test)
#'   sample_metadata(test)
#'   ## ...
#' }
setMethod("latest", 
          signature = c(x = "mcnebula", slot = "character",
                        subscript = "ANY"),
          function(x, slot, subscript){
            fun <- match.fun(slot)
            res <- dataset(fun(x))
            if (length(res) == 0)
              return()
            res <- res[[ subscript ]]
            if (is.null(res))
              return()
            else
              return(tibble::as_tibble(entity(res)))
          })


#' @exportMethod latest
#' @description \code{latest()}: get the default parameters for the method \code{latest}.
#' @rdname mcnebula-class
setMethod("latest", 
          signature = setMissing("latest"),
          function(){
            list(slot = "mcn_dataset",
                 subscript = 1)
          })

#' @exportMethod latest
#' @description \code{latest(x, ...)}: use the default parameters whatever 'missing'
#' while performing the method \code{latest}.
#' @rdname mcnebula-class
setMethod("latest", 
          signature = c(x = "mcnebula"),
          function(x, slot, subscript){
            reCallMethod("latest", .fresh_param(latest()))
          })


#' @exportMethod creation_time
#' @aliases creation_time
#' @description \code{creation_time}, \code{creation_time<-}: getter and setter
#' for the \code{creation_time} slot of the object.
#' @rdname mcnebula-class
setMethod("creation_time", 
          signature = c(x = "mcnebula"),
          function(x){ x@creation_time })

#' @exportMethod creation_time<-
#' @aliases creation_time<-
#' @param value The value for the slot.
#' @rdname mcnebula-class
setReplaceMethod("creation_time", 
                 signature = c(x = "mcnebula"),
                 function(x, value){
                   initialize(x, creation_time = value)
                 })


#' @exportMethod ion_mode
#' @aliases ion_mode
#' @description \code{ion_mode}, \code{ion_mode<-}: getter and setter
#' for the \code{ion_mode} slot of the object.
#' @rdname mcnebula-class
setMethod("ion_mode", 
          signature = c(x = "mcnebula"),
          function(x){ x@ion_mode })

#' @exportMethod ion_mode<-
#' @aliases ion_mode<-
#' @param value The value for the slot.
#' @rdname mcnebula-class
setReplaceMethod("ion_mode", 
                 signature = c(x = "mcnebula"),
                 function(x, value){
                   initialize(x, ion_mode = value)
                 })

# ==========================================================================
# get infrustructure object
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
#' @exportMethod palette_set
#' @aliases palette_set
#' @description  \code{palette_set}, \code{palette_gradient}, \code{palette_stat},
#' \code{palette_col}: fast channel to obtain the downstream slot.
#' For \code{palette_set}, e.g., getter for the \code{palette_set} slot in sub-object
#' of \code{melody} slot of the object. Equals:
#' - \code{palette_set(melody(object))}
#' - \code{palette_set(object)}.
#' @rdname mcnebula-class
setMethod("palette_set", 
          signature = c(x = "mcnebula"),
          function(x){
            palette_set(melody(x))
          })

#' @exportMethod palette_gradient
#' @aliases palette_gradient
#' @rdname mcnebula-class
setMethod("palette_gradient", 
          signature = c(x = "mcnebula"),
          function(x){
            palette_gradient(melody(x))
          })

#' @exportMethod palette_stat
#' @aliases palette_stat
#' @rdname mcnebula-class
setMethod("palette_stat", 
          signature = c(x = "mcnebula"),
          function(x){
            palette_stat(melody(x))
          })

#' @exportMethod palette_col
#' @aliases palette_col
#' @rdname mcnebula-class
setMethod("palette_col", 
          signature = c(x = "mcnebula"),
          function(x){
            palette_col(melody(x))
          })

#' @exportMethod palette_label
#' @aliases palette_label
#' @rdname mcnebula-class
setMethod("palette_label", 
          signature = c(x = "mcnebula"),
          function(x){
            palette_label(melody(x))
          })


#' @exportMethod reference
#' @aliases reference
#' @description  \code{reference}: fast channel to obtain
#' the downstream slot, getter
#' for the \code{reference} slot in sub-object
#' of \code{mcn_dataset} slot of the object. Equals:
#' - \code{reference(mcn_dataset(object))} 
#' - \code{reference(object)}
#' @rdname mcnebula-class
setMethod("reference", 
          signature = c(x = "mcnebula"),
          function(x){
            reference(mcn_dataset(x))
          })

#' @exportMethod specific_candidate
#' @aliases specific_candidate
#' @description \code{specific_candidate}, \code{hierarchy}, \code{stardust_classes},
#' \code{nebula_index}, \code{spectral_similarity}, \code{features_annotation},
#' \code{features_quantification}, \code{sample_metadata}:
#' fast channel to obtain data (mostly 'tbl' or 'data.frame')
#' inside the downstream slot ('list'). e.g., getter
#' for the data named \code{specific_candidate} in
#' \code{reference} slot (a 'list') in sub-object
#' of \code{mcn_dataset} slot of the object. Equals:
#' - \code{reference(mcn_dataset(object))$specific_candidate}
#' - \code{specific_candidate(object)}.
#' @rdname mcnebula-class
setMethod("specific_candidate", 
          signature = c(x = "mcnebula"),
          function(x){
            reference(x)[[ "specific_candidate" ]]
          })

#' @exportMethod hierarchy
#' @aliases hierarchy
#' @rdname mcnebula-class
setMethod("hierarchy", 
          signature = c(x = "mcnebula"),
          function(x){
            reference(x)[[ "hierarchy" ]]
          })

#' @exportMethod stardust_classes
#' @aliases stardust_classes
#' @rdname mcnebula-class
setMethod("stardust_classes", 
          signature = c(x = "mcnebula"),
          function(x){
            reference(x)[[ "stardust_classes" ]]
          })

#' @exportMethod nebula_index
#' @aliases nebula_index
#' @rdname mcnebula-class
setMethod("nebula_index", 
          signature = c(x = "mcnebula"),
          function(x){
            reference(x)[[ "nebula_index" ]]
          })

#' @exportMethod spectral_similarity
#' @aliases spectral_similarity
#' @rdname mcnebula-class
setMethod("spectral_similarity", 
          signature = c(x = "mcnebula"),
          function(x){
            reference(x)[[ "spectral_similarity" ]]
          })

#' @exportMethod spectral_similarity<-
#' @aliases spectral_similarity<-
#' @description  \code{spectral_similarity<-}, \code{features_quantification<-},
#' \code{sample_metadata<-}: fast channel to replace
#' data (mostly 'tbl' or 'data.frame') inside the downstream slot ('list'). e.g., setter
#' for the data named \code{spectral_similarity} in
#' \code{reference} slot (a 'list') in sub-object
#' of \code{mcn_dataset} slot of the object. Similar:
#' - \code{reference(mcn_dataset(object))$spectral_similarity<-}
#' - \code{spectral_similarity(object)<-}.
#'
#' But the latter not only replace and also validate.
#' @rdname mcnebula-class
setReplaceMethod("spectral_similarity", 
                 signature = c(x = "mcnebula"),
                 function(x, value){
                   .check_columns(value, list(".features_id1", ".features_id2",
                                              "similarity"),
                                  "spectral_similarity")
                   reference(mcn_dataset(x))$spectral_similarity <- value
                   return(x)
                 })

#' @exportMethod features_annotation
#' @aliases features_annotation
#' @rdname mcnebula-class
setMethod("features_annotation", 
          signature = c(x = "mcnebula"),
          function(x){
            reference(x)[[ "features_annotation" ]]
          })

#' @exportMethod features_quantification
#' @aliases features_quantification
#' @rdname mcnebula-class
setMethod("features_quantification", 
          signature = c(x = "mcnebula"),
          function(x){
            reference(x)[[ "features_quantification" ]]
          })

.features_quantification <- 
  function(x){
    data <- features_quantification(x)
    .features_id <- data$.features_id
    data$.features_id <- NULL
    data <- as.matrix(data)
    rownames(data) <- .features_id
    data
  }

#' @importFrom dplyr select
#' @exportMethod features_quantification<-
#' @aliases features_quantification<-
#' @rdname mcnebula-class
setReplaceMethod("features_quantification", 
                 signature = c(x = "mcnebula"),
                 function(x, value){
                   .check_columns(value, list(".features_id"),
                                  "features_quantification")
                   .check_type(dplyr::select(value, -.features_id),
                               "numeric", "features_quantification")
                   reference(mcn_dataset(x))$features_quantification <- value
                   return(x)
                 })

#' @exportMethod sample_metadata
#' @aliases sample_metadata
#' @rdname mcnebula-class
setMethod("sample_metadata", 
          signature = c(x = "mcnebula"),
          function(x){
            reference(x)[[ "sample_metadata" ]]
          })

#' @exportMethod sample_metadata<-
#' @aliases sample_metadata<-
#' @rdname mcnebula-class
setReplaceMethod("sample_metadata", 
                 signature = c(x = "mcnebula"),
                 function(x, value){
                   .check_data(x, list(features_quantification =
                                       "features_quantification"), "(x) <-")
                   .check_columns(value, list("sample", "group"), "sample_metadata")
                   if (any(!value$sample %in% colnames(features_quantification(x))))
                     stop(paste0("the name in 'sample' column in 'sample_metadata' ",
                                 "must all involved in 'features_quantification'"))
                   reference(mcn_dataset(x))$sample_metadata <- value
                   return(x)
                 })

#' @exportMethod classification
#' @aliases classification
#' @description  \code{classification}: fast channel to obtain
#' data deeply inside the downstream slot ('list'), getter
#' for the data named \code{".canopus"} in
#' \code{dataset} slot (a 'list') in sub-object
#' of \code{project_dataset} slot of the object. Equals:
#' - \code{tibble::as_tibble(entity(dataset(project_dataset(object))$.canopus))}
#' - \code{classification(object)}.
#' @rdname mcnebula-class
setMethod("classification", 
          signature = c(x = "mcnebula"),
          function(x){
            res <- dataset(project_dataset(x))[[ ".canopus" ]]
            if (is.null(res))
              return()
            else
              return(dplyr::as_tibble(entity(res)))
          })
# ==========================================================================
# a class to store hex color set.
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
#' @exportClass melody
#'
#' @aliases melody
#'
#' @title Mutiple color palette in hexadecimal code
#'
#' @description
#' This is a class object store Hex color used for visualization.
#' In default (use [initialize_mcnebula()] to initialize the object),
#' these these Hex color in each palette were get from package \code{ggsci}.
#' Most of these palette in this package would passed to [ggplot2::scale_fill_manual] for
#' filling color. So, let these Hex color with names may work well to specify target.
#'
#' @seealso [ggsci::pal_simpsons()], [ggsci::pal_igv()], [ggsci::pal_ucscgb()],
#' [ggsci::pal_d3()]...
#'
#' @slot palette_set character with names or not. Hex color.
#' @slot palette_gradient character with names or not. Hex color.
#' @slot palette_stat character with names or not. Hex color.
#' @slot palette_col character with names or not. Hex color.
#' @slot palette_label character with names or not. Hex color.
#'
#' @rdname melody-class
#'
.melody <- 
  setClass("melody", 
           contains = character(),
           representation = 
             representation(palette_set = "character",
                            palette_gradient = "character",
                            palette_stat = "character",
                            palette_col = "character",
                            palette_label = "character"
                            ),
           prototype = NULL
  )

# ==========================================================================
# method
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
#' @exportMethod show
#' @aliases show
#' @rdname melody-class
setMethod("show", 
          signature = c(object= "melody"),
          function(object){
            .show(object)
          })


#' @exportMethod melody
#' @aliases melody
#' @description \code{melody}, \code{melody<-}: getter and setter
#' for the \code{melody} slot of the object.
#' @rdname melody-class
setMethod("melody", 
          signature = c(x = "ANY"),
          function(x){ x@melody })

#' @exportMethod melody<-
#' @aliases melody<-
#' @param value The value for the slot.
#' @rdname melody-class
setReplaceMethod("melody", 
                 signature = c(x = "ANY"),
                 function(x, value){
                   initialize(x, melody = value)
                 })


#' @exportMethod palette_set
#' @aliases palette_set
#' @description \code{palette_set}, \code{palette_set<-}: getter and setter
#' for the \code{palette_set} slot of the object.
#' @rdname melody-class
setMethod("palette_set", 
          signature = c(x = "melody"),
          function(x){ x@palette_set })

#' @exportMethod palette_set<-
#' @aliases palette_set<-
#' @param value The value for the slot.
#' @rdname melody-class
setReplaceMethod("palette_set", 
                 signature = c(x = "melody"),
                 function(x, value){
                   initialize(x, palette_set = value)
                 })


#' @exportMethod palette_gradient
#' @aliases palette_gradient
#' @description \code{palette_gradient}, \code{palette_gradient<-}: getter and setter
#' for the \code{palette_gradient} slot of the object.
#' @rdname melody-class
setMethod("palette_gradient", 
          signature = c(x = "melody"),
          function(x){ x@palette_gradient })

#' @exportMethod palette_gradient<-
#' @aliases palette_gradient<-
#' @param value The value for the slot.
#' @rdname melody-class
setReplaceMethod("palette_gradient", 
                 signature = c(x = "melody"),
                 function(x, value){
                   initialize(x, palette_gradient = value)
                 })


#' @exportMethod palette_stat
#' @aliases palette_stat
#' @description \code{palette_stat}, \code{palette_stat<-}: getter and setter
#' for the \code{palette_stat} slot of the object.
#' @rdname melody-class
setMethod("palette_stat", 
          signature = c(x = "melody"),
          function(x){ x@palette_stat })

#' @exportMethod palette_stat<-
#' @aliases palette_stat<-
#' @param value The value for the slot.
#' @rdname melody-class
setReplaceMethod("palette_stat", 
                 signature = c(x = "melody"),
                 function(x, value){
                   initialize(x, palette_stat = value)
                 })


#' @exportMethod palette_col
#' @aliases palette_col
#' @description \code{palette_col}, \code{palette_col<-}: getter and setter
#' for the \code{palette_col} slot of the object.
#' @rdname melody-class
setMethod("palette_col", 
          signature = c(x = "melody"),
          function(x){ x@palette_col })

#' @exportMethod palette_col<-
#' @aliases palette_col<-
#' @param value The value for the slot.
#' @rdname melody-class
setReplaceMethod("palette_col", 
                 signature = c(x = "melody"),
                 function(x, value){
                   initialize(x, palette_col = value)
                 })


#' @exportMethod palette_label
#' @aliases palette_label
#' @description \code{palette_label}, \code{palette_label<-}: getter and setter
#' for the \code{palette_label} slot of the object.
#' @rdname melody-class
setMethod("palette_label", 
          signature = c(x = "melody"),
          function(x){ x@palette_label })

#' @exportMethod palette_label<-
#' @aliases palette_label<-
#' @param value The value for the slot.
#' @rdname melody-class
setReplaceMethod("palette_label", 
                 signature = c(x = "melody"),
                 function(x, value){
                   initialize(x, palette_label = value)
                 })
# ==========================================================================
# msframe: class based on data.frame
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
#' @exportClass msframe
#'
#' @aliases msframe
#'
#' @title format and filter table data
#'
#' @description
#' Class for table data manipulation inside this package.
#'
#' @family subscripts
#'
#' @slot entity data.frame.
#' @slot subscript character(1). See [subscript-class].
#'
#' @rdname msframe-class
#'
.msframe <- 
  setClass("msframe", 
           contains = "subscript",
           representation = 
             representation(entity = "data.frame"),
           prototype = NULL
  )

# ==========================================================================
# methods
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
#' @exportMethod show
#' @aliases show
#' @rdname msframe-class
setMethod("show", 
          signature = c(object = "msframe"),
          function(object){
            cat( "A class of \"msframe\" of", subscript(object), "\n")
          })


#' @exportMethod msframe
#' @aliases msframe
#' @description \code{msframe}, \code{msframe<-}: getter and setter
#' for the \code{msframe} slot of the object.
#' @rdname msframe-class
setMethod("msframe", 
          signature = c(x = "ANY"),
          function(x){ x@msframe })

#' @exportMethod msframe<-
#' @aliases msframe<-
#' @param value The value for the slot.
#' @rdname msframe-class
setReplaceMethod("msframe", 
                 signature = c(x = "ANY"),
                 function(x, value){
                   initialize(x, msframe = value)
                 })


#' @exportMethod latest
#' @aliases latest
#' @description \code{latest}: get data inside \code{entity(object)} and format as
#' 'tbl'.
#' @family latests
#' @seealso [tibble::as_tibble()]
#' @rdname msframe-class
setMethod("latest", 
          signature = c(x = "msframe"),
          function(x){
            tibble::as_tibble(entity(x))
          })


#' @exportMethod entity
#' @aliases entity
#' @description \code{entity}, \code{entity<-}: getter and setter
#' for the \code{entity} slot of the object.
#' @rdname msframe-class
setMethod("entity", 
          signature = c(x = "msframe"),
          function(x){ x@entity })

#' @exportMethod entity<-
#' @aliases entity<-
#' @param value The value for the slot.
#' @rdname msframe-class
setReplaceMethod("entity", 
                 signature = c(x = "msframe"),
                 function(x, value){
                   initialize(x, entity = value)
                 })


#' @exportMethod format_msframe
#' @aliases format_msframe
#' @rdname msframe-class
setMethod("format_msframe", 
          signature = setMissing("format_msframe",
                                 x = "msframe",
                                 fun_format = "function"),
          function(x, fun_format){
            entity(x) <- format_msframe(entity(x), fun_format = fun_format)
            return(x)
          })

#' @exportMethod format_msframe
#' @aliases format_msframe
#' @rdname msframe-class
setMethod("format_msframe", 
          signature = setMissing("format_msframe",
                                 x = "data.frame",
                                 fun_format = "function"),
          function(x, fun_format){
            results <- try(fun_format(x), silent = T)
            if (!inherits(results, "try-error")) {
              x[[ ".candidates_id" ]] <- results
            }
            return(x)
          })


#' @exportMethod format_msframe
#' @aliases format_msframe
#' @rdname msframe-class
setMethod("format_msframe", 
          signature = setMissing("format_msframe",
                                 x = "msframe",
                                 names = "character",
                                 types = "character"),
          function(x, names, types){
            if( !is.character(names(names)) )
              stop( "the `names` is unformat" )
            if( !is.character(names(types)) )
              stop( "the `types` is unformat" )
            .format_msframe(x, names, types)
          })

#' @exportMethod format_msframe
#' @aliases format_msframe
#' @rdname msframe-class
setMethod("format_msframe", 
          signature = setMissing("format_msframe",
                                 x = "msframe"),
          function(x){
            names <- .get_attribute_name_sirius.v4()
            types <- .get_attribute_type_sirius.v4()
            .format_msframe(x, names, types)
          })

#' @exportMethod format_msframe
#'
#' @aliases format_msframe
#'
#' @description
#' \code{format_msframe}:
#'
#' @param x [msframe-class] object.
#' @param names character with names.
#' e.g., c(tani.score = "tanimotoSimilarity", mol.formula = "molecularFormula").
#' @param fun_names function to get names.
#' e.g., \code{MCnebula2:::.get_attribute_name_sirius.v4()}
#' @param types character with names.
#' e.g., c(tani.score = "numeric", mol.formula = "character").
#' @param fun_types function to get types.
#' e.g., \code{MCnebula2:::.get_attribute_type_sirius.v4()}
#' @param fun_format function to format slot \code{entity}.
#' e.g., \code{MCnebula2:::.format_msframe()}
#'
#' @rdname msframe-class
#'
setMethod("format_msframe", 
          signature = setMissing("format_msframe",
                                 x = "msframe",
                                 fun_names = "function",
                                 fun_types = "function"),
          function(x, fun_names, fun_types){
            .format_msframe(x, fun_names(), fun_types())
          })

.format_msframe <- 
  function(x, names, types){
    if( any(names(names) == "...sig") ) {
      rs <- which( names == subscript(x) & names(names) == "...sig")
      if (length(rs) != 0) {
        rs <- rs + 1
        re <- length(names)
        for( i in rs:length(names) ){
          if( names(names)[i] == "...sig" ) {
            re <- i - 1
            break
          }
        }
        names <- c(names[rs:re], names)
      }
      names <- vec_unique_by_value(names)
      names <- names[names(names) != "...sig"]
    }
    x <- .format_msframe_names(x, names)
    names <- names[names(names) %in% colnames(entity(x))]
    .format_msframe_types(x, names, types)
  }

.format_msframe_names <- 
  function(x, names){
    pattern <- paste0("^", names, "$")
    colnames(entity(x)) <-
      mapply_rename_col(pattern, names(names), colnames(entity(x)))
    return(x)
  }

.format_msframe_types <- 
  function(x, names, types){
    for (i in names(names)) {
      if (i %in% names(types))
        target_type <- types[[i]]
      else
        target_type <- "character"
      fun <- match.fun(paste0("is.", target_type))
      if ( !fun(entity(x)[[i]]) ){
        fun <- match.fun(paste0("as.", target_type))
        entity(x)[[i]] <- fun(entity(x)[[i]])
      }
    }
    return(x)
  }


#' @exportMethod filter_msframe
#' @aliases filter_msframe
#' @rdname msframe-class
setMethod("filter_msframe", 
          signature = setMissing("filter_msframe",
                                 x = "msframe", fun_filter = "function"),
          function(x, fun_filter, ...){
            filter_msframe(x, fun_filter = fun_filter,
                           f = ~ .features_id, ...)
          })

#' @exportMethod filter_msframe
#'
#' @aliases filter_msframe
#'
#' @description \code{filter_msframe}: filter data in slot \code{entity} (data.frame).
#' @note The class is not for normal use of the package.
#'
#' @param x [msframe-class] object.
#' @param fun_filter function used to filter the slot \code{entity} (data.frame).
#' e.g., \code{dplyr::filter()}, \code{head()}.
#' @param f formula passed to \code{split()}.
#' @param ... extra parameter passed to fun_filter.
#'
#' @rdname msframe-class
#'
setMethod("filter_msframe", 
          signature = setMissing("filter_msframe",
                                 x = "msframe", fun_filter = "function",
                                 f = "formula"),
          function(x, fun_filter, f, ...){
            .message_info("msframe", "filter_msframe",
                      paste0("group_by: ", paste0(f, collapse = " "))
            )
            entity <- lapply( split(entity(x), f = f), FUN = fun_filter, ...)
            entity(x) <- data.table::rbindlist(entity, fill = T)
            return(x)
          })

# ==========================================================================
# a class to store network component
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
#' @exportClass parent_nebula
#'
#' @aliases parent_nebula
#'
#' @description \code{parent_nebula}: Store data for visualization of
#' Parent-Nebula.
#'
#' @rdname nebula-class
#'
.parent_nebula <- 
  setClass("parent_nebula", 
           contains = character(),
           representation = 
             representation(igraph = "ANY",
                            tbl_graph = "ANY",
                            layout_ggraph = "ANY",
                            ggset = "ggset"
                            ),
           prototype = NULL
  )

#' @exportClass child_nebulae
#'
#' @aliases child_nebulae
#'
#' @description \code{child_nebulae}: store data for visualization of
#' Child-Nebulae.
#'
#' @slot igraph "igraph" object or its list. See [igraph::graph_from_data_frame()].
#' The slot contains edges and nodes data of Child-Nebulae or Parent-Nebula.
#' The "igraph" object can be output use [igraph::write_graph()] as ".graphml" file,
#' which belong to a network data format that can be operated by other software such as
#' Cytoscape (\url{https://cytoscape.org/}).
#'
#' @slot tbl_graph "tbl_graph" object or its list. See [tidygraph::as_tbl_graph()].
#' Converted from slot \code{igraph}.
#'
#' @slot layout_ggraph "layout_ggraph" object or its list. See [ggraph::create_layout()].
#' Create from slot \code{tbl_graph}, passed to [ggraph::ggraph()] for visualization.
#'
#' @slot grid_layout "layout" object. See [grid::grid.layout()].
#' Grid layout for position of each Child-Nebula to visualize.
#'
#' @slot viewports list with names. Each element must be "viewport" object.
#' See [grid::viewport()]. Position for each Child-Nebula to visualize.
#'
#' @slot panel_viewport "viewport" object. See [grid::viewport()]. For visualization,
#' the position to place overall Child-Nebulae.
#'
#' @slot legend_viewport "viewport" object. See [grid::viewport()]. For visualization,
#' the position to place legend.
#'
#' @slot ggset [ggset-class] object or its list with names. Each [ggset-class] object
#' can be visualized directly use [call_command()].
#'
#' @slot structures_grob list with names. Each element is a "grob" object.
#' See [grid::grob()]. Use [grid::grid.draw()] to visualize the chemical structure.
#'
#' @slot nodes_ggset list of [ggset-class] object. For drawing each node of 'features'
#' ('features' means the detected peaks while processing LC-MS data)
#' with annotation. Use [call_command()] to visualize the [ggset-class].
#'
#' @slot nodes_grob list of "grob" object. Converted from slot \code{nodes_ggset} with slot
#' \code{structures_grob}. Use [grid::grid.draw()] to visualize the "grob".
#'
#' @slot ppcp_data list with names. Each element is a data.frame. This is an
#' annotation data of 'features' which would be visualize in nodes border
#' as a radial bar plot. \code{ppcp_data}, i.e., posterior probability of
#' classification prediction. See [filter_ppcp()].
#'
#' @slot ration_data list with names. Each element is a data.frame. This is an
#' annotation data of 'features' which would be visualize in nodes nucleus as
#' ring plot. Generally, \code{ration_data} is the statistic data for samples.
#'
#' @slot ggset_annotate a list of [ggset-class] object. The annotated Child-Nebulae
#' gathered from slot \code{ggset} and slot \code{nodes_grob}. 
#' Use [call_command()] to visualize the [ggset-class]. Be care, the object
#' sometimes is too large that need lot of time to loading for visualization.
#'
#' @rdname nebula-class
#'
.child_nebulae <- 
  setClass("child_nebulae", 
           contains = character(),
           representation = 
             representation(igraph = "list",
                            tbl_graph = "list",
                            layout_ggraph = "list",
                            grid_layout = "ANY",
                            viewports = "list",
                            panel_viewport = "ANY",
                            legend_viewport = "ANY",
                            ggset = "list",
                            structures_grob = "list",
                            nodes_ggset = "list",
                            nodes_grob = "list",
                            ppcp_data = "list",
                            ration_data = "list",
                            ggset_annotate = "list"
                            ),
           prototype = NULL
  )

#' @exportClass nebula
#'
#' @aliases nebula
#'
#' @title Visualization component of chemical Nebulae/Nebula
#'
#' @description This class store multiple components for visualization.
#'
#' @family nebulae
#'
#' @slot parent_nebula [parent_nebula-class] object.
#' @slot child_nebulae [child_nebulae-class] object.
#'
#' @rdname nebula-class
#' @order 1
#'
.nebula <- 
  setClass("nebula", 
           contains = character(),
           representation = 
             representation(parent_nebula = "parent_nebula",
                            child_nebulae = "child_nebulae"
                            ),
           prototype = NULL
           )

# ==========================================================================
# method
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
#' @exportMethod parent_nebula
#' @aliases parent_nebula
#' @rdname nebula-class
setMethod("show", 
          signature = c(object = "parent_nebula"),
          function(object){
            .show_nebulae_data(object)
          })

#' @exportMethod child_nebulae
#' @aliases child_nebulae
#' @rdname nebula-class
setMethod("show", 
          signature = c(object = "child_nebulae"),
          function(object){
            .show_nebulae_data(object)
          })

.show_nebulae_data <- 
  function(object){
    slots_mapply(object, function(slot, name){
                   if (is(slot, "viewport")) {
                     num <- 1
                   } else if (is.list(slot)) {
                     num <- length(slot)
                   } else {
                     if (is.null(slot))
                       num <- 0
                     else
                       num <- 1
                   }
                   if (num == 0 | is(slot, "name")) 
                     return()
                   cat(name, ": ", class(slot)[1], " of ", num,
                       "\n", sep = "")
                      })
  }


#' @exportMethod parent_nebula
#' @aliases parent_nebula
#' @description \code{parent_nebula}, \code{parent_nebula<-}: getter and setter
#' for the \code{parent_nebula} slot of the object.
#' @rdname nebula-class
setMethod("parent_nebula", 
          signature = c(x = "ANY"),
          function(x){ x@parent_nebula })

#' @exportMethod parent_nebula<-
#' @aliases parent_nebula<-
#' @param value The value for the slot.
#' @rdname nebula-class
setReplaceMethod("parent_nebula", 
                 signature = c(x = "ANY"),
                 function(x, value){
                   initialize(x, parent_nebula = value)
                 })

#' @exportMethod child_nebulae
#' @aliases child_nebulae
#' @description \code{child_nebulae}, \code{child_nebulae<-}: getter and setter
#' for the \code{child_nebulae} slot of the object.
#' @rdname nebula-class
setMethod("child_nebulae", 
          signature = c(x = "ANY"),
          function(x){ x@child_nebulae })

#' @exportMethod child_nebulae<-
#' @aliases child_nebulae<-
#' @param value The value for the slot.
#' @rdname nebula-class
setReplaceMethod("child_nebulae", 
                 signature = c(x = "ANY"),
                 function(x, value){
                   initialize(x, child_nebulae = value)
                 })


#' @exportMethod igraph
#' @aliases igraph
#' @description \code{igraph}, \code{igraph<-}: getter and setter
#' for the \code{igraph} slot of the object.
#' @rdname nebula-class
setMethod("igraph", 
          signature = c(x = "ANY"),
          function(x){ x@igraph })

#' @exportMethod igraph<-
#' @aliases igraph<-
#' @param value The value for the slot.
#' @rdname nebula-class
setReplaceMethod("igraph", 
                 signature = c(x = "ANY"),
                 function(x, value){
                   initialize(x, igraph = value)
                 })


#' @exportMethod tbl_graph
#' @aliases tbl_graph
#' @description \code{tbl_graph}, \code{tbl_graph<-}: getter and setter
#' for the \code{tbl_graph} slot of the object.
#' @rdname nebula-class
setMethod("tbl_graph", 
          signature = c(x = "ANY"),
          function(x){ x@tbl_graph })

#' @exportMethod tbl_graph<-
#' @aliases tbl_graph<-
#' @param value The value for the slot.
#' @rdname nebula-class
setReplaceMethod("tbl_graph", 
                 signature = c(x = "ANY"),
                 function(x, value){
                   initialize(x, tbl_graph = value)
                 })


#' @exportMethod layout_ggraph
#' @aliases layout_ggraph
#' @description \code{layout_ggraph}, \code{layout_ggraph<-}: getter and setter
#' for the \code{layout_ggraph} slot of the object.
#' @rdname nebula-class
setMethod("layout_ggraph", 
          signature = c(x = "ANY"),
          function(x){ x@layout_ggraph })

#' @exportMethod layout_ggraph<-
#' @aliases layout_ggraph<-
#' @param value The value for the slot.
#' @rdname nebula-class
setReplaceMethod("layout_ggraph", 
                 signature = c(x = "ANY"),
                 function(x, value){
                   initialize(x, layout_ggraph = value)
                 })


#' @exportMethod grid_layout
#' @aliases grid_layout
#' @description \code{grid_layout}, \code{grid_layout<-}: getter and setter
#' for the \code{grid_layout} slot of the object.
#' @rdname nebula-class
setMethod("grid_layout", 
          signature = c(x = "ANY"),
          function(x){ x@grid_layout })

#' @exportMethod grid_layout<-
#' @aliases grid_layout<-
#' @param value The value for the slot.
#' @rdname nebula-class
setReplaceMethod("grid_layout", 
                 signature = c(x = "ANY"),
                 function(x, value){
                   initialize(x, grid_layout = value)
                 })


#' @exportMethod viewports
#' @aliases viewports
#' @description \code{viewports}, \code{viewports<-}: getter and setter
#' for the \code{viewports} slot of the object.
#' @rdname nebula-class
setMethod("viewports", 
          signature = c(x = "ANY"),
          function(x){ x@viewports })

#' @exportMethod viewports<-
#' @aliases viewports<-
#' @param value The value for the slot.
#' @rdname nebula-class
setReplaceMethod("viewports", 
                 signature = c(x = "ANY"),
                 function(x, value){
                   initialize(x, viewports = value)
                 })


#' @exportMethod ggset
#' @aliases ggset
#' @description \code{ggset}, \code{ggset<-}: getter and setter
#' for the \code{ggset} slot of the object.
#' @rdname nebula-class
setMethod("ggset", 
          signature = c(x = "ANY"),
          function(x){ x@ggset })

#' @exportMethod ggset<-
#' @aliases ggset<-
#' @param value The value for the slot.
#' @rdname nebula-class
setReplaceMethod("ggset", 
                 signature = c(x = "ANY"),
                 function(x, value){
                   initialize(x, ggset = value)
                 })


#' @exportMethod panel_viewport
#' @aliases panel_viewport
#' @description \code{panel_viewport}, \code{panel_viewport<-}: getter and setter
#' for the \code{panel_viewport} slot of the object.
#' @rdname nebula-class
setMethod("panel_viewport", 
          signature = c(x = "ANY"),
          function(x){ x@panel_viewport })

#' @exportMethod panel_viewport<-
#' @aliases panel_viewport<-
#' @param value The value for the slot.
#' @rdname nebula-class
setReplaceMethod("panel_viewport", 
                 signature = c(x = "ANY"),
                 function(x, value){
                   initialize(x, panel_viewport = value)
                 })


#' @exportMethod legend_viewport
#' @aliases legend_viewport
#' @description \code{legend_viewport}, \code{legend_viewport<-}: getter and setter
#' for the \code{legend_viewport} slot of the object.
#' @rdname nebula-class
setMethod("legend_viewport", 
          signature = c(x = "ANY"),
          function(x){ x@legend_viewport })

#' @exportMethod legend_viewport<-
#' @aliases legend_viewport<-
#' @param value The value for the slot.
#' @rdname nebula-class
setReplaceMethod("legend_viewport", 
                 signature = c(x = "ANY"),
                 function(x, value){
                   initialize(x, legend_viewport = value)
                 })


#' @exportMethod structures_grob
#' @aliases structures_grob
#' @description \code{structures_grob}, \code{structures_grob<-}: getter and setter
#' for the \code{structures_grob} slot of the object.
#' @rdname nebula-class
setMethod("structures_grob", 
          signature = c(x = "ANY"),
          function(x){ x@structures_grob })

#' @exportMethod structures_grob<-
#' @aliases structures_grob<-
#' @param value The value for the slot.
#' @rdname nebula-class
setReplaceMethod("structures_grob", 
                 signature = c(x = "ANY"),
                 function(x, value){
                   initialize(x, structures_grob = value)
                 })


#' @exportMethod nodes_ggset
#' @aliases nodes_ggset
#' @description \code{nodes_ggset}, \code{nodes_ggset<-}: getter and setter
#' for the \code{nodes_ggset} slot of the object.
#' @rdname nebula-class
setMethod("nodes_ggset", 
          signature = c(x = "ANY"),
          function(x){ x@nodes_ggset })

#' @exportMethod nodes_ggset<-
#' @aliases nodes_ggset<-
#' @param value The value for the slot.
#' @rdname nebula-class
setReplaceMethod("nodes_ggset", 
                 signature = c(x = "ANY"),
                 function(x, value){
                   initialize(x, nodes_ggset = value)
                 })


#' @exportMethod nodes_grob
#' @aliases nodes_grob
#' @description \code{nodes_grob}, \code{nodes_grob<-}: getter and setter
#' for the \code{nodes_grob} slot of the object.
#' @rdname nebula-class
setMethod("nodes_grob", 
          signature = c(x = "ANY"),
          function(x){ x@nodes_grob })

#' @exportMethod nodes_grob<-
#' @aliases nodes_grob<-
#' @param value The value for the slot.
#' @rdname nebula-class
setReplaceMethod("nodes_grob", 
                 signature = c(x = "ANY"),
                 function(x, value){
                   initialize(x, nodes_grob = value)
                 })


#' @exportMethod ppcp_data
#' @aliases ppcp_data
#' @description \code{ppcp_data}, \code{ppcp_data<-}: getter and setter
#' for the \code{ppcp_data} slot of the object.
#' @rdname nebula-class
setMethod("ppcp_data", 
          signature = c(x = "ANY"),
          function(x){ x@ppcp_data })

#' @exportMethod ppcp_data<-
#' @aliases ppcp_data<-
#' @param value The value for the slot.
#' @rdname nebula-class
setReplaceMethod("ppcp_data", 
                 signature = c(x = "ANY"),
                 function(x, value){
                   initialize(x, ppcp_data = value)
                 })


#' @exportMethod ration_data
#' @aliases ration_data
#' @description \code{ration_data}, \code{ration_data<-}: getter and setter
#' for the \code{ration_data} slot of the object.
#' @rdname nebula-class
setMethod("ration_data", 
          signature = c(x = "ANY"),
          function(x){ x@ration_data })

#' @exportMethod ration_data<-
#' @aliases ration_data<-
#' @param value The value for the slot.
#' @rdname nebula-class
setReplaceMethod("ration_data", 
                 signature = c(x = "ANY"),
                 function(x, value){
                   initialize(x, ration_data = value)
                 })


#' @exportMethod ggset_annotate
#' @aliases ggset_annotate
#' @description \code{ggset_annotate}, \code{ggset_annotate<-}: getter and setter
#' for the \code{ggset_annotate} slot of the object.
#' @rdname nebula-class
setMethod("ggset_annotate", 
          signature = c(x = "ANY"),
          function(x){ x@ggset_annotate })

#' @exportMethod ggset_annotate<-
#' @aliases ggset_annotate<-
#' @param value The value for the slot.
#' @rdname nebula-class
setReplaceMethod("ggset_annotate", 
                 signature = c(x = "ANY"),
                 function(x, value){
                   initialize(x, ggset_annotate = value)
                 })
# ==========================================================================
# a class to store functions of reading or formating the target data
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
#' @exportClass project_api
#'
#' @aliases project_api
#'
#' @title Function set for extracting data
#'
#' @description 
#' This is a class object used to store various functions for extracting and formatting data.
#' See [project-class] for joint application with other related classes.
#' @family projects
#'
#' @note The class is not for normal use of the package.
#'
#' @slot methods_read list. Store a list of functions for reading data.
#' The list with the names: "read" + "subscript". e.g., "read.f3_fingerid".
#' @slot methods_format function. The function is used to format the data
#' (e.g., rename the column names; convert the columns of character type into numeric).
#' @slot methods_match list. Store a list of functions for matching and extracting string.
#'
#' @rdname project_api-class
#'
.project_api <- 
  setClass("project_api", 
           contains = character(),
           representation = 
             representation(methods_read = "list",
                            methods_format = "function",
                            methods_match = "list"
                            ),
           prototype = NULL
           )

# ==========================================================================
# method
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
#' @exportMethod show
#' @aliases show
#' @rdname project_api-class
setMethod("show", 
          signature = c(object = "project_api"),
          function(object){
            .show(object)
          })

#' @exportMethod project_api
#' @aliases project_api
#' @description \code{project_api}, \code{project_api<-}: getter and setter
#' for the \code{project_api} slot of the object.
#' @rdname project_api-class
setMethod("project_api", 
          signature = c(x = "ANY"),
          function(x){ x@project_api })

#' @exportMethod project_api<-
#' @aliases project_api<-
#' @param value The value for the slot.
#' @rdname project_api-class
setReplaceMethod("project_api", 
                 signature = c(x = "ANY"),
                 function(x, value){
                   initialize(x, project_api = value)
                 })

# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
#' @exportMethod methods_read
#' @aliases methods_read
#' @description \code{methods_read}, \code{methods_read<-}: getter and setter
#' for the \code{methods_read} slot of the object.
#' @rdname project_api-class
setMethod("methods_read", 
          signature = c(x = "project_api"),
          function(x){ x@methods_read })

#' @exportMethod methods_read<-
#' @aliases methods_read<-
#' @param value The value for the slot.
#' @rdname project_api-class
setReplaceMethod("methods_read", 
                 signature = c(x = "project_api"),
                 function(x, value){
                   initialize(x, methods_read = value)
                 })


#' @exportMethod methods_format
#' @aliases methods_format
#' @description \code{methods_format}, \code{methods_format<-}: getter and setter
#' for the \code{methods_format} slot of the object.
#' @rdname project_api-class
setMethod("methods_format", 
          signature = c(x = "project_api"),
          function(x){ x@methods_format })

#' @exportMethod methods_format<-
#' @aliases methods_format<-
#' @param value The value for the slot.
#' @rdname project_api-class
setReplaceMethod("methods_format", 
                 signature = c(x = "project_api"),
                 function(x, value){
                   initialize(x, methods_format = value)
                 })


#' @exportMethod methods_match
#' @aliases methods_match
#' @description \code{methods_match}, \code{methods_match<-}: getter and setter
#' for the \code{methods_match} slot of the object.
#' @rdname project_api-class
setMethod("methods_match", 
          signature = c(x = "project_api"),
          function(x){ x@methods_match })

#' @exportMethod methods_match<-
#' @aliases methods_match<-
#' @param value The value for the slot.
#' @rdname project_api-class
setReplaceMethod("methods_match", 
                 signature = c(x = "project_api"),
                 function(x, value){
                   initialize(x, methods_match = value)
                 })
# ==========================================================================
# a class to store the characters of files or data in raw project.
# These generally describe the file name, file path, and attributes name.
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
#' @exportClass project_conformation
#'
#' @aliases project_conformation
#'
#' @title Clarify the name, path and attribute name of files
#' in the project (directory)
#'
#' @description 
#' This is a class object used to record the name, path and attribute name of the file.
#' These records can be retrieved by "subscript" (see [subscript-class]).
#' See [project-class] for joint application with other related classes.
#'
#' @note The class is not for normal use of the package.
#'
#' @family projects
#' @family subscripts
#'
#' @slot file_name character with names.
#' Record the filenames or pattern string or function name (begin with "FUN_")
#' for each "subscript" (imply file names).
#' @slot file_api character with names.
#' Record the file path for each "subscript" (imply file names).
#' The path is descriped by "subscript" with "/".
#' @slot attribute_name character with names.
#' Record the attribute name for each "subscript" (imply column names).
#'
#' @rdname project_conformation-class
#'
.project_conformation <- 
  setClass("project_conformation", 
           contains = character(),
           representation = 
             representation(file_name = "character",
                            file_api = "character",
                            attribute_name = "character"
                            ),
           prototype = NULL
           )

# ==========================================================================
# validity
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
setValidity("project_conformation", 
            function(object){
              check <- 
                slots_mapply(object,
                             function(slot, name){
                               if (is.character(slot) & length(slot) == 0) {
                                 TRUE
                               } else {
                                 if ( is.character( names(slot) ))
                                   TRUE
```

# 后2500行代码：

```{r eval = F, echo = T}
#' @param ... Other parameters passed to the function \code{fun_filter}.
#' @param by_reference logical. Use \code{specific_candidate(object)} data to filter
#' candidates data. See [create_reference()].
#'
#' @rdname filter_formula-methods
#'
#' @examples
#' \dontrun{
#'   test <- mcn_5features
#'   
#'   ## filter chemical formula candidates
#'   ## use default parameters
#'   test1 <- filter_formula(test)
#'   latest(test1)
#'   
#'   ## the default parameters:
#'   filter_formula()
#'   
#'   ## customized filtering
#'   ## according to score
#'   test1 <- filter_formula(test1, dplyr::filter, zodiac.score > 0.5)
#'   latest(test1)
#'   
#'   ## get top rank
#'   test1 <- filter_formula(test1, dplyr::filter, rank.formula <= 3)
#'   latest(test1)
#'   
#'   ## complex filtering
#'   test1 <- filter_formula(
#'     test1, dplyr::filter,
#'     ## molecular formula
#'     !grepl("N", mol.formula),
#'     ## mass error
#'     abs(error.mass) < 0.001
#'   )
#'   latest(test1)
#'   
#'   ## select columns
#'   test1 <- filter_formula(test1, dplyr::select, 1:5)
#'   latest(test1)
#' }
setMethod("filter_formula", 
          signature = setMissing("filter_formula",
                                 x = "mcnebula",
                                 fun_filter = "function",
                                 by_reference = "logical"),
          function(x, fun_filter, ..., by_reference){
            .message_info_formal("MCnebula2", "filter_formula")
            subscript <- ".f2_formula"
            x <- collate_data(x, subscript, .collate_formula.msframe)
            ## filter
            msframe.lst <- extract_rawset(x, subscript)
            if (by_reference) {
              .message_info("filter_formula", "by_reference == T",
                        "\n\tcase formula, ignore `fun_filter`")
              .check_data(x, list(specific_candidate = "create_reference"))
              fun <- methods_match(project_api(x))[[ "generate_candidates_id" ]]
              entity(msframe.lst[[1]]) <- 
                merge(specific_candidate(x),
                      format_msframe(entity(msframe.lst[[1]]), fun_format = fun),
                      by = c(".features_id", ".candidates_id"))
            } else {
              msframe.lst[[1]] <-
                filter_msframe(msframe.lst[[1]], fun_filter = fun_filter,
                               f = ~.features_id, ...)
            }
            mcn_dataset(x) <- add_dataset(mcn_dataset(x), msframe.lst)
            return(x)
          })

.collate_formula.msframe <- 
  function(x, subscript){
    msframe <- .collate_data.msframe(x, subscript)
    if (!"zodiac.score" %in% colnames(entity(msframe))) {
      warning("`zodiac.score` not found in `msframe`, fill it with `zodiac.score` = 0")
      entity(msframe)$zodiac.score <- 0
    }
    msframe
  }
# ==========================================================================
# collate ppcp dataset in sirius project and do filtering
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
#' @aliases filter_ppcp
#'
#' @title Collate and filter candidates of chemical classification for each 'feature'
#'
#' @description This methods provide an approach to
#' collate and filter chemical classification candidates data in baches for each
#' 'feature'.
#'
#' @details 
#' Filter for PPCP (posterior probability of classification prediction) data.
#' See details about classification prediction for compounds:
#' \url{http://www.nature.com/articles/s41587-020-0740-8}.
#' See other details in [filter_formula()].
#'
#' @name filter_ppcp-methods
#'
#' @order 1
NULL
#> NULL

#' @exportMethod filter_ppcp
#' @description \code{filter_ppcp()}: get the default parameters for the method
#' \code{filter_ppcp}.
#' @rdname filter_ppcp-methods
setMethod("filter_ppcp", 
          signature = setMissing("filter_ppcp",
                                 x = "missing"),
          function(){
            list(fun_filter = .filter_ppcp_by_threshold,
                 by_reference = T
            )
          })

#' @exportMethod filter_ppcp
#' @description \code{filter_ppcp(x, ...)}: use the default parameters whatever 'missing'
#' while performing the method \code{filter_ppcp}.
#' @rdname filter_ppcp-methods
setMethod("filter_ppcp", 
          signature = c(x = "mcnebula"),
          function(x, fun_filter, ..., by_reference){
            reCallMethod("filter_ppcp",
                         .fresh_param(filter_ppcp()), ...)
          })

#' @exportMethod filter_ppcp
#'
#' @aliases filter_ppcp
#'
#' @inheritParams filter_formula-methods
#'
#' @rdname filter_ppcp-methods
#'
#' @examples
#' \dontrun{
#'   test <- mcn_5features
#'   
#'   ## filter chemical class candidates
#'   ## the default parameters:
#'   filter_ppcp()
#'   
#'   ## if 'by_reference' set with TRUE, 'create_reference' should be
#'   ## run previously.
#'   test1 <- filter_ppcp(test, by_reference = F)
#'   latest(test1)
#'   
#'   ## customized filtering
#'   ## according to score
#'   test1 <- filter_ppcp(test1, dplyr::filter, pp.value > 0.5,
#'                        by_reference = F)
#'   latest(test1)
#'   
#'   ## complex filtering
#'   test1 <- filter_ppcp(
#'     test1, dplyr::filter,
#'     ## PPCP value
#'     pp.value > 0.5,
#'     ## speicifid class
#'     class.name %in% c("Azoles"),
#'     by_reference = F
#'   )
#'   latest(test1)
#'   
#'   ## select columns
#'   test1 <- filter_ppcp(test1, dplyr::select, 1:5,
#'                        by_reference = F)
#'   latest(test1)
#' }
setMethod("filter_ppcp", 
          signature = setMissing("filter_ppcp",
                                 x = "mcnebula", fun_filter = "function",
                                 by_reference = "logical"),
          function(x, fun_filter, ..., by_reference){
            .message_info_formal("MCnebula2", "filter_ppcp")
            if (by_reference) {
              .message_info("filter_ppcp", "by_reference == T")
              .check_data(x, list(specific_candidate = "create_reference"))
            }
            subscript <- c(".canopus", ".f3_canopus")
            if (ion_mode(x) == "neg")
              subscript[1] <- c(".canopus_neg")
            for (i in subscript) {
              x <- get_metadata(x, i)
              if (by_reference & i == subscript[2])
                x <- collate_data(x, i, reference = specific_candidate(x))
              else
                x <- collate_data(x, i)
            }
            annotation <- entity(dataset(project_dataset(x))[[ subscript[1] ]])
            msframe.lst <- extract_rawset(x, subscript = subscript[2])
            ## validate
            if ( !subscript[2] %in% names(dataset(mcn_dataset(x))) ) {
              .message_info("filter_ppcp", "validate annotation data",
                        paste0(subscript, collapse = " >>> "))
              validate_ppcp_annotation(annotation, msframe.lst)
              ## add annotation into dataset
              msframe.lst <- merge_ppcp_annotation(annotation, msframe.lst)
              project_dataset(x) <- add_dataset(project_dataset(x), msframe.lst)
            }
            ## filter
            msframe.lst[[1]] <-
              filter_msframe(msframe.lst[[1]], fun_filter = fun_filter,
                             f = ~ paste0(.features_id, "_", .candidates_id), ...)
            mcn_dataset(x) <- add_dataset(mcn_dataset(x), msframe.lst)
            return(x)
          })

validate_ppcp_annotation <- 
  function(annotation, lst){
    rows <- nrow(annotation)
    lst <- split(entity(lst[[1]]), f = ~ paste0(.features_id, "_", .candidates_id))
    if (!identical( annotation$rel.index, lst[[1]]$rel.index))
      stop("the annotation not match the classification dataset: 1")
    lapply(lst, function(df){
             if (nrow(df) != rows)
               stop("the annotation not match the classification dataset")
          })
  }

merge_ppcp_annotation <- 
  function(annotation, msframe.lst){
    annotation <- dplyr::select(annotation, -.features_id, -.candidates_id)
    col <- colnames(annotation)
    col <- col[!col %in% colnames(entity(msframe.lst[[1]]))]
    annotation <- dplyr::select(annotation, rel.index, dplyr::all_of(col))
    entity(msframe.lst[[1]]) <- 
      merge(entity(msframe.lst[[1]]), annotation,
            by = "rel.index", all.x = T, sort = F)
    return(msframe.lst)
  }
# ==========================================================================
# collate structure dataset in sirius project and do filtering
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
#' @aliases filter_structure
#'
#' @title Collate and filter candidates of chemical structure for each 'feature'
#'
#' @description This methods provide an approach to
#' collate and filter chemical structure candidates data in baches for each
#' 'feature'.
#'
#' @details See details in [filter_formula()].
#'
#' @name filter_structure-methods
#'
#' @order 1
NULL
#> NULL

#' @exportMethod filter_structure
#' @description \code{filter_structure()}: get the default parameters for the method
#' \code{filter_structure}.
#' @rdname filter_structure-methods
setMethod("filter_structure", 
          signature = setMissing("filter_structure",
                                 x = "missing"),
          function(){
            list(fun_filter = .rank_by_csi.score,
                 by_reference = F
            )
          })

#' @exportMethod filter_structure
#' @description \code{filter_structure(x, ...)}: use the default parameters whatever 'missing'
#' while performing the method \code{filter_structure}.
#' @rdname filter_structure-methods
setMethod("filter_structure", 
          signature = c(x = "mcnebula"),
          function(x, fun_filter, ..., by_reference){
            reCallMethod("filter_structure",
                         .fresh_param(filter_structure()), ...)
          })

#' @exportMethod filter_structure
#'
#' @aliases filter_structure
#'
#' @inheritParams filter_formula-methods
#'
#' @rdname filter_structure-methods
#'
#' @examples
#' \dontrun{
#'   test <- mcn_5features
#'   
#'   ## filter chemical structure candidates
#'   ## use default parameters
#'   test1 <- filter_structure(test)
#'   latest(test1)
#'   
#'   ## the default parameters:
#'   filter_structure()
#'   
#'   ## customized filtering
#'   ## according to score
#'   test1 <- filter_structure(test1, dplyr::filter, tani.score > 0.4)
#'   latest(test1)
#'   
#'   ## get top rank
#'   test1 <- filter_structure(test1, dplyr::filter, rank.structure <= 3)
#'   latest(test1)
#'   
#'   ## complex filtering
#'   test1 <- filter_structure(
#'     test1, dplyr::filter,
#'     ## molecular formula
#'     !grepl("N", mol.formula),
#'     ## Tanimoto similarity
#'     tani.score > 0.4
#'   )
#'   latest(test1)
#'   
#'   ## select columns
#'   test1 <- filter_structure(test1, dplyr::select, 1:5)
#'   latest(test1)
#' }
setMethod("filter_structure", 
          signature = setMissing("filter_structure",
                                 x = "mcnebula",
                                 fun_filter = "function",
                                 by_reference = "logical"),
          function(x, fun_filter, ..., by_reference){
            .message_info_formal("MCnebula2", "filter_structure")
            subscript <- ".f3_fingerid"
            x <- collate_data(x, subscript)
            ## filter
            msframe.lst <- extract_rawset(x, subscript)
            if (by_reference) {
              .message_info("filter_structure", "by_reference == T")
              .check_data(x, list(specific_candidate = "create_reference"))
              entity(msframe.lst[[1]]) <- 
                merge(specific_candidate(x), entity(msframe.lst[[1]]),
                      by = c(".features_id", ".candidates_id"))
            }
            msframe.lst[[1]] <-
              filter_msframe(msframe.lst[[1]], fun_filter = fun_filter,
                             f = ~.features_id, ...)
            mcn_dataset(x) <- add_dataset(mcn_dataset(x), msframe.lst)
            return(x)
          })
# ==========================================================================
# set default value for project of MCnebula
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
#' @aliases initialize_mcnebula
#'
#' @title Initialize mcnebula object
#'
#' @description
#' Set SIRIUS project path and its version to initialize [mcnebula-class] object.
#' In addition, the methods can be used for some related object to given
#' default value.
#'
#' @name initialize_mcnebula-methods
#'
#' @order 1
NULL
#> NULL

#' @importFrom methods getFunction
#' @exportMethod initialize_mcnebula
#'
#' @aliases initialize_mcnebula
#'
#' @param x [mcnebula-class] object, [melody-class] object,
#' [project_conformation-class] or [project_api-class] object.
#' @param sirius_version character. e.g., "sirius.v4", "sirius.v5"
#' @param sirius_project character. The path of SIRIUS project space.
#' @param output_directory character. The path for output.
#'
#' @rdname initialize_mcnebula-methods
#'
#' @examples
#' \dontrun{
#'   ## The raw data used for the example
#'   tmp <- paste0(tempdir(), "/temp_data")
#'   dir.create(tmp)
#'   eg.path <- system.file("extdata", "raw_instance.tar.gz",
#'                          package = "MCnebula2")
#'   
#'   utils::untar(eg.path, exdir = tmp)
#'   
#'   ## initialize 'mcnebula' object
#'   test <- mcnebula()
#'   test <- initialize_mcnebula(test, "sirius.v4", tmp)
#'   ## check the setting
#'   export_path(test)
#'   palette_set(test)
#'   ion_mode(test)
#'   project_version(test)
#'   
#'   ## initialize 'melody' object
#'   test <- new("melody")
#'   test <- initialize_mcnebula(test)
#'   ## check...
#'   palette_stat(test)
#'   
#'   ## initialize 'project_conformation' object
#'   test <- new("project_conformation")
#'   test <- initialize_mcnebula(test, "sirius.v4")
#'   ## check
#'   file_name(test)
#'   
#'   ## initialize 'project_api' object
#'   test <- new("project_api")
#'   test <- initialize_mcnebula(test, "sirius.v4")
#'   ## check
#'   methods_format(test)
#'   
#'   unlink(tmp, T, T)
#' }
setMethod("initialize_mcnebula", 
          signature = c(x = "mcnebula",
                        sirius_version = "ANY",
                        sirius_project = "ANY",
                        output_directory = "ANY"),
          function(x, sirius_version, sirius_project, output_directory){
            if (missing(sirius_version))
              sirius_version <- project_version(x)
            else
              project_version(x) <- sirius_version
            if (missing(sirius_project))
              sirius_project <- project_path(x)
            else
              project_path(x) <- sirius_project
            if (missing(output_directory)) {
              if (length(x@export_path) == 0) {
                export_path(x) <- paste0(sirius_project, "/mcnebula_results")
              }
            } else {
              export_path(x) <- output_directory
            }
            getFunction(paste0(".validate_", sirius_version),
                        where = parent.env(environment()))(sirius_project)
            item <- methods(initialize_mcnebula)
            item <- stringr::str_extract(item, "(?<=,).*(?=-method)")
            item <- gsub(",.*$", "", item)
            item <- item[item != "mcnebula"]
            for(i in item){
              express <- paste0(i, "(x)",
                                "<- initialize_mcnebula(",
                                ## initialize slot
                                i, "(x)", ", ",
                                ## other args
                                "sirius_version = sirius_version,",
                                "sirius_project = sirius_project",
                                ")")
              eval( parse(text = express) )
            }
            export_name(x) <- .get_export_name()
            return(x)
          })

#' @exportMethod initialize_mcnebula
#'
#' @aliases initialize_mcnebula
#'
#' @seealso [ggsci::pal_simpsons()], [ggsci::pal_igv()], [ggsci::pal_ucscgb()],
#' [ggsci::pal_d3()]...
#'
#' @rdname initialize_mcnebula-methods
#'
setMethod("initialize_mcnebula", 
          signature = c(x = "melody"),
          function(x){
            ## set color palette
            palette_set(x) <- .get_color_set()
            palette_gradient(x) <- .get_color_gradient()
            palette_stat(x) <- .get_color_stat()
            palette_col(x) <- .get_color_col()
            palette_label(x) <- .get_label_color()
            return(x)
          })

#' @exportMethod initialize_mcnebula
#' @rdname initialize_mcnebula-methods
setMethod("initialize_mcnebula", 
          signature = c(x = "project_conformation",
                        sirius_version = "character"),
          function(x, sirius_version){
            slots <- names(attributes(x))
            slots <- slots[-length(slots)]
            for (i in slots) {
              express <- 
                paste0( i, "(x)", "<-", ".get_", i, "_", sirius_version, "()")
              eval( parse(text = express) )
            }
            return(x)
          })

#' @exportMethod initialize_mcnebula
#' @rdname initialize_mcnebula-methods
setMethod("initialize_mcnebula", 
          signature = c(x = "project_api",
                        sirius_version = "character"),
          function(x, sirius_version){
            express <- paste0("function(x) format_msframe(",
                              "x,",
                              "fun_names = .get_attribute_name_", sirius_version, ",",
                              "fun_types = .get_attribute_type_", sirius_version, "",
                              ")")
            methods_format(x) <- eval( parse(text = express) )
            express <- paste0(".get_methods_read_", sirius_version, "()")
            methods_read(x) <- eval( parse(text = express) )
            express <- paste0(".get_methods_match_", sirius_version, "()")
            methods_match(x) <- eval( parse(text = express) )
            return(x)
          })
# ==========================================================================
# extract and visualize 'ggset' in 'mcnebula' object
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
#' @aliases visualize
#'
#' @title Visualize Nebulae in R graphic device
#'
#' @description
#' Methods used for visualization.
#' Show chemical Nebulae (either Parent-Nebula or Child-Nebulae) in R graphic device.
#' Run after [activate_nebulae()]
#'
#' @name visualize-methods
#'
#' @order 1
NULL
#> NULL

#' @importFrom tibble tibble
setClassUnion("numeric_or_character", c("numeric", "character"))

#' @exportMethod visualize
#' @description \code{visualize(x)}: get a 'tbl' about Child-Nebulae candidates
#' for \code{visualize} methods to visualize.
#' @rdname visualize-methods
setMethod("visualize", 
          signature = setMissing("visualize",
                                 x = "mcnebula",
                                 fun_modify = "ANY"),
          function(x, fun_modify){
            .message_info_formal("MCnebula2", "visualize")
            cat("\tSpecify item as following to visualize:\n\n")
            class.name <- names(ggset(child_nebulae(x)))
            hierarchy <- vapply(class.name, function(c, h) h[[c]], 1,
                                h = .get_hierarchy(x))
            tibble::tibble(seq = 1:length(class.name),
                           hierarchy = hierarchy,
                           class.name = class.name
            )
          })

#' @exportMethod visualize
#' @description \code{visualize()}: get the default parameters for the method
#' \code{visualize}.
#' @rdname visualize-methods
setMethod("visualize", 
          signature = setMissing("visualize"),
          function(){
            list(fun_modify = modify_set_labs)
          })

#' @exportMethod visualize
#' @description \code{visualize(x, ...)}: use the default parameters whatever 'missing'
#' while performing the method \code{visualize}.
#' @rdname visualize-methods
setMethod("visualize", 
          signature = c(x = "mcnebula"),
          function(x, item, fun_modify, annotate){
            reCallMethod("visualize", .fresh_param(visualize()))
          })

#' @exportMethod visualize
#'
#' @aliases visualize
#'
#' @param item character(1) or numeric(1). If \code{character}, the value should be
#' a name of chemical class in 'nebula_index' data. Its Nebulae has been activated
#' via [activate_nebulae()]. If \code{numeric}, the value should be the sequence of 
#' Nebulae... Use \code{visualize(object)} to get the optional value.
#' 
#' @param annotate logical. If \code{TRUE}, visualize the Nebula with the annotation.
#' Only available [annotate_nebula()] has been run for the Nebula.
#'
#' @rdname visualize-methods
#'
#' @examples
#' \dontrun{
#'   test <- mcn_5features
#'   
#'   ## the previous steps
#'   test1 <- filter_structure(test)
#'   test1 <- create_reference(test1)
#'   test1 <- filter_formula(test1, by_reference = T)
#'   test1 <- create_stardust_classes(test1)
#'   test1 <- create_features_annotation(test1)
#'   test1 <- cross_filter_stardust(test1, 2, 1)
#'   test1 <- create_nebula_index(test1)
#'   test1 <- compute_spectral_similarity(test1)
#'   test1 <- create_parent_nebula(test1, 0.01)
#'   test1 <- create_child_nebulae(test1, 0.01)
#'   test1 <- create_parent_layout(test1)
#'   test1 <- create_child_layouts(test1)
#'   test1 <- activate_nebulae(test1)
#'   
#'   ## optional Child-Nebulae
#'   visualize(test1)
#'   
#'   visualize(test1, "parent")
#'   visualize(test1, 1)
#'   visualize_all(test1)
#'   ## ...
#'   
#'   ## use 'fun_modify'
#'   visualize(test1, 1, modify_default_child)
#'   visualize(test1, 1, modify_unify_scale_limits)
#'   visualize(test1, 1, modify_set_labs)
#'   ## ...
#' }
setMethod("visualize", 
          signature = setMissing("visualize",
                                 x = "mcnebula",
                                 item = "character",
                                 fun_modify = "function"),
          function(x, item, fun_modify){
            .message_info_formal("MCnebula2", "visualize")
            if (item == "parent") {
              call_command(fun_modify(ggset(parent_nebula(x))))
            } else {
              obj <- ggset(child_nebulae(x))[[ item ]]
              if (!is.null(obj)) {
                call_command(fun_modify(obj))
              } else {
                stop( "the `item` not found in `ggset(child_nebula(x))`" )
              }
            }
          })

#' @exportMethod visualize
#' @rdname visualize-methods
setMethod("visualize", 
          signature = setMissing("visualize",
                                 x = "mcnebula",
                                 item = "numeric",
                                 fun_modify = "function"),
          function(x, item, fun_modify){
            .message_info_formal("MCnebula2", "visualize")
            call_command(fun_modify(ggset(child_nebulae(x))[[ item ]]))
          })

#' @exportMethod visualize
#' @rdname visualize-methods
setMethod("visualize", 
          signature = setMissing("visualize",
                                 x = "mcnebula",
                                 item = "numeric_or_character",
                                 fun_modify = "function",
                                 annotate = "logical"),
          function(x, item, fun_modify, annotate){
            if (annotate) {
              obj <- ggset_annotate(child_nebulae(x))[[ item ]]
              if (is.null(obj)) {
                stop( "the `item` not found in `ggset_annotate(child_nebula(x))`" )
              } else {
                call_command(fun_modify(obj))
              }
            } else {
              visualize(x, item)
            }
          })

#' @export get_ggset
#' @description \code{get_ggset}: similar to \code{visualize(...)}, but get
#' [ggset-class] object.
#' @rdname visualize-methods
get_ggset <- function(x, item, fun_modify, annotate = F) {
  if (!annotate) {
    fun_modify(ggset(child_nebulae(x))[[ item ]])
  } else {
    fun_modify(ggset_annotate(child_nebulae(x))[[ item ]])
  }
}

#' @exportMethod visualize_all
#' @description \code{visualize_all()}: get the default parameters for the method
#' \code{visualize_all}.
#' @rdname visualize-methods
setMethod("visualize_all", 
          signature = setMissing("visualize_all",
                                 x = "missing"),
          function(){
            list(newpage = T,
                 fun_modify = modify_default_child,
                 legend_hierarchy = T
            )
          })

#' @exportMethod visualize_all
#' @description \code{visualize_all(x, ...)}: use the default parameters whatever 'missing'
#' while performing the method \code{visualize_all}.
#' @rdname visualize-methods
setMethod("visualize_all", 
          signature = c(x = "mcnebula"),
          function(x, newpage, fun_modify, legend_hierarchy){
            reCallMethod("visualize_all",
                         .fresh_param(visualize_all()))
          })

#' @importFrom grid grid.newpage
#' @importFrom grid viewport
#' @importFrom grid pushViewport
#' @importFrom grid upViewport
#' @importFrom grid grid.draw
#' @exportMethod visualize_all
#'
#' @description \code{visualize_all}: visualize overall Child-Nebulae into R graphic device.
#'
#' @param x [mcnebula-class] object.
#' @param newpage logical. If \code{TRUE}, use [grid::grid.newpage()] before visualization.
#' @param fun_modify function. Used to post modify the [ggset-class] object before
#' visualization. See [fun_modify].
#' @param legend_hierarchy logical. If \code{TRUE}, visualize the legend of chemical hierarchy.
#'
#' @rdname visualize-methods
#'
setMethod("visualize_all", 
          signature = setMissing("visualize_all",
                                 x = "mcnebula",
                                 newpage = "logical",
                                 fun_modify = "function",
                                 legend_hierarchy = "logical"),
          function(x, newpage, fun_modify, legend_hierarchy){
            .message_info_formal("MCnebula2", "visualize_all")
            set <- child_nebulae(x)
            if (newpage)
              grid::grid.newpage()
            .message_info_viewport("BEGIN")
            grid::pushViewport(panel_viewport(set))
            layer <- 1
            .message_info_viewport()
            if (legend_hierarchy) {
              .visualize_legend_hierarchy(set)
              layer <- layer + 1
            }
            layer <- layer +
              .visualize_child_nebulae(set, fun_modify)
            grid::upViewport(layer)
            .message_info_viewport()
            .visualize_legend_nebulae(set, fun_modify)
            .message_info_viewport("END")
          })

.visualize_child_nebulae <- 
  function(set, fun_modify = modify_default_child, x){
    x <- .get_missing_x(x, "mcnebula")
    if (!is.null(grid_layout(set))) {
      grid::pushViewport(grid::viewport(layout = grid_layout(set)))
      layer <- 1
    } else {
      layer <- 0
    }
    lapply(names(ggset(set)),
           function(name){
             print(call_command(fun_modify(ggset(set)[[ name ]])),
                   vp = viewports(set)[[ name ]],
                   newpage = F)
           })
    return(layer)
  }

.visualize_legend_nebulae <- 
  function(set, fun_modify = modify_default_child, x){
    x <- .get_missing_x(x, "mcnebula")
    grid::pushViewport(legend_viewport(set))
    .message_info("visualize", "legend:",
                paste0("\n\textract legend from ",
                       "`ggset(child_nebulae(x))[[1]]` ",
                       "(nebula names:", names(ggset(set)[[1]]), ").",
                       "\n\tIn default, legend scales have been unified ",
                       "for all child-nebulae."
                       ))
    ggset <- fun_modify(ggset(set)[[1]])
    if (!is.null(attr(ggset, "modify"))) {
      ggset <- match.fun(attr(ggset, "modify"))(ggset)
    }
    grob <- .get_legend(call_command(ggset))
    grid::grid.draw(grob)
  }

.visualize_legend_hierarchy <- 
  function(set, x){
    x <- .get_missing_x(x, "mcnebula")
    grob <- .legend_hierarchy(set)
    pushViewport(viewport(0.5, 0, 1, 0.1,
                          just = c("centre", "bottom"),
                          name = "legend_hierarchy"))
    .message_info_viewport()
    grid::grid.draw(grob)
    upViewport(1)
    pushViewport(viewport(0.5, 0.1, 1, 0.9,
                          just = c("centre", "bottom"),
                          name = "sub_panel"))
    .message_info_viewport()
  }

.legend_hierarchy <- 
  function(set, x){
    x <- .get_missing_x(x, "mcnebula")
    theme <- layers(ggset(set)[[1]])$theme
    if (is.null(theme)) {
      theme <- new_command(match.fun("theme"), name = "theme")
    }
    class.names <- names(ggset(set))
    .check_data(x, list("hierarchy" = "create_hierarchy"))
    hierarchy <- .get_hierarchy(x)
    hierarchy <- vapply(class.names, function(name) hierarchy[[name]], 1)
    color <- vapply(hierarchy, function(n) palette_label(x)[[n]], "ch")
    names(color) <- paste0("Level ", hierarchy)
    .grob_legend_hierarchy_plot(color, call_command(theme))
  }

#' @export visualize_ids
#' @aliases visualize_ids
#' @description \code{visualize_ids}: Plot a label map about the location of the 'features'.
#' @rdname visualize-methods
visualize_ids <- function(x, item) {
  data <- ggset(child_nebulae(x))[[ item ]]
  data <- command_args(layers(data)[[1]])$graph
  data <- dplyr::select(data, .features_id = name, x, y)
  ggplot(data) +
    geom_text(aes(x = x, y = y, label = .features_id), family = .font) +
    theme(text = element_text(family = .font))
}
# ==========================================================================
# directory and file names and path in SIRIUS 4 project, and some function
# for how to read or format these data.
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.validate_sirius.v4 <- 
  function(path){
    sig <- paste0(path, "/.format")
    content <- "%source_%name"
    if (file.exists(sig)) {
      if (!identical(readLines(sig, warn = F, n = 1), content)) {
        stop("the content of file \"", sig,
          "\" is not identical to \"", content, "\"")
      }
    }else{
      stop("file \"", sig, "\" not exists")
    }
  }

.get_file_name_sirius.v4 <- 
  function(){
    set <- c(.id = "FUN_get_id_sirius.v4",
      .canopus = "^canopus.tsv",
      .canopus_summary = "canopus_summary.tsv",
      .compound_identifications = "compound_identifications.tsv",
      .formula_identifications = "formula_identifications.tsv",
      .canopus_neg = "canopus_neg.tsv",
      .csi_fingerid = "csi_fingerid.tsv",
      .csi_fingerid_neg = "csi_fingerid_neg.tsv",
      .dir_canopus = "^canopus$",
      .dir_fingerid = "^fingerid$",
      .dir_scores = "^scores$",
      .dir_spectra = "^spectra$",
      .f2_ms = "spectrum.ms",
      .f2_msms = "spectrum.ms",
      .f2_info = "compound.info",
      .f2_formula = "formula_candidates.tsv",
      .f3_canopus = "\\.fpt$",
      .f3_fingerid = "\\.tsv$",
      .f3_scores = "\\.info$",
      .f3_spectra = "\\.tsv$"
    )
  }

FUN_get_id_sirius.v4 <- 
  function(x){
    if (missing(x))
      return("^[0-9](.*)_(.*)_(.*)$")
    stringr::str_extract(x, "(?<=_)[^_|^/]{1,}(?=/|$)")
  }

.get_file_api_sirius.v4 <- 
  function(){
    set <- c(.id = ".id",
      .canopus = ".canopus",
      .canopus_summary = ".canopus_summary",
      .compound_identifications = ".compound_identifications",
      .formula_identifications = ".formula_identifications",
      .canopus_neg = ".canopus_neg",
      .csi_fingerid = ".csi_fingerid",
      .csi_fingerid_neg = ".csi_fingerid_neg",
      .dir_canopus = ".id/.dir_canopus",
      .dir_fingerid = ".id/.dir_fingerid",
      .dir_scores = ".id/.dir_scores",
      .dir_spectra = ".id/.dir_spectra",
      .f2_ms = ".id/.f2_ms",
      .f2_msms = ".id/.f2_msms",
      .f2_info = ".id/.f2_info",
      .f2_formula = ".id/.f2_formula",
      .f3_canopus = ".id/.dir_canopus/.f3_canopus",
      .f3_fingerid = ".id/.dir_fingerid/.f3_fingerid",
      .f3_scores = ".id/.dir_scores/.f3_scores",
      .f3_spectra = ".id/.dir_spectra/.f3_spectra"
    )
  }

.get_attribute_name_sirius.v4 <- 
  function(){
    set <- c(
      ## .f3_fingerid
      ...sig = ".f3_fingerid",
      inchikey2d = "inchikey2D",
      inchi = "inchi",
      mol.formula = "molecularFormula",
      rank.structure = "rank",
      csi.score = "score",
      synonym = "name",
      smiles = "smiles",
      xlogp = "xlogp",
      pubmed.ids = "PubMedIds",
      links = "links",
      tani.score = "tanimotoSimilarity",
      dbflags = "dbflags",
      ## .f3_spectra
      ...sig = ".f3_spectra",
      mz = "mz",
      int. = "intensity",
      rel.int. = "rel.intensity",
      exactmass = "exactmass",
      formula = "formula",
      ion. = "ionization",
      ## .f2_formula
      ...sig = ".f2_formula",
      adduct = "adduct",
      pre.formula = "precursorFormula",
      zodiac.score = "ZodiacScore",
      sirius.score = "SiriusScore",
      tree.score = "TreeScore",
      iso.score = "IsotopeScore",
      hit.num. = "numExplainedPeaks",
      hit.int. = "explainedIntensity",
      error.frag. = "medianMassErrorFragmentPeaks\\(ppm\\)",
      error.abs.frag. = "medianAbsoluteMassErrorFragmentPeaks\\(ppm\\)",
      error.mass = "massErrorPrecursor\\(ppm\\)",
      rank.formula = "rank",
      ## .f2_info
      ...sig = ".f2_info",
      rt.secound = "rt",
      mz = "ionMass",
      ## .canopus
      ...sig = ".canopus",
      rel.index = "relativeIndex",
      abs.index = "absoluteIndex",
      chem.ont.id = "id",
      class.name = "name",
      parent.chem.ont.id = "parentId",
      description = "description",
      ## .canopus_neg
      ...sig = ".canopus_neg",
      chem.ont.id = "id",
      class.name = "name",
      ## .canopus_summary
      ...sig = ".canopus_summary",
      .id = "name",
      most.sp.class = "most specific class",
      level5 = "level 5",
      subclass = "subclass",
      class = "class",
      superclass = "superclass",
      all.class = "all classifications",
      ## .compound_identifications
      ...sig = ".compound_identifications",
      cosmic.score = "ConfidenceScore",
      .id = "id",
      ## .f3_canopus
      ...sig = ".f3_canopus",
      pp.value = "V1",
      ...sig = "END"
    )
  }

.get_attribute_type_sirius.v4 <- 
  function(){
    set <- c(
      rank.formula = "integer",
      rank.structure = "integer",
      csi.score = "numeric",
      xlogp = "numeric",
      tani.score = "numeric",
      mz = "numeric",
      rt.secound = "numeric",
      rt.min = "numeric",
      int. = "numeric",
      rel.int. = "numeric",
      exactmass = "numeric",
      zodiac.score = "numeric",
      sirius.score = "numeric",
      tree.score = "numeric",
      iso.score = "numeric",
      hit.num. = "integer",
      hit.int. = "numeric",
      error.frag. = "numeric",
      error.abs.frag. = "numeric",
      error.mass = "numeric",
      rel.index = "integer",
      abs.index = "integer",
      cosmic.score = "numeric",
      pp.value = "numeric"
    )
  }

.get_methods_read_sirius.v4 <- 
  function(){
    set <- c(
      read.canopus = read_tsv,
      read.canopus_summary = read_tsv,
      read.compound_identifications = read_tsv,
      read.formula_identifications = read_tsv,
      read.f2_ms = pbsapply_read_tsv,
      read.f2_msms = pbsapply_read_msms,
      read.f2_formula = pbsapply_read_tsv,
      read.f2_info = pbsapply_read_info,
      read.f3_fingerid = pbsapply_read_tsv,
      read.f3_scores = pbsapply_read_tsv,
      read.f3_spectra = pbsapply_read_tsv,
      read.f3_canopus = .pbsapply_read_fpt
    )
  }

list_files_top.sirius.v4 <- function(path, pattern){
  data.frame(files = list.files(path = path, pattern = pattern))
}

list_files.sirius.v4 <- function(path, upper, pattern, ...){
  lst_file <- pbapply::pbmapply(path, upper, pattern, SIMPLIFY = F,
    FUN = function(path, upper, pattern){
      files <- list.files(paste0(path, "/", upper), pattern)
      if ( length(files) == 0)
        return( data.frame() )
      data.frame(upper = upper, files = files)
    })
  data.table::rbindlist(lst_file)
}

pbsapply_read_msms <- function(path){
  pbapply::pbsapply(path, simplify = F,
    function(path){
      lines <- readLines(path)
      start <- grep("^>ms2peaks", lines) + 1
      if (length(start) != 0) {
        lines <- lines[start:length(lines)]
        data <- data.table::fread(text = lines)
        colnames(data) <- c("mz", "int.")
      } else {
        data <- data.frame(mz = double(0), int. = double(0))
      }
      data
    }
  )
}

pbsapply_read_info <- function(path){
  pbapply::pbsapply(path, simplify = F,
    function(path){
      lines <- readLines(path)
      lines <- lines[grepl("^ionMass|^rt", lines)]
      data.frame(ionMass =
        stringr::str_extract(lines[1], "[0-9|.]{1,}"),
      rt = stringr::str_extract(lines[2], "[0-9|.]{1,}")
      )
    })
}

.pbsapply_read_fpt <- function(path){
  pbapply::pbsapply(path, simplify = F,
    function(path){
      df <- data.table::fread(path, header = F)
      df$rel.index <- 0:(nrow(df) - 1)
      df
    })
}

.get_methods_match_sirius.v4 <- 
  function(){
    set <- c(
      match.features_id = FUN_get_id_sirius.v4,
      match.candidates_id = function(x) stringr::str_extract(x, "[^/]*(?=\\.[a-z]*$)"),
      generate_candidates_id = function(df) {
        if (is.null(df$pre.formula) | is.null(df$adduct))
          stop( "columns not found in `df`" )
        paste0(df$pre.formula, "_", gsub(" ", "", df$adduct))
      }
    )
  }

# ==========================================================================
# directory and file names and path in SIRIUS 4 project, and some function
# for how to read or format these data.
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

.validate_sirius.v5 <- 
  function(path){
    sig <- paste0(path, "/.format")
    content <- "%source_%name"
    if (file.exists(sig)) {
      if (!identical(readLines(sig, warn = F, n = 1), content)) {
        stop("the content of file \"", sig,
          "\" is not identical to \"", content, "\"")
      }
    }else{
      stop("file \"", sig, "\" not exists")
    }
    sig <- paste0(path, "/.compression")
    if (file.exists(sig)) {
      lines <- readLines(sig, warn = F)
      if (lines[1] != "compressionLevels\t1" |
        lines[2] != "compressionMethod\tDEFLATED")
        stop("file \"", sig, "\": Inappropriate compression method.")
    }
  }


.get_file_name_sirius.v5 <- 
  function(){
    set <- c(.id = "FUN_get_id_sirius.v5",
      .canopus = "^canopus.tsv",
      .canopus_summary = "canopus_compound_summary.tsv",
      .compound_identifications = "compound_identifications.tsv",
      .formula_identifications = "formula_identifications.tsv",
      .canopus_neg = "canopus_neg.tsv",
      .csi_fingerid = "csi_fingerid.tsv",
      .csi_fingerid_neg = "csi_fingerid_neg.tsv",
      .zip_canopus = "^canopus$",
      .zip_fingerid = "^fingerid$",
      .zip_scores = "^scores$",
      .zip_spectra = "^spectra$",
      .f2_ms = "spectrum.ms",
      .f2_msms = "spectrum.ms",
      .f2_info = "compound.info",
      .f2_formula = "formula_candidates.tsv",
      .f3_canopus = "\\.fpt$",
      .f3_fingerid = "\\.tsv$",
      .f3_scores = "\\.info$",
      .f3_spectra = "\\.tsv$"
    )
  }

FUN_get_id_sirius.v5 <-FUN_get_id_sirius.v4

.get_file_api_sirius.v5 <- function(){
  set <- c(.id = ".id",
    .canopus = ".canopus",
    .canopus_summary = ".canopus_summary",
    .compound_identifications = ".compound_identifications",
    .formula_identifications = ".formula_identifications",
    .canopus_neg = ".canopus_neg",
    .csi_fingerid = ".csi_fingerid",
    .csi_fingerid_neg = ".csi_fingerid_neg",
    .zip_canopus = ".id/.zip_canopus",
    .zip_fingerid = ".id/.zip_fingerid",
    .zip_scores = ".id/.zip_scores",
    .zip_spectra = ".id/.zip_spectra",
    .f2_ms = ".id/.f2_ms",
    .f2_msms = ".id/.f2_msms",
    .f2_info = ".id/.f2_info",
    .f2_formula = ".id/.f2_formula",
    .f3_canopus = ".id/.zip_canopus/.f3_canopus",
    .f3_fingerid = ".id/.zip_fingerid/.f3_fingerid",
    .f3_scores = ".id/.zip_scores/.f3_scores",
    .f3_spectra = ".id/.zip_spectra/.f3_spectra"
  )
}

.get_attribute_name_sirius.v5 <- 
  function(){
    set <- c(
      ## .f3_fingerid
      ...sig = ".f3_fingerid",
      inchikey2d = "inchikey2D",
      inchi = "inchi",
      mol.formula = "molecularFormula",
      rank.structure = "rank",
      csi.score = "score",
      synonym = "name",
      smiles = "smiles",
      xlogp = "xlogp",
      pubmed.ids = "PubMedIds",
      links = "links",
      tani.score = "tanimotoSimilarity",
      dbflags = "dbflags",
      ## .f3_spectra
      ...sig = ".f3_spectra",
      mz = "mz",
      int. = "intensity",
      rel.int. = "rel.intensity",
      exactmass = "exactmass",
      formula = "formula",
      ion. = "ionization",
      ## .f2_formula
      ...sig = ".f2_formula",
      adduct = "adduct",
      pre.formula = "precursorFormula",
      zodiac.score = "ZodiacScore",
      sirius.score = "SiriusScore",
      tree.score = "TreeScore",
      iso.score = "IsotopeScore",
      hit.num. = "numExplainedPeaks",
      hit.int. = "explainedIntensity",
      error.frag. = "medianMassErrorFragmentPeaks\\(ppm\\)",
      error.abs.frag. = "medianAbsoluteMassErrorFragmentPeaks\\(ppm\\)",
      error.mass = "massErrorPrecursor\\(ppm\\)",
      rank.formula = "rank",
      ## .f2_info
      ...sig = ".f2_info",
      rt.secound = "rt",
      mz = "ionMass",
      ## .canopus
      ...sig = ".canopus",
      rel.index = "relativeIndex",
      abs.index = "absoluteIndex",
      chem.ont.id = "id",
      class.name = "name",
      parent.chem.ont.id = "parentId",
      description = "description",
      ## .canopus_neg
      ...sig = ".canopus_neg",
      chem.ont.id = "id",
      class.name = "name",
      ## .canopus_summary
      ...sig = ".canopus_summary",
      .id = "id",
      npc_pathway = "NPC#pathway",
      npc_pathway_pp = "NPC#pathway Probability",
      npc_superclass = "NPC#superclass",
      npc_superclass_pp = "NPC#superclass Probability",
      npc_class = "NPC#class",
      npc_class_pp = "NPC#class Probability",
      classyfire_most_specific_class = "ClassyFire#most specific class",
      classyfire_most_specific_class_pp = "ClassyFire#most specific class Probability",
      classyfire_level_5 = "ClassyFire#level 5",
      classyfire_level_5_pp = "ClassyFire#level 5 Probability",
      classyfire_subclass = "ClassyFire#subclass",
      classyfire_subclass_pp = "ClassyFire#subclass Probability",
      classyfire_class = "ClassyFire#class",
      classyfire_class_pp = "ClassyFire#class Probability",
      classyfire_superclass = "ClassyFire#superclass",
      classyfire_superclass_pp = "ClassyFire#superclass probability",
      classyfire_all_classifications = "ClassyFire#all classifications",
      ## .compound_identifications
      ...sig = ".compound_identifications",
      cosmic.score = "ConfidenceScore",
      .id = "id",
      ## .f3_canopus
      ...sig = ".f3_canopus",
      pp.value = "V1",
      ...sig = "END"
    )
  }

.get_attribute_type_sirius.v5 <- .get_attribute_type_sirius.v4

list_files_top.sirius.v5 <- list_files_top.sirius.v4

#' @importFrom utils unzip
list_files.sirius.v5 <- function(path, upper, pattern, info){
  lst_file <- pbapply::pbmapply(path, upper, pattern, SIMPLIFY = F,
    FUN = function(path, upper, pattern){
      if (grepl("^\\.zip_", info)) {
        res <- try(utils::unzip(paste0(path, "/", upper), list = T), silent = T)
        if (!inherits(res, "try-error")) {
          files <- res$Name
          files <- files[ grepl(pattern, files) ]
        } else {
          files <- integer(0)
        }
      } else {
        files <- list.files(paste0(path, "/", upper), pattern)
      }
      if ( length(files) == 0)
        return( data.frame() )
      data.frame(upper = upper, files = files)
    })
  data.table::rbindlist(lst_file)
}

.get_methods_read_sirius.v5 <- 
  function(){
    set <- c(
      read.canopus = read_tsv,
      read.canopus_summary = read_tsv,
      read.compound_identifications = read_tsv,
      read.formula_identifications = read_tsv,
      read.f2_ms = pbsapply_read_tsv,
      read.f2_msms = pbsapply_read_msms,
      read.f2_formula = pbsapply_read_tsv,
      read.f2_info = pbsapply_read_info,
      read.f3_fingerid = pblapply_read_tsv_fromZip,
      read.f3_scores = pblapply_read_tsv_fromZip,
      read.f3_spectra = pblapply_read_tsv_fromZip,
      read.f3_canopus = .pblapply_read_fpt_fromZip
    )
  }

.pblapply_read_fpt_fromZip <- function(path) {
  pblapply_read_tsv_fromZip(path,
    function(path) {
      df <- data.table::fread(path, header = F)
      df$rel.index <- 0:(nrow(df) - 1)
      df
    })
}

pblapply_read_tsv_fromZip <- function(path, fun = read_tsv) {
  zips <- gsub("/[^/]*$", "", path)
  files <- stringr::str_extract(path, "[^/]*$")
  lst_files <- split(files, zips)
  zips <- unique(zips)
  lst_files <- lapply(zips, function(name) lst_files[[ name ]])
  zip_upper <- gsub("/[^/]*$", "", zips)
  zip_name <- stringr::str_extract(zips, "[^/]*$")
  exdir <- paste0(zip_upper, "/.temp_", zip_name)
  lst <- pbapply::pblapply(1:length(lst_files),
    function(n) {
      utils::unzip(zips[n], exdir = exdir[n])
      files <- paste0(exdir[n], "/", lst_files[[ n ]])
      lst <- lapply(files, fun)
      unlink(exdir[n], T)
      return(lst)
    })
  lst <- unlist(lst, F)
  names(lst) <- paste0(zips, "/", unlist(lst_files))
  return(lst)
}

.get_methods_match_sirius.v5 <- .get_methods_match_sirius.v4
# ==========================================================================
# Get hexadecimal color with ggsci package
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
#' @importFrom ggsci pal_simpsons
#' @importFrom ggsci pal_igv
#' @importFrom ggsci pal_ucscgb
#' @importFrom ggsci pal_d3
.get_color_set <- 
  function(){
    unique(c(rev(ggsci::pal_d3("category20")(20))[-3],
             ggsci::pal_simpsons()(16)[-3],
             ggsci::pal_ucscgb()(6)
             ))
  }

.get_color_col <- 
  function(){
    unique(c(ggsci::pal_simpsons()(16),
             ggsci::pal_igv("default")(51),
             ggsci::pal_ucscgb()(26),
             ggsci::pal_d3("category20")(20)
             ))
  }

.get_color_gradient <- 
  function(){
    c("#D5E4A2FF", "#FFCD00FF", "#EEA236FF", "#FB6467FF", "#9467BDFF")
  }

.get_label_color <- 
  function(){
    colorRampPalette(c("#C6DBEFFF", "#3182BDFF", "red"))(10)
  }

#' @importFrom ggsci pal_locuszoom
.get_color_stat <- 
  function(){
    col <- ggsci::pal_locuszoom()(7)
    vapply(col, .depigment_col, "ch", USE.NAMES = F)
  }
# ==========================================================================
# functions to get 'command' of ggplot, grob for visualizing nebulae
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
#' @importFrom ggraph geom_edge_fan
#' @importFrom ggraph geom_node_point
#' @importFrom ggraph scale_edge_width
#' @importFrom stringr str_wrap
#' @importFrom stringr str_wrap
.command_parent_edge <- function(edge_color = "lightblue"){
  new_command(ggraph::geom_edge_fan,
              aes(edge_width = similarity),
              color = edge_color
  )
}

.command_parent_node <- function(){
  new_command(ggraph::geom_node_point,
              aes(size = ifelse(is.na(tani.score), 0.2, tani.score),
                  fill = mz),
              shape = 21)
}

.command_parent_fill <- function(pal){
  new_command(scale_fill_gradientn, colours = pal, na.value = "white")
}

.command_parent_fill2 <- function(pal){
  new_command(scale_fill_manual, values = pal)
}

.command_parent_labs <- function(){
  new_command(labs, fill = "m/z", size = "Tanimoto similarity",
              edge_width = "Spectral similarity")
}

.command_parent_edge_width <- function(){
  new_command(scale_edge_width, range = c(0, 0.7))
}

.command_scale_x <- function(data, factor = 1.05){
  new_command(scale_x_continuous, limits = zoRange(data$x, factor))
}

.command_scale_y <- function(data, factor = 1.05){
  new_command(scale_y_continuous, limits = zoRange(data$y, factor))
}

.command_parent_theme <- function(){
  new_command(match.fun(theme),
              text = element_text(family = .font, face = "bold"),
              axis.ticks = element_blank(),
              axis.text = element_blank(),
              axis.title = element_blank(),
              panel.grid = element_blank(),
              panel.background = element_rect(fill = "white"),
              legend.background = element_rect(fill = "transparent"),
              name = "theme"
  )
}

.command_child_title <-
  function(title){
    new_command(ggtitle, stringr::str_wrap(title, width = 30))
  }

.command_child_theme <- 
  function(fill){
    command <- .command_parent_theme()
    command_args(command)[[ "plot.title" ]] <-
      call_command(.command_title_textbox(fill))
    command
  }

.command_title_textbox <- 
  function(fill){
    new_command(.element_textbox, fill = fill)
  }

.command_node_nuclear <- 
  function(color){
    new_command(geom_ribbon, fill = color,
                aes(ymin = -5L, ymax = 0L,
                    x = seq(0, max(seq) + 1, length.out = length(seq)))
    )
  }

.command_node_border <- 
  function(){
    new_command(geom_ribbon, fill = "black",
                aes(ymin = 0, ymax = 1.1,
                    x = seq(0, max(seq) + 1, length.out = length(seq)))
    )
  }

.command_node_radial_bar <- 
  function(){
    new_command(geom_col, aes(x = seq, y = pp.value,
                              fill = reorder(paste0(rel.index), rel.index)),
                color = "white", size = 0.25)
  }

.command_node_fill <- 
  function(pal, labels){
    new_command(scale_fill_manual, values = pal, labels = labels)
  }

.command_node_ylim <- 
  function(){
    new_command(ylim, ... = c(-5, 1.3))
  }

.command_node_polar <- 
  function(){
    new_command(coord_polar)
  }

.command_node_theme <- 
  function(){
    new_command(match.fun(theme),
                text = element_text(family = .font, face = "bold"),
                name = "theme")
  }

.command_node_ration <- 
  function(df){
    new_command(geom_tile, data = df, size = 0.2, color = "white",
                aes(y = -2.5, x = x, width = width,
                    height = 2.5, fill = group))
  }

#' @importFrom ggimage geom_subview
.command_node_annotate <- 
  function(data, subview){
    new_command(ggimage::geom_subview, data = data, 
                aes(x = x, y = y, width = size, height = size),
                subview = subview)
  }


.grob_legend_hierarchy_plot <- 
  function(color, theme){
    df <- data.frame(h = names(color), color = color, y = 1:length(color))
    p <- ggplot(df) +
      geom_tile(aes(x = 1, y = h, fill = h)) +
      labs(fill = "Class hierarchy") +
      scale_fill_manual(values = color) +
      guides(fill = guide_legend(nrow = 1, direction = "horizontal")) +
      theme
    .get_legend(p)
  }

.grob_node_text <- 
  function(label, color = "black"){
    grid::textGrob(label, y = 0.12,
                   gp = grid::gpar(fontfamily = .font,
                                   fontsize = 20, col = color))
  }
# ==========================================================================
# functions to get export setting
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.get_export_name <- 
  function(){
    set <- c(
             mz = "m/z",
             pre.mz = "Precursor m/z",
             rt.min = "RT (min)",
             similarity = "Spectral similarity",
             tani.score = "Tanimoto similarity",
             rel.index = "Relative index",
             rel.int. = "Relative intensity",
             tracer = "Tracer",
             group = "Group",
             .features_id = "ID",
             mol.formula = "Formula",
             inchikey2d = "InChIKey planar",
             error.mass = "Mass error (ppm)",
             synonym = "Synonym",
             adduct = "Adduct"
    )
  }
# ==========================================================================
# algorithmic functions used in methods-*.R files
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.rank_by_csi.score <- 
  function(df){
    head( dplyr::arrange(df, desc(csi.score)), n = 1)
  }

.rank_by_default <- 
  function(df){
    head(df, n = 1)
  }

.filter_ppcp_by_threshold <- 
  function(df, pp.threshold = 0.5){
    dplyr::filter(df, pp.value > pp.threshold)
  }

.decrease_edges <-
  function(edges, max_edge_number = 5){
    ## order
    edges <- edges[order(edges$similarity, decreasing = T), ]
    edges[[ "...SEQ" ]] <- 1:nrow(edges)
    freq <- table(c(edges[[ ".features_id1" ]], edges[[ ".features_id2" ]]))
    ## at least loop number
    while (max(freq) > max_edge_number) {
      target_id <- names(freq[freq == max(freq)])[1]
      ## get ...SEQ of the edges which need to be excluded
      include <- edges[[ ".features_id1" ]] == target_id |
        edges[[ ".features_id2" ]] == target_id
      edges_include_target <- edges[include, ]
      seq_exclude_edges <- edges_include_target[-(1:max_edge_number), ]$...SEQ
      ## exclude edges
      edges <- edges[!edges$...SEQ %in% seq_exclude_edges, ]
      freq <- table(c(edges[[ ".features_id1" ]], edges[[ ".features_id2" ]]))
    }
    edges[[ "...SEQ" ]] <- NULL
    edges
  }
# ==========================================================================
# functions to modify 'ggset' object
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
#' @aliases fun_modify
#'
#' @title Modify 'ggset' object
#'
#' @description
#' These are multiple functions used for post modification of [ggset-class]
#' object. These functions provide a convenient, fast, and repeatable way
#' to make improvements to [ggset-class] object.
#'
#' @param ggset [ggset-class] object.
#' @param x [mcnebula-class] object.
#' 
#' @seealso [ggset-class]
#'
#' @name fun_modify
NULL
#> NULL

#' @export modify_default_child
#' @aliases modify_default_child
#' 
#' @description \code{modify_default_child}:
#' Used for \code{visualize_all()}.
#' \code{modify_rm_legend} + \code{modify_set_labs} + \code{modify_unify_scale_limits}.
#' In addition, if the 'use_tracer' is TRUE (see [set_nodes_color()]),
#' \code{modify_tracer_node} and \code{modify_color_edge} would be performed.
#' 
#' @rdname fun_modify
modify_default_child <- 
  function(ggset, x){
    x <- .get_missing_x(x, "mcnebula")
    maps <- .get_mapping2(ggset)
    if (maps[[ "fill" ]] == "tracer")
      ggset <- modify_color_edge(modify_tracer_node(ggset), "lightblue")
    modify_rm_legend(modify_set_labs(modify_unify_scale_limits(ggset)))
  }

#' @export modify_stat_child
#' @aliases modify_stat_child
#' 
#' @description \code{modify_stat_child}:
#' Repalce [scale_fill_gradientn()] with [scale_fill_gradient2()] in 'layers';
#' unify the "aes" scale except for "fill";
#' perfrom [modify_set_labs()];
#' only keep the legend for 'fill', and adjust its width;
#' move the position of the legend to the bottom;
#' remove the title of the legend.
#' 
#' @rdname fun_modify
modify_stat_child <- 
  function(ggset, x) {
    x <- .get_missing_x(x, "mcnebula")
    ## replace
    seq <- grep("scale_fill_gradientn", names(layers(ggset)))
    if (is.integer(seq) & length(seq) > 0)
      ggset <- delete_layers(ggset, seq)
    args <- list(low = "blue", mid = "grey90", high = "red", na.value = "white")
    pal <- palette_gradient(x)
    pal <- pal[names(pal) %in% names(args)]
    args <- .fresh_param(args, as.list(pal))
    breaks <- function(x) round(seq(floor(min(x)), ceiling(max(x)), length.out = 7), 1)
    command <- do.call(new_command, c(fun = scale_fill_gradient2,
                                      breaks = breaks, args,
                                      name = "scale_fill_gradient2"))
    ggset <- add_layers(ggset, command)
    ## unify and set labs
    aes_name <- names(.get_mapping2(ggset))
    ggset <- modify_unify_scale_limits(ggset, aes_name = aes_name[aes_name != "fill"])
    ggset <- modify_set_labs(ggset)
    ## ...
    args <- sapply(aes_name, simplify = F,
                   function(name) {
                     if (name == "fill")
                       guide_colorbar(title = NULL, barheight = grid::unit(.5, "line"))
                     else "none"
                   })
    if (any(grepl("^guides|ggplot2::guides", names(layers(ggset)))))
      ggset <- do.call(mutate_layer, c(list(x = ggset, layer = "guides"), args))
    else {
      command <- do.call(new_command,
                         c(fun = match.fun("guides"), args, name = "guides"))
      ggset <- add_layers(ggset, command)
    }
    ggset <- mutate_layer(ggset, "theme", legend.position = "bottom")
    attr(ggset, "modify") <- "rev.modify_stat_child"
    ggset
  }

rev.modify_stat_child <- 
  function(ggset){
    args <- sapply(names(.get_mapping2(ggset)), simplify = F,
                   function(name) {
                     if (name == "fill") "none" else NULL
                   })
    ggset <- do.call(mutate_layer, c(list(x = ggset, layer = "guides"), args))
    ggset <- mutate_layer(ggset, "theme", legend.position = "right")
    ggset
  }

#' @export modify_set_labs_and_unify_scale_limits
#' @aliases modify_set_labs_and_unify_scale_limits
#' 
#' @description \code{modify_set_labs_and_unify_scale_limits}:
#' \code{modify_set_labs} + \code{modify_unify_scale_limits}
#' 
#' @rdname fun_modify
modify_set_labs_and_unify_scale_limits <- 
  function(ggset, x){
    x <- .get_missing_x(x, "mcnebula")
    modify_set_labs(modify_unify_scale_limits(ggset))
  }

#' @export modify_annotate_child
#' @aliases modify_annotate_child
#' 
#' @description \code{modify_annotate_child}:
#' \code{modify_set_labs} + ...
#' (for parameters of \code{panel.grid} and \code{panel.background}
#' in [ggplot2::theme()]).
#' 
#' @rdname fun_modify
modify_annotate_child <- 
  function(ggset, x){
    x <- .get_missing_x(x, "mcnebula")
    mutate_layer(modify_set_labs(ggset), "theme",
                 panel.grid = element_line("white", inherit.blank = T),
                 panel.background = element_rect("grey92", color = NA,
                                                 inherit.blank = T))
  }

#' @export modify_rm_legend
#' @aliases modify_rm_legend
#' 
#' @description \code{modify_rm_legend}: remove the legend.
#' For parameter of \code{legend.position} in [ggplot2::theme()].
#' 
#' @rdname fun_modify
modify_rm_legend <- 
  function(ggset){
    mutate_layer(ggset, "theme", legend.position = "none")
  }

#' @export modify_tracer_node
#' @aliases modify_tracer_node
#' @description \code{modify_tracer_node}: Set the stroke for nodes in
#' Nebulae (network) as 0, and the color as 'transparent';
#' Override the node color (border color) in legend.
#' @rdname fun_modify
modify_tracer_node <- 
  function(ggset){
    seq <- grep("geom_node_point", names(layers(ggset)))
    ggset <- mutate_layer(ggset, seq, stroke = 0, color = "transparent")
    ## override the nodes boder color in legend 
    seq <- grep("^guides|ggplot2::guides", names(layers(ggset)))
    size_legend <- guide_legend(override.aes = list(stroke = .3, color = "black"))
    fill_legend <- guide_legend(override.aes = list(size = 4))
    if (length(seq) > 0)
      ggset <- mutate_layer(ggset, seq, size = size_legend, fill = fill_legend)
    else {
      command <- new_command(match.fun("guides"), size = size_legend,
                             fill = fill_legend, name = "guides")
      ggset <- add_layers(ggset, command)
    }
  }

#' @export modify_color_edge
#' @aliases modify_color_edge
#' @description \code{modify_color_edge}: Set color for edge.
#' @param color character(1).
#' @rdname fun_modify
modify_color_edge <- 
  function(ggset, color){
    seq <- grep("geom_edge_", names(layers(ggset)))
    mutate_layer(ggset, seq, color = color)
  }

#' @importFrom grid unit
#' @export modify_set_margin
#' @aliases modify_set_margin
#' 
#' @description \code{modify_set_margin}: reduce margin.
#' For parameter of \code{plot.margin} in [ggplot2::theme()].
#' 
#' @rdname fun_modify
modify_set_margin <- 
  function(ggset, margin = grid::unit(rep(-8, 4), "lines")){
    mutate_layer(ggset, "theme", plot.margin = margin)
  }

#' @export modify_unify_scale_limits
#' @aliases modify_unify_scale_limits
#' 
#' @description \code{modify_unify_scale_limits}:
#' Uniform mapping 'scale' for all Child-Nebulae.
#' Related to \code{ggplot2::scale_*} function.
#' Use \code{MCnebula2:::.LEGEND_mapping()} to get the possibly mapping.
#'
#' @param aes_name character. Specify which 'aes' to unify scale,
#' e.g., c("fill", "size", "edge_width").
#' 
#' @rdname fun_modify
modify_unify_scale_limits <- 
  function(ggset, x, aes_name = NA){
    x <- .get_missing_x(x, "mcnebula")
    .check_data(x, list(features_annotation = "create_features_annotation",
                        spectral_similarity = "compute_spectral_similarity"))
    layers_name <- names(layers(ggset))
    args <- as.list(.get_mapping2(ggset))
    if (is.logical(aes_name))
      aes_name <- .LEGEND_mapping()
    for (i in aes_name) {
      if (is.null(args[[ i ]])) {
        next
      }
      if (i == "edge_width") {
        attr <- spectral_similarity(x)[[ args[[i]] ]]
        fun <- paste0("scale_", i)
      } else {
        attr <- features_annotation(x)[[ args[[i]] ]]
        if (is.null(attr)) {
          attr <- attr(features_annotation(x), "extra_data")[[ args[[i]] ]]
          if (is.null(attr))
            stop(paste0("Not found attribute '", args[[i]],
                        "' in `features_annotation(x)`."))
        }
        fun <- paste0("scale_", i, "_continuous")
      }
      if (!is.numeric(attr)) {
        next
      }
      range <- range(attr, na.rm = T)
      seq <- grep(paste0("^scale_", i, "|^ggplot2::scale_", i), layers_name)
      if (length(seq) == 1) {
        ggset <- mutate_layer(ggset, seq, limits = range)
      } else if (length(seq) > 1) {
        stop(paste0("multiple layers of 'scale_", i,
             ".*", "' were found"))
      } else {
        ggset <-
          add_layers(ggset,
                     new_command(match.fun(fun),
                                 limits = range,
                                 name = fun
                                 ))
      }
    }
    ggset
  }

#' @export modify_set_labs_xy
#' @aliases modify_set_labs_xy
#'
#' @description \code{modify_set_labs_xy}:
#' According to names in slot \code{export_name} of [mcnebula-class] object
#' to rename the labs of x and y axis.
#' 
#' @rdname fun_modify
modify_set_labs_xy <- 
  function(ggset, x){
    x <- .get_missing_x(x, "mcnebula")
    .modify_set_labs(ggset, x, c("x", "y"))
  }

#' @export modify_set_labs
#' @aliases modify_set_labs
#' 
#' @description \code{modify_set_labs}:
#' According to names in slot \code{export_name} of [mcnebula-class] object
#' to rename the labs of legends.
#' 
#' @rdname fun_modify
modify_set_labs <- 
  function(ggset, x){
    x <- .get_missing_x(x, "mcnebula")
    .modify_set_labs(ggset, x)
  }

.modify_set_labs <- 
  function(ggset, x, ...) {
    export_name <- as.list(export_name(x))
    mapping <- vecter_unique_by_names(.get_mapping2(ggset, ...))
    args <- vapply(mapping, FUN.VALUE = "ch",
                   function(attr) {
                     if (is.null(export_name[[ attr ]]))
                       attr
                     else
                       export_name[[ attr ]]
                   })
    seq <- grep("^labs$|^ggplot2::labs$", names(layers(ggset)))
    if ( length(seq) == 1) {
      ggset <- do.call(mutate_layer, c(ggset, seq, args))
    } else if ( length(seq) > 1 ) {
      stop( "multiple layers of 'labs' were found" )
    } else {
      ggset <- do.call(add_layers,
                       c(ggset, do.call(new_command,
                                        c(match.fun(labs),
                                          args, name = "labs"))))
    }
    ggset
  }

#' @importFrom stringr str_extract
.get_mapping2 <-
  function(ggset, maps = .LEGEND_mapping()){
    args <- .get_mapping(ggset)
    pattern <- "[a-z|A-Z|.|_|0-9]{1,}"
    args[] <-
      stringr::str_extract(args,
                           paste0("(?<=\\()", pattern, "(?=\\),)",
                                  "|^", pattern, "$"))
    args[names(args) %in% maps]
  }

.LEGEND_mapping <- 
  function(){
    c("fill", "color", "colour", "alpha", "size", "edge_width")
  }

.get_mapping <- 
  function(ggset){
    unlist(lapply(unname(layers(ggset)),
                  function(com){
                    mapping <- command_args(com)$mapping
                    if (!is.null(mapping)) {
                      vapply(mapping, FUN.VALUE = "ch",
                             function(m) tail(paste0(m), 1))
                    }
                  }))
  }

# ==========================================================================
# functions used in 'report' or 'section' class 
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.write_block <- 
  function(command_name, ..., codes){
    args <- list(...)
    if (length(args) > 0) {
      lapply(names(args),
             function(name) {
               if (nchar(name) == 0)
                 stop("the args for r block must contain parameter names, ",
                      "e.g., 'eval = FALSE', 'echo = TRUE'")
             })
      args <- lapply(args,
                     function(arg) {
                       if (is.character(arg))
                         paste0("'", arg, "'")
                       else
                         arg
                     })
      args <- paste0(paste0(names(args), " = ", args),
                     collapse = ", ")
      leader <- paste0("```{", command_name, ", ", args, "}")
    } else {
      leader <- paste0("```{", command_name, "}")
    }
    end <- "```"
    c(leader, codes, end, "")
  }

.args_r_block <-
  function(){
    list(echo = T,
         eval = T,
         message = F
    )
  }

.args_r_block_table <-
  function(){
    list(echo = T,
         eval = T,
         message = F
    )
  }

.args_r_block_figure <-
  function(){
    list(echo = T,
         eval = T,
         message = F,
         fig.cap = "The figure"
    )
  }

nshow <- function(object){
  if (!is.null(object)) {
    show(object)
  }
}

textSh <- 
  function(..., sep = "", exdent = 4, ending = "\n",
           pre_collapse = F, collapse = "\n",
           pre_trunc = F, trunc_width = 200,
           pre_wrap = F, wrap_width = 60){
    text <- list(...)
    if (pre_collapse) {
      text <- vapply(text, paste, "ch", collapse = collapse)
    }
    text <- paste(text, sep = sep)
    if (pre_trunc) {
      text <- .text_fold(text, trunc_width)
    }
    if (pre_wrap) {
      text <- paste0(strwrap(text, width = wrap_width), collapse = "\n")
    }
    exdent <- paste0(rep(" ", exdent), collapse = "")
    writeLines(gsub("(?<=\n)|(?<=^)", exdent, text, perl = T))
    if (!is.null(ending))
      cat(ending)
  }

#' @importFrom stringr str_trunc
.text_fold <- 
  function(text, width = 200, ellipsis = crayon::silver("...(fold)")){
    stringr::str_trunc(text, width = width, ellipsis = ellipsis)
  }

.part <-
  function(...){
    args <- list(...)
    unlist(lapply(args,
                  function(obj) {
                    if (!is.null(obj))
                      c(obj, "")
                  }))
  }

get_history <- 
  function(exclude = 0){
    file1 <- tempfile("Rrawhist")
    savehistory(file1)
    rawhist <- readLines(file1)
    unlink(file1)
    if (exclude > 0) {
      exclude <- (length(rawhist) - exclude + 1):length(rawhist)
      rawhist <- rawhist[-exclude]
    }
    rawhist
  }

#' @importFrom bookdown pdf_document2
#' @importFrom BiocStyle pdf_document
#' @importFrom BiocStyle html_document
default_pdf <- bookdown::pdf_document2
bioc_pdf <- BiocStyle::pdf_document
bioc_html <- BiocStyle::html_document

# ==========================================================================
# get or modify 'yaml' for 'report'
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
.yaml_default <- 
  function(style = c("default", "BiocStyle", "BiocStyle_pdf")){
    style <- match.arg(style)
    readLines(system.file("extdata", paste0(style, ".yml"),
                                 package = "MCnebula2"))
  }
# ==========================================================================
# additional function
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
#' @importFrom stats dist hclust model.matrix reorder rnorm
#' @importFrom utils combn head methods object.size savehistory str tail
#' @importFrom utils write.table
setMissing <- 
  function(generic, ..., .SIG = "missing"){
    args <- list(...)
    sig <- getGeneric(generic)@signature
    res <- vapply(sig, FUN.VALUE = "character",
                  function(name){
                    if (is.null(args[[ name ]]))
                      .SIG
                    else
                      args[[ name ]]
                  })
    names(res) <- sig
    return(res)
  }

reCallMethod <- 
  function(funName, args, ...){
    arg.order <- unname(getGeneric(funName)@signature)
    args.missing <- !arg.order %in% names(args)
    if (any(args.missing)) {
      args.missing <- arg.order[args.missing]
      args.missing <- sapply(args.missing, simplify = F,
                             function(x) structure(0L, class = "missing"))
      args <- c(args, args.missing)
    }
    args <- lapply(arg.order, function(i) args[[i]])
    sig <- get_signature(args)
    method <- selectMethod(funName, sig)
    last_fun <- sys.function(sys.parent())
    n <- 0
    while (identical(last_fun, method@.Data, ignore.environment = T)) {
      if (n == 0) {
        mlist <- getMethodsForDispatch(getGeneric(funName))
      }
      n <- n + 1
      rm(list = paste0(method@defined, collapse = "#"), envir = mlist)
      method <- selectMethod(funName, sig, mlist = mlist)
    }
    expr <- paste0("method@.Data(",
                   paste0(paste0(arg.order, " = args[[",
                                 1:length(arg.order), "]]"),
                          collapse = ", "),
                   ", ...)")
    eval(parse(text = expr))
  }

get_signature <- 
  function(args){
    vapply(args, function(arg) class(arg)[1], FUN.VALUE = "ch")
  }

match_methods <- 
  function(name, classes){
    methods <- showMethods(classes = classes, printTo = FALSE)
    methods <- methods[ grep(paste0("^Function: ", name), methods, perl = T) ]
    vapply(strsplit(methods, " "), `[`, "character", 2)
  }

vecter_unique_by_names <- 
  function(lst){
    unique <- data.frame(names = names(lst),
                         order = 1:length(lst))
    unique <- unique[!duplicated(unique$names), ]
    lst[unique$order]
  }

vec_unique_by_value <- 
  function(vec){
    unique <- data.frame(value = vec,
                         order = 1:length(vec))
    unique <- unique[!duplicated(unique$value), ]
    vec[unique$order]
  }


slots_mapply <- 
  function(x, fun, ...){
    slots <- attributes(x)
    slots <- slots[-length(slots)]
    res <- mapply(fun, slot = slots, name = names(slots), ...)
    return(res)
  }


mapply_rename_col <- 
  function(
           mutate_set,
           replace_set,
           names,
           fixed = F
           ){
    envir <- environment()
    mapply(mutate_set, replace_set,
           MoreArgs = list(envir = envir, fixed = fixed),
           FUN = function(mutate, replace, envir,
                          fixed = F, names = get("names", envir = envir)){
             names <- gsub(mutate, replace, names, perl = ifelse(fixed, F, T), fixed = fixed)
             assign("names", names, envir = envir)
           })
    return(names)
  }


.show <- 
  function(object){
    cat(class(object), "\n")
    slots_mapply(object, function(names, slots){
              cat(names, ":\n", sep = "")
              cat(str(slots))
              cat("\n\n")
           })
  }

# # ------------------------------------- 
.message_info <- 
  function(main, sub, arg = NULL, sig = "##"){
    message(sig, " ", main, ": ", sub, " ", arg)
  }

.message_info_formal <- 
  function(main, sub, arg = NULL, sig = "[INFO]"){
    message(sig, " ", main, ": ", sub, " ", arg)
  }

#' @importFrom grid current.viewport
.message_info_viewport <- 
  function(info = "info"){
    .message_info(info, "current.viewport:",
                  paste0("\n\t", paste0(grid::current.viewport())))
  }

.get_missing_x <- 
  function(x, class, n = 2, envir = parent.frame(n)){
    if (missing(x)) {
      x <- get("x", envir = envir)
      if (!is(x, class)) {
        stop( paste0("there must be an `x` of '", class, 
                     "' in `parent.frame(", n - 1, ")`" ) )
      }
    }
    return(x)
  }


#' @importFrom rlang as_label
.check_data <- 
  function(object, lst, tip = "(...)"){
    target <- rlang::as_label(substitute(object))
    mapply(lst, names(lst), FUN = function(value, name){
             obj <- match.fun(name)(object)
             if (is.null(obj)) {
               stop(paste0("is.null(", name, "(", target, ")) == T. ",
                           "use `", value, tip, "` previously."))
             }
             if (is.list(obj)) {
               if (length(obj) == 0) {
                 stop(paste0("length(", name, "(", target, ")) == 0. ",
                             "use `", value, tip, "` previously."))
               }
             }
           })
  }

.check_names <- 
  function(param, formal, tip1, tip2){
    if (!is.null(names(param))) {
      if ( any(!names(formal) %in% names(param)) ) {
        stop(paste0("the names of `", tip1, "` must contain all names of ",
                    tip2, "; or without names."
                    ))
      }
    }
  }

#' @importFrom rlang as_label
.check_class <- 
  function(object, class = "layout", tip = "grid::grid.layout"){
    if (!is(object, class)) {
      stop(paste0("`", rlang::as_label(substitute(object)),
                  "` should be a '", class, "' object created by ",
                  "`", tip, "`." ))
    }
  }

.check_columns <- 
  function(obj, lst, tip){
    if (!is.data.frame(obj))
      stop(paste0("'", tip, "' must be a 'data.frame'."))
    lapply(lst, function(col){
             if (is.null(obj[[ col ]]))
               stop(paste0("'", tip, "' must contains a column of '", col, "'."))
           })
  }

.check_type <- 
  function(obj, type, tip){
    fun <- match.fun(paste0("is.", type))
    apply(obj, 2, function(col){
            if (!fun(col))
              stop(paste0("data columns in '", tip, "' must all be '", type, "'."))
           })
  }

.check_path <- 
  function(path){
    if (!file.exists(path)) {
      dir.create(path, recursive = T)
    }
  }

.check_file <- 
  function(file){
    if (!file.exists(file)) {
      stop("file.exists(file) == F, `file` not exists.")
    }
  }

validate_class_in_list <- 
  function(lst, recepts, tip){
    check <- 
      lapply(lst, function(layer) {
               check <- lapply(recepts, function(class) {
                                 if (is(layer, class)) T })
               if (any(unlist(check))) T else F
           })
    if (any(!unlist(check)))
      stop(tip)
    else T
  }

.suggest_bio_package <- 
  function(pkg){
    if (!requireNamespace(pkg, quietly = T))
      stop("package '", pkg, "' not installed. use folloing to install:\n",
           '\nif (!require("BiocManager", quietly = TRUE))',
           '\n\tinstall.packages("BiocManager")',
           '\nBiocManager::install("', pkg, '")\n\n')
  }

read_tsv <- function(path){
  file <- data.table::fread(input=path, sep="\t", header=T, quote="", check.names=F)
  return(file)
}

pbsapply_read_tsv <- function(path){
  data <- pbapply::pbsapply(path, read_tsv, simplify = F)
  return(data)
}

write_tsv <-
  function(x, filename, col.names = T, row.names = F){
    write.table(x, file = filename, sep = "\t",
                col.names = col.names, row.names = row.names, quote = F)
  }


#' @importFrom grid unit
#' @importFrom ggtext element_textbox
.element_textbox <- 
  function(family = NULL, face = NULL, size = NULL,
           colour = "white", fill = "lightblue",
           box.colour = "white", linetype = 1, linewidth = NULL,
           hjust = NULL, vjust = NULL,
           halign = 0.5, valign = NULL, lineheight = NULL,
           margin = match.fun("margin")(3, 3, 3, 3),
           padding = match.fun("margin")(2, 0, 1, 0),
           width = grid::unit(1, "npc"),
           height = NULL, minwidth = NULL,
           maxwidth = NULL, minheight = NULL, maxheight = NULL,
           r = grid::unit(5, "pt"), orientation = NULL,
           debug = FALSE, inherit.blank = FALSE
           ){
    structure(as.list(environment()),
              class = c("element_textbox", "element_text", "element"))
  }


.get_legend <- 
  function(p){
    p <- ggplot2:::ggplot_build.ggplot(p)$plot
    theme <- ggplot2:::plot_theme(p)
    position <- theme$legend.position
    ggplot2:::build_guides(p$scales, p$layers, p$mapping,
                           position, theme, p$guides, p$labels)
  }

.depigment_col <- 
  function(col, n = 10, level = 5){
    colorRampPalette(c("white", col))(n)[level]
  }


.simulate_quant_set <- 
  function(x){
    quant <- .simulate_quant(features_annotation(x)$.features_id)
    meta <- group_strings(colnames(quant),
                          c(control = "^control", model = "^model",
                            treat = "^treat", pos = "^pos"), "sample")
    features_quantification(x) <- quant
    sample_metadata(x) <- meta
    return(x)
  }

#' @importFrom tibble as_tibble
.simulate_quant <- 
  function(.features_id, mean = 50, sd = 20, seed = 555,
           group = c("control", "model", "treat", "pos"), rep = 5){
    quant <- data.frame(.features_id = .features_id)
    set.seed(seed)
    lst <- lapply(1:(length(group) * rep), function(x){
                    rnorm(nrow(quant), mean, sd)
           })
    df <- apply(do.call(data.frame, lst), 2, abs)
    df <- df[, hclust(dist(t(df)))$order]
    colnames(df) <- unlist(lapply(group, paste0, "_", 1:rep))
    tibble::as_tibble(cbind(quant, df))
  }

group_strings <- 
  function(strings, patterns, target = NA){
    if (is.null(names(patterns)))
      stop("`patterns` must be characters with names.")
    lst <- .find_and_sort_strings(strings, patterns)
    lst <- lapply(names(lst), function(name){
                    data.frame(target = lst[[name]], group = name)
           })
    df <- do.call(rbind, lst)
    if (!is.na(target)) {
      colnames(df)[1] <- target
    }
    tibble::as_tibble(df)
  }

.find_and_sort_strings <- 
  function(strings, patterns){
    lapply(patterns,
           function(pattern){
             strings[grepl(pattern, strings, perl = T)]
           })
  }

.as_dic <- 
  function(vec, names, default,
           fill = T, as.list = T, na.rm = F){
    if (is.null(names(vec)))
      names(vec) <- names[1:length(vec)]
    if (fill) {
      if (any(!names %in% names(vec))) {
        ex.names <- names[!names %in% names(vec)]
        ex <- rep(default, length(ex.names))
        names(ex) <- ex.names
        vec <- c(vec, ex)
      }
    }
    if (as.list) {
      if (!is.list(vec))
        vec <- as.list(vec)
    }
    if (na.rm) {
      vec <- vec[!is.na(names(vec))]
    }
    vec
  }

.fresh_param <- 
  function(default, args){
    if (missing(args))
      args <- as.list(parent.frame())
    args <- args[ !vapply(args, is.name, T) ]
    sapply(unique(c(names(default), names(args))),
           simplify = F,
           function(name){
             if (any(name == names(args)))
               args[[ name ]]
             else
               default[[ name ]]
           })
  }


#' @importFrom grImport2 readPicture
#' @importFrom grImport2 grobify
.cairosvg_to_grob <- 
  function(path){
    grImport2::grobify(grImport2::readPicture(path))
  }

checkColMerge <- function(x, y, ...){
  args <- list(...)
  by <- args$by
  col <- lapply(list(x, y),
                function(df){
                  colnames(df)[ !colnames(df) %in% by ]
                })
  discard <- col[[2]][col[[2]] %in% col[[1]]]
  y <- y[, !colnames(y) %in% discard]
  if (!is.data.frame(y))
    return(x)
  args <- c(list(x = x, y = y), args)
  do.call(merge, args)
}

zoRange <- function(x, factor) {
  x <- range(x)
  ex <- abs(x[2] - x[1]) * (factor - 1)
  x[1] <- x[1] - ex
  x[2] <- x[2] + ex
  return(x)
}


## default font for visualization
# @importFrom grDevices pdfFonts
# .setFont <- function(pattern){
  # font <- names(pdfFonts())
  # n <- grep(pattern, font)
  # if (length(n) >= 1) {
  #   font <- font[n[1]]
  # } else {
  #   font[1]
  # }
# }

# .font <- if (.Platform$OS.type == 'unix') "Times" else "Times New Roman"

#' @export setFont
#' @title Set font for visualization of MCnebula2
#' @description \bold{Note that} your R harbours the font you set.
#' @param font character(1). Such as 'Times'. If you output the
#' visualization for pdf, use \code{grDevices::pdfFonts()} to checkout
#' the available fonts; else, you might need help with package \code{extrafont}.
#' @rdname setFont
setFont <- function(font = "Times") {
  assign(".font", font, env = topenv(environment()))
  options(mcnebulaFont = font)
}
.font <- "Times"
setFont("Times")

```

